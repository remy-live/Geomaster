<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©oMaster</title>
    <style>
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #333;
            margin-top: -6px;
        }

        input[type="range"]::-moz-range-thumb {
            border: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #333;
        }

        input[type="range"]:focus {
            outline: none;
        }

        .editor-toolbar {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
            width: 100%;
        }

        #fontFamilyInput {
            flex: 2;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px;
            font-size: 12px;
            outline: none;
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
        }

        #fontSizeInput {
            flex: 1;
            width: 50px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 12px;
            outline: none;
            background: rgba(255, 255, 255, 0.95);
        }

        #textEditor {
            background: transparent;
            padding: 6px;
            border-radius: 8px;
            position: absolute;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            transform: translate(-50%, -50%);
            border: none;
            box-shadow: none;
        }

        #textInput {
            border: 1px dashed #2980b9;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            padding: 4px 8px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            text-align: center;
            outline: none;
            width: 140px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #textInput:focus {
            border-color: #1976d2;
            border-style: solid;
        }

        .editor-buttons {
            display: flex;
            gap: 4px;
            background: white;
            padding: 3px;
            border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        .editor-buttons button {
            border: none;
            background: #f0f2f5;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
        }

        .editor-buttons button:hover {
            transform: scale(1.1);
        }

        #btnTextSave {
            color: white;
            background: #27ae60;
        }

        #btnTextCancel {
            color: #c0392b;
            background: #fff;
            border: 1px solid #eee;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #eef2f5;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #ffffff;
            height: 50px;
            padding: 0 15px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-dropdown {
            position: relative;
            display: flex;
            align-items: center;
            height: 100%;
        }

        .header-dropdown-content {
            display: none;
            position: absolute;
            top: 90%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 5000;
            flex-direction: column;
            gap: 4px;
            min-width: 40px;
            align-items: center;
        }

        .header-dropdown:hover .header-dropdown-content {
            display: flex;
            animation: fadeIn 0.2s;
        }

        .header-dropdown .top-btn::after {
            content: '‚ñæ';
            font-size: 10px;
            margin-left: 2px;
            color: #999;
            position: absolute;
            bottom: 2px;
            right: 2px;
        }

        .logo {
            font-weight: 800;
            font-size: 18px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            margin-right: 4px;
            background: linear-gradient(45deg, #51728e, #51115c);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .top-toolbar {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding-right: 8px;
            margin-right: 8px;
            border-right: 1px solid #eee;
        }

        .toolbar-group:last-child {
            border: none;
            padding-right: 0;
            margin-right: 0;
        }

        .top-btn {
            width: 34px;
            height: 34px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .top-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2px;
        }

        .top-btn:hover {
            background: #f0f0f0;
            color: #000;
            border-color: #e0e0e0;
        }

        .top-btn:active {
            transform: scale(0.95);
        }

        .top-btn.active {
            background: #222;
            color: #fff;
            border-color: #222;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .top-btn.danger:hover {
            background: #fff0f0;
            color: #d32f2f;
            border-color: #ffcdd2;
        }

        .top-btn:disabled {
            opacity: 0.2;
            cursor: default;
        }

        .top-btn span.icon {
            font-size: 16px;
        }

        #fileInput {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            height: calc(100% - 50px);
            position: relative;
        }

        .toolbar {
            width: 90px;
            min-width: 90px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 8px;
            align-content: start;
            padding: 12px 8px;

            z-index: 10;
            overflow-y: auto;
            overflow: visible !important;
            gap: 4px;
            padding-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .group-label {
            grid-column: span 2;
            font-size: 9px;
            color: #8898aa;
            margin-top: 12px;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 700;
            width: 100%;
            text-align: center;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 4px;
            display: none
        }

        .tool-sep {
            grid-column: span 2;
            height: 1px;
            background-color: #f0f0f0;
            margin: 4px 0;
        }

        .tool-btn {
            position: relative;
            width: 100%;
            height: 42px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #546e7a;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .tool-btn svg {
            width: 22px;
            height: 22px;
        }

        .tool-btn:hover {
            background: #f8f9fa;
            color: #2c3e50;
            border-color: #cfd8dc;
            transform: translateY(-1px);
            z-index: 1000;
        }

        .tool-btn.active {
            background-color: #e3f2fd;
            color: #1976d2;
            border-color: #90caf9;
        }

        .tool-btn.widget-active {
            background-color: #fff3e0;
            color: #e67e22;
            border-color: #ffe0b2;
            box-shadow: inset 0 0 0 2px #ffe0b2;
        }

        .tool-btn.delete-btn {
            color: #e74c3c;
        }

        .tool-btn.delete-btn:hover {
            background: #ffebee;
            border-color: #ffcdd2;
            color: #c0392b;
        }

        .tool-btn.delete-btn.active {
            background-color: #ffebee;
            color: #d32f2f;
            border-color: #ffcdd2;
        }

        .tool-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
            background: #2c3e50;
            color: white;
            padding: 5px 10px;
            font-size: 11px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .justify-center {
            justify-content: center;
        }

        .canvas-container {
            flex-grow: 1;
            width: 0;
            background-color: #f5f7fa;
            display: block;
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .tool-btn.export-btn {
            flex-direction: column;
            gap: 0px;
            padding: 2px;
            height: 42px;
        }

        .tool-btn.export-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 1.5;
        }

        .tool-btn.export-btn span {
            font-size: 9px;
            font-weight: 800;
            line-height: 1;
            color: #555;
            text-transform: uppercase;
        }

        .tool-btn.simple-icon {
            border: none;
            background: transparent;
            padding: 4px;
        }

        .tool-btn.simple-icon:hover {
            background-color: transparent;
            color: #2980b9;
        }

        .tool-btn.export-btn:hover span {
            color: #2980b9;
        }

        canvas {
            display: block;
            background-color: #ffffff;
            box-shadow: none;
            border-radius: 0;
        }

        #replayBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding: 8px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s;
        }

        .replay-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            border-right: 1px solid #ddd;
            padding-right: 15px;
        }

        .replay-control-group:last-child {
            border-right: none;
            padding-right: 0;
        }

        .replay-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: #555;
            padding: 5px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }

        .replay-btn:hover {
            background: #eee;
            color: #222;
            transform: scale(1.1);
        }

        .replay-btn.active {
            color: #2980b9;
            background: #e3f2fd;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .slider-container input {
            width: 80px;
            margin: 0;
            cursor: pointer;
        }

        .slider-icon {
            font-size: 8px;
            position: relative;
            top: -5px;
            color: #888;
            text-transform: uppercase;
            font-weight: bold;
        }

        body.interface-locked .toolbar,
        body.interface-locked .top-toolbar,
        body.interface-locked #contextMenu,
        body.interface-locked #textEditor {
            pointer-events: none;
            opacity: 0.5;
            filter: grayscale(0.8);
        }

        body.interface-locked canvas {
            cursor: not-allowed !important;
        }

        #contextMenu {
            display: none;
            position: fixed;
            z-index: 3000;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            padding: 10px;
            width: 190px;
            flex-direction: column;
            gap: 8px;
            animation: popIn 0.15s ease-out;
        }

        .menu-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 2px;
            flex-wrap: wrap;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            flex: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #444;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: #fff;
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-color: #bdc3c7;
        }

        .icon-btn.active {
            background: #2980b9;
            color: white;
            border-color: #2980b9;
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .icon-btn.trash {
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.2);
            background: rgba(231, 76, 60, 0.05);
            width: 100%;
        }

        .icon-btn.trash:hover {
            background: #ffebee;
            color: white;
        }

        .compact-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            appearance: none;
            background: #ddd;
            outline: none;
            max-width: 80px;
        }

        .compact-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #555;
            cursor: pointer;
        }

        .coding-grid {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr) !important;
            gap: 6px !important;
            width: 100%;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }

        .mark-btn {
            width: 100%;
            height: 32px;
            border-radius: 4px;
            background: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
        }

        .mark-btn:hover {
            background: #e3f2fd;
            border-color: #90caf9;
        }

        .mark-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        #rowAngle.menu-row {
            display: flex !important;
            flex-direction: row !important;
            justify-content: center !important;
            flex-wrap: nowrap !important;
        }

        .switch-container {
            display: flex;
            background-color: #eef2f5;
            padding: 4px;
            border-radius: 8px;
            gap: 2px;
            margin-bottom: 6px;
            border: 1px solid #e0e0e0;
        }

        .switch-btn {
            flex: 1;
            height: 28px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .switch-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            color: #555;
        }

        .switch-btn.active {
            background-color: #fff;
            color: #2980b9;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }

        .switch-btn svg {
            width: 18px;
            height: 18px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .btn-trash {
            width: 100%;
            margin-top: 4px;
            background: #fff0f0;
            color: #d32f2f;
            border: 1px solid #ffcdd2;
        }

        .btn-trash:hover {
            background: #ffebee;
            border-color: #e57373;
        }

        .label-positioner {
            width: 60px;
            height: 60px;
            margin: 0 auto;
            position: relative;
            border-radius: 50%;
            background: #f8f9fa;
            border: 1px solid #ddd;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
            cursor: crosshair;
        }

        .label-cross {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .label-cross::before {
            content: '';
            position: absolute;
            background: #ccc;
            width: 100%;
            height: 2px;
            top: 4px;
            left: 0;
        }

        .label-cross::after {
            content: '';
            position: absolute;
            background: #ccc;
            width: 2px;
            height: 100%;
            top: 0;
            left: 4px;
        }

        .label-knob {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #2980b9;
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: grab;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .label-knob:active {
            cursor: grabbing;
            background: #e67e22;
        }

        .label-preview {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 10px;
            color: #999;
            font-weight: bold;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .color-dot {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-dot:hover {
            transform: scale(1.2);
            z-index: 2;
        }

        .sep-h {
            width: 100%;
            height: 1px;
            background: rgba(0, 0, 0, 0.08);
            margin: 4px 0;
        }

        .vis-line {
            width: 18px;
            background: #444;
            border-radius: 1px;
        }

        .s-solid {
            height: 2px;
        }

        .s-dashed {
            height: 2px;
            border-bottom: 2px dashed #444;
            background: transparent;
        }

        .w-thin {
            height: 1px;
        }

        .w-med {
            height: 3px;
        }

        .w-thick {
            height: 5px;
        }

        .toggle-btn {
            background: #fff;
            border: 1px solid #ddd;
            padding: 6px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            box-sizing: border-box;
        }

        .toggle-btn:hover {
            background: #f9f9f9;
            border-color: #ccc;
        }

        .toggle-btn.active {
            background: #e3f2fd;
            color: #1976d2;
            border-color: #2196f3;
        }

        .cursor-move {
            cursor: move;
        }

        .cursor-grab {
            cursor: grab;
        }

        .cursor-grabbing {
            cursor: grabbing;
        }

        .cursor-ew {
            cursor: ew-resize;
        }

        .v-keyboard {
            display: none;
            position: absolute;
            z-index: 3000;
            width: 420px;
            background: rgba(230, 235, 240, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            flex-direction: column;
            gap: 4px;
            user-select: none;
        }

        .v-keyboard.visible {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .vk-drag-handle {
            width: 100%;
            height: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            margin-bottom: 2px;
        }

        .vk-drag-handle:active {
            cursor: grabbing;
        }

        .vk-drag-handle::after {
            content: '';
            width: 40px;
            height: 4px;
            background-color: #cbd5e1;
            border-radius: 2px;
        }

        .vk-row {
            display: flex;
            justify-content: center;
            gap: 3px;
        }

        .vk-btn {
            height: 28px;
            flex: 1;
            min-width: 24px;
            background: #fff;
            border: 1px solid #dae1e7;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
        }

        .vk-btn:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .vk-btn:active {
            transform: translateY(1px);
            background: #e2e8f0;
        }

        .vk-btn.special {
            background: #cbd5e1;
            color: #334155;
            font-size: 11px;
            max-width: 40px;
        }

        .vk-btn.space {
            flex: 4;
        }

        .vk-btn.active-shift {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .drag-handle {
            width: 100%;
            height: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            margin-bottom: 4px;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle::after {
            content: '';
            width: 40px;
            height: 4px;
            background-color: rgba(0, 0, 0, 0.15);
            border-radius: 2px;
        }

        .renamer-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 6px;
        }

        .renamer-display {
            flex: 1;
            text-align: center;
            font-weight: 800;
            font-size: 16px;
            color: #2c3e50;
            cursor: ns-resize;
            user-select: none;
            height: 28px;
            line-height: 28px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .renamer-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .renamer-btn:hover {
            background: #e3f2fd;
            color: #1976d2;
        }

        .renamer-btn:active {
            transform: scale(0.95);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s;
        }

        .modal-box {
            background: white;
            padding: 20px 25px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            transform: scale(0.95);
            animation: popIn 0.2s forwards;
        }

        .modal-text {
            font-size: 16px;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            border: none;
            font-family: inherit;
            transition: transform 0.1s;
        }

        .modal-btn:active {
            transform: scale(0.95);
        }

        .modal-cancel {
            background: #f0f2f5;
            color: #555;
        }

        .modal-cancel:hover {
            background: #e4e6eb;
        }

        .modal-confirm {
            background: #3498db;
            color: white;
        }

        .modal-confirm:hover {
            background: #2980b9;
        }

        .modal-confirm.danger {
            background: #e74c3c;
        }

        .modal-confirm.danger:hover {
            background: #c0392b;
        }

        .header-color-row {
            display: flex;
            gap: 2px;
            margin-right: 8px;
            background: #f5f5f5;
            padding: 2px;
            border-radius: 12px;
            border: 1px solid #eee;
        }

        .header-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.1s;
        }

        .header-dot:hover {
            transform: scale(1.2);
            z-index: 2;
        }

        .header-dot.active {
            border: 2px solid #000;
        }

        #docTitleInput {
            width: 100px;
            padding: 6px 6px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            outline: none;
        }

        #docTitleInput:hover {
            background: #fff;
            border-color: #b0bec5;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        #docTitleInput:focus {
            background: #fff;
            border-color: #2196f3;
            color: #000;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
            width: 160px;
        }

        .help-box {
            width: 500px;
            max-width: 95%;
            text-align: left;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        .help-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-header h2 {
            margin: 0;
            font-size: 18px;
            color: #2c3e50;
        }

        .close-help {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #7f8c8d;
        }

        .close-help:hover {
            color: #c0392b;
        }

        .help-content {
            padding: 20px;
            overflow-y: auto;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            font-size: 14px;
            text-transform: uppercase;
            color: #2980b9;
            border-bottom: 2px solid #e3f2fd;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .help-section p,
        .help-section li {
            font-size: 14px;
            color: #444;
            line-height: 1.5;
        }

        .help-footer {
            background: #f8f9fa;
            padding: 10px;
            text-align: center;
            font-size: 11px;
            color: #95a5a6;
            border-top: 1px solid #eee;
        }

        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
            color: #333;
            display: inline-block;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
            padding: 2px 4px;
            white-space: nowrap;
            font-family: monospace;
        }

        .shortcut-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .sc-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #555;
        }

        #instructionBox {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 300px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 200px;
        }

        .instr-header {
            background: #f1f3f4;
            padding: 8px 12px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            font-weight: bold;
            color: #555;
            font-size: 13px;
            user-select: none;
        }

        .instr-close {
            border: none;
            background: none;
            cursor: pointer;
            font-weight: bold;
            color: #999;
        }

        .instr-close:hover {
            color: red;
        }

        .instr-toolbar {
            display: flex;
            padding: 4px;
            background: #fff;
            border-bottom: 1px solid #eee;
            gap: 2px;
            flex-wrap: wrap;
        }

        .instr-toolbar button {
            border: 1px solid transparent;
            background: white;
            cursor: pointer;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            color: #444;
        }

        .instr-toolbar button:hover {
            background: #f0f0f0;
            border-color: #ddd;
        }

        .instr-sep {
            width: 1px;
            background: #ddd;
            margin: 0 4px;
        }

        #instrContent {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            outline: none;
            line-height: 1.5;
            color: #333;
            max-height: 400px;
        }

        #instrContent h3 {
            margin-top: 0;
            font-size: 16px;
            color: #2980b9;
            border-bottom: 2px solid #eee;
            padding-bottom: 4px;
        }

        #instrContent ul {
            padding-left: 20px;
            margin: 5px 0;
        }

        #toast-notification {
            visibility: hidden;
            min-width: 250px;
            background-color: rgba(44, 62, 80, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 12px 24px;
            position: fixed;
            z-index: 6000;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
        }

        #toast-notification.show {
            visibility: visible;
            opacity: 0.8;
            bottom: 50px;
        }

        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            background: #222;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: sans-serif;
            white-space: nowrap;
            z-index: 7000;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease-out;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            z-index: 10000;
            transition-delay: 0.5s;
        }
    </style>
</head>

<div id="helpModal" class="modal-overlay" onclick="if(event.target === this) app.toggleHelp()">
    <div class="modal-box help-box">
        <div class="help-header">
            <h2>Guide Rapide G√©oSoft</h2>
            <button class="close-help" onclick="app.toggleHelp()">‚úï</button>
        </div>
        <div class="help-content">

            <div class="help-section">
                <h3>üñ±Ô∏è Souris & Interaction</h3>
                <p><strong>Clic Gauche :</strong> S√©lectionner, D√©placer, Cr√©er des points.</p>
                <p><strong>Clic Droit :</strong> Menu Contextuel (Couleur, √âpaisseur, Hachures, Nom).</p>
                <p><strong>Molette :</strong> Zoomer / D√©zoomer.</p>
                <p><strong>Clic Molette (ou Espace + Glisser) :</strong> Bouger la feuille (Pan).</p>
            </div>

            <div class="help-section">
                <h3>‚å®Ô∏è Raccourcis Clavier</h3>
                <div class="shortcut-grid">
                    <div class="sc-row"><kbd>Ctrl</kbd> + <kbd>Z</kbd> <span>Annuler</span></div>
                    <div class="sc-row"><kbd>Ctrl</kbd> + <kbd>Y</kbd> <span>R√©tablir</span></div>
                    <div class="sc-row"><kbd>Suppr</kbd> <span>Supprimer la s√©lection</span></div>
                    <div class="sc-row"><kbd>Echap</kbd> <span>Annuler l'outil / D√©s√©lectionner</span></div>
                    <div class="sc-row"><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> <span>D√©placement pr√©cis
                            (1px)</span></div>
                </div>
            </div>

            <div class="help-section">
                <h3>üí° Astuces Outils</h3>
                <ul style="text-align: left; padding-left: 20px; margin: 5px 0;">
                    <li><strong>R√®gle / Rapporteur :</strong> Cliquez au centre pour d√©placer, sur les bords pour
                        tourner.</li>
                    <li><strong>Compas :</strong> Tirez la branche crayon pour √©carter. Cliquez sur la poign√©e haute
                        pour tourner.</li>
                    <li><strong>Polygone :</strong> Cliquez sur le 1er point pour fermer la forme.</li>
                    <li><strong>Sym√©trie :</strong> Cliquez d'abord sur l'objet √† transformer, puis sur l'axe (ou le
                        centre).</li>
                </ul>
            </div>

        </div>

        <div class="help-footer">
            G√©omaster v1.0 - Logiciel de G√©om√©trie Dynamique par DEVODDERE R√©my
        </div>
    </div>
</div>
<div id="instructionBox" style="display:none;">
    <div class="instr-header" id="instrDragHandle">
        <span>üìù Consignes</span>
        <button class="instr-close" onclick="app.toggleInstructions()">‚úï</button>
    </div>

    <div class="instr-toolbar">
        <button onmousedown="event.preventDefault(); document.execCommand('bold', false, null);"
            title="Gras"><b>B</b></button>
        <button onmousedown="event.preventDefault(); document.execCommand('italic', false, null);"
            title="Italique"><i>I</i></button>
        <button onmousedown="event.preventDefault(); document.execCommand('underline', false, null);"
            title="Soulign√©"><u>U</u></button>
        <div class="instr-sep"></div>
        <button onmousedown="event.preventDefault(); document.execCommand('insertUnorderedList', false, null);"
            title="Liste √† puces">‚Ä¢ Liste</button>
        <button onmousedown="event.preventDefault(); document.execCommand('formatBlock', false, '<h3>');"
            title="Titre">Titre</button>
        <button onmousedown="event.preventDefault(); document.execCommand('removeFormat', false, null);"
            title="Effacer style">üßπ</button>
    </div>

    <div id="instrContent" contenteditable="true" placeholder="√âcrivez vos consignes ici...">
        <h3>Exercice :</h3>
        <p>1. Tracez un triangle...</p>
    </div>
</div>
<div id="toast-notification">Message par d√©faut</div>

<body>
    <header>
        <div class="logo">G√©omaster</div>

        <input type="text" id="docTitleInput" value="Sans titre" placeholder="Nom du projet..."
            aria-label="Renommer le projet" data-tooltip="Renommer le projet">

        <div class="top-toolbar">

            <div class="toolbar-group">
                <button class="top-btn" id="btnPan" onclick="app.togglePanMode()"
                    aria-label="D√©placer la feuille (Main)" data-tooltip="D√©placer la feuille (Main)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" />
                        <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" />
                        <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
                        <path
                            d="M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
                    </svg>
                </button>
                <button class="top-btn" onclick="app.resetView()" aria-label="Recentrer la vue (100%)"
                    data-tooltip="Recentrer la vue (100%)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="10" />
                        <circle cx="12" cy="12" r="3" />
                        <line x1="22" y1="12" x2="18" y2="12" />
                        <line x1="6" y1="12" x2="2" y2="12" />
                        <line x1="12" y1="6" x2="12" y2="2" />
                        <line x1="12" y1="22" x2="12" y2="18" />
                    </svg>
                </button>
            </div>

            <div class="toolbar-group">
                <button class="top-btn danger" onclick="app.clearAll()" aria-label="Tout effacer"
                    data-tooltip="Tout effacer">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <polyline points="3 6 5 6 21 6" />
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                        <line x1="10" y1="11" x2="10" y2="17" />
                        <line x1="14" y1="11" x2="14" y2="17" />
                    </svg>
                </button>

                <button class="top-btn" onclick="document.getElementById('fileInput').click()"
                    aria-label="Ouvrir un fichier" data-tooltip="Ouvrir un fichier">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
                    </svg>
                </button>
                <input type="file" id="fileInput" accept=".geo" onchange="app.loadFile(this)">

                <button class="top-btn" onclick="app.saveFile()" aria-label="Sauvegarder" data-tooltip="Sauvegarder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                        <polyline points="17 21 17 13 7 13 7 21" />
                        <polyline points="7 3 7 8 15 8" />
                    </svg>
                </button>

                <button class="top-btn" onclick="app.exportSVG()" aria-label="Exporter en SVG"
                    data-tooltip="Exporter en SVG">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" y1="15" x2="12" y2="3" />
                    </svg>
                </button>

                <button class="top-btn" onclick="app.exportImage('png')" aria-label="Exporter l'image (PNG)"
                    data-tooltip="Exporter l'image (PNG)">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                </button>

                <button class="top-btn" id="btnCopy" onclick="app.copyToClipboard()"
                    aria-label="Copier la figure (Presse-papier)" data-tooltip="Copier la figure (Presse-papier)">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>
            </div>


            <div class="toolbar-group">
                <button class="top-btn" id="btnGrid" onclick="app.toggleGrid()" aria-label="Changer de Grille"
                    data-tooltip="Changer de Grille">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                        <line x1="3" y1="9" x2="21" y2="9" />
                        <line x1="3" y1="15" x2="21" y2="15" />
                        <line x1="9" y1="3" x2="9" y2="21" />
                        <line x1="15" y1="3" x2="15" y2="21" />
                    </svg>
                </button>
                <button class="top-btn" id="btnMagnet" onclick="app.toggleMagnet()" aria-label="Aimantation (Grille)"
                    data-tooltip="Aimantation (Grille)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 14v-9h4v9a5 5 0 0 0 10 0v-9h4v9a9 9 0 0 1-18 0Z" fill="currentColor"
                            fill-opacity="0.2" />
                        <line x1="3" y1="9" x2="7" y2="9" />
                        <line x1="17" y1="9" x2="21" y2="9" />
                    </svg>
                </button>
                <button class="top-btn" onclick="app.autoCodeSegments()" aria-label="Codage Automatique des longueurs"
                    data-tooltip="Codage Automatique des longueurs">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="m17 6 1 3 3 0.5-2.5 2 1 3L17 13l-2.5 1.5 1-3L13 9.5l3-0.5z" />
                        <path d="M15 12 4 22" />
                    </svg>
                </button>
            </div>

            <div class="toolbar-group">
                <div class="header-dropdown">
                    <button class="top-btn" aria-label="Style du Point" data-tooltip="Style du Point">
                        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none">
                            <circle cx="12" cy="12" r="3" fill="currentColor" />
                            <circle cx="12" cy="12" r="8" />
                        </svg>
                    </button>

                    <div class="header-dropdown-content">
                        <div class="icon-btn" id="btnPtCross" onclick="app.setGlobalPointStyle('cross')"
                            aria-label="Croix" data-tooltip="Croix">
                            <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="3" fill="none">
                                <path d="M6 6l12 12M18 6l-12 12" />
                            </svg>
                        </div>
                        <div class="icon-btn" id="btnPtDot" onclick="app.setGlobalPointStyle('dot')" aria-label="Disque"
                            data-tooltip="Disque">
                            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                <circle cx="12" cy="12" r="5" />
                            </svg>
                        </div>
                        <div class="icon-btn" id="btnPtPixel" onclick="app.setGlobalPointStyle('pixel')"
                            aria-label="Pixel" data-tooltip="Pixel">
                            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                <rect x="10" y="10" width="4" height="4" />
                            </svg>
                        </div>
                    </div>
                </div>

                <div
                    style="position:relative; width:34px; height:34px; display:flex; align-items:center; justify-content:center;">
                    <input type="color" id="globalColorPicker" value="#000000" oninput="app.setGlobalColor(this.value)"
                        onchange="app.setGlobalColor(this.value)"
                        style="position:absolute; opacity:0; width:100%; height:100%; cursor:pointer;"
                        aria-label="Choisir la couleur" data-tooltip="Choisir la couleur">

                    <div id="colorPreview"
                        style="width:20px; height:20px; border-radius:50%; background:#000; border:2px solid #ddd; pointer-events:none;">
                    </div>
                </div>


                <button class="top-btn" id="btnGlobalDash" onclick="app.toggleGlobalDash()"
                    aria-label="Style de trait (Plein/Pointill√©)" data-tooltip="Style de trait (Plein/Pointill√©)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <line x1="2" y1="12" x2="22" y2="12" stroke-width="2" />
                    </svg>
                </button>

                <div class="slider-container" style="flex-direction:row; gap:8px; margin: 0 4px;">
                    <input type="range" id="globalWidth" min="1" max="8" value="2"
                        oninput="app.setGlobalWidth(this.value)" aria-label="√âpaisseur" data-tooltip="√âpaisseur">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor">
                        <line id="headerStrokeIcon" x1="2" y1="12" x2="22" y2="12" stroke-width="2"
                            stroke-linecap="round" />
                    </svg>
                </div>

                <button class="top-btn" id="btnPaint" onclick="app.togglePaintMode()" aria-label="Mode Peinture"
                    data-tooltip="Mode Peinture">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path
                            d="M13.5 3C8.3 3 4 7.3 4 12.5C4 17.7 8.3 22 13.5 22C16.5 22 19 20 19 17.5C19 16.7 18.3 16 17.5 16H16.5C15.7 16 15 15.3 15 14.5C15 13.7 15.7 13 16.5 13H17C18.7 13 20 11.7 20 10C20 6.1 17.1 3 13.5 3Z" />
                        <circle cx="8.5" cy="10.5" r="1.5" fill="#e74c3c" stroke="none" />
                        <circle cx="13.5" cy="7.5" r="1.5" fill="#f1c40f" stroke="none" />
                        <circle cx="8.5" cy="15.5" r="1.5" fill="#3498db" stroke="none" />
                    </svg>
                </button>
            </div>

            <div class="header-dropdown">
                <button class="top-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <text x="12" y="18" font-family="serif" font-size="18" fill="currentColor" stroke="none"
                            font-weight="bold" text-anchor="middle">A</text>
                    </svg>
                </button>

                <div class="header-dropdown-content" style="width: 50px;">
                    <button class="icon-btn" onclick="app.toggleGlobalLabels()" aria-label="Afficher/Masquer les noms"
                        data-tooltip="Afficher/Masquer les noms">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                            <circle cx="12" cy="12" r="3" color="white" />
                        </svg>
                    </button>

                    <div class="sep-h"></div>

                    <button class="icon-btn" onclick="app.offsetGlobalTextSize(2)" aria-label="Agrandir le texte"
                        data-tooltip="Agrandir le texte">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19V5 M5 12l7-7 7 7" />
                        </svg>
                    </button>

                    <button class="icon-btn" onclick="app.offsetGlobalTextSize(-2)" aria-label="R√©duire le texte"
                        data-tooltip="R√©duire le texte">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 5v14 M19 12l-7 7-7-7" />
                        </svg>
                    </button>

                    <div class="sep-h"></div>

                    <button class="icon-btn" onclick="app.resetGlobalText()" aria-label="R√©initialiser (Standard)"
                        data-tooltip="R√©initialiser (Standard)">=
                    </button>
                </div>
            </div>

            <div class="toolbar-group">
                <button class="top-btn" id="btnUndo" onclick="app.undo()" disabled aria-label="Annuler (Ctrl+Z)"
                    data-tooltip="Annuler (Ctrl+Z)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M3 7v6h6" />
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                    </svg>
                </button>
                <button class="top-btn" id="btnRedo" onclick="app.redo()" disabled aria-label="R√©tablir (Ctrl+Y)"
                    data-tooltip="R√©tablir (Ctrl+Y)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 7v6h-6" />
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" />
                    </svg>
                </button>
            </div>

            <button class="top-btn" onclick="app.toggleInstructions()" aria-label="Afficher/Masquer les Consignes"
                data-tooltip="Afficher/Masquer les Consignes">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
            </button>
            <div class="header-right" style="display: flex; align-items: center;">

                <button class="top-btn" onclick="app.cycleStyle()" aria-label="Changer de Th√®me"
                    data-tooltip="Changer de Th√®me" style="margin-left:auto; margin-right: 10px;">
                    <span style="font-size:22px; line-height: 1;">‚óê</span>
                </button>
                <button class="top-btn" id="btn-fullscreen" onclick="app.toggleFullscreen()" aria-label="Plein √âcran"
                    data-tooltip="Plein √âcran"
                    style="margin-right: 10px; display:flex; align-items:center; justify-content:center;">

                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"
                        xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M7 14H5V19H10V17H7V14ZM5 10H7V7H10V5H5V10ZM17 17H14V19H19V14H17V17ZM14 5V7H17V10H19V5H14Z" />
                    </svg>

                </button>
                <button class="top-btn" onclick="app.toggleHelp()" aria-label="Aide & Raccourcis"
                    data-tooltip="Aide & Raccourcis">
                    <span style="font-weight:bold; font-size:18px;">?</span>
                </button>

            </div>
        </div>
    </header>
    <div class="main-container">
        <div class="toolbar">
            <div class="group-label">Action</div>

            <button class="tool-btn active" onclick="app.setTool('move')" aria-label="D√©placer / S√©lectionner"
                data-tooltip="D√©placer / S√©lectionner">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.3L7 18z" />
                </svg>
            </button>

            <button class="tool-btn delete-btn" onclick="app.setTool('delete')" aria-label="Supprimer"
                data-tooltip="Supprimer">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18 M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Points</div>

            <button class="tool-btn" onclick="app.setTool('point')" aria-label="Point" data-tooltip="Point">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round">
                    <line x1="8" y1="8" x2="16" y2="16" />
                    <line x1="16" y1="8" x2="8" y2="16" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('midpoint')" aria-label="Milieu" data-tooltip="Milieu">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="2" y1="12" x2="22" y2="12" stroke-width="2" />
                    <line x1="2" y1="10" x2="2" y2="14" stroke-width="2" />
                    <line x1="22" y1="10" x2="22" y2="14" stroke-width="2" />
                    <path d="M9 9 L15 15 M9 15 L15 9" stroke-width="1" />
                    <path d="M5 10 L7 14" stroke-width="1" />
                    <path d="M17 10 L19 14" stroke-width="1" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Transf.</div>

            <button class="tool-btn" onclick="app.setTool('sym_axial')" aria-label="Sym√©trie Axiale (Miroir)"
                data-tooltip="Sym√©trie Axiale (Miroir)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2v20 M4 12l4-4 M4 12l4 4 M20 12l-4-4 M20 12l-4 4" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('sym_central')" aria-label="Sym√©trie Centrale (Rotation 180¬∞)"
                data-tooltip="Sym√©trie Centrale (Rotation 180¬∞)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="2" fill="currentColor" />
                    <path d="M6 12a6 6 0 0 1 12 0" stroke-dasharray="2,2" />
                    <circle cx="4" cy="12" r="2" />
                    <circle cx="20" cy="12" r="2" fill="currentColor" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Lignes</div>

            <button class="tool-btn" onclick="app.setTool('segment')" aria-label="Segment [AB]"
                data-tooltip="Segment [AB]">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="5" y1="19" x2="19" y2="5" />
                    <line x1="3" y1="17" x2="7" y2="21" stroke-width="2.5" />
                    <line x1="17" y1="3" x2="21" y2="7" stroke-width="2.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('line')" aria-label="Droite (AB)" data-tooltip="Droite (AB)">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="2" y1="22" x2="22" y2="2" />
                    <line x1="5" y1="15" x2="9" y2="19" stroke-width="2.5" />
                    <line x1="15" y1="5" x2="19" y2="9" stroke-width="2.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('ray')" aria-label="Demi-droite [AB)"
                data-tooltip="Demi-droite [AB)">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="5" y1="19" x2="22" y2="2" />
                    <line x1="3" y1="17" x2="7" y2="21" stroke-width="2.5" />
                    <line x1="13" y1="7" x2="17" y2="11" stroke-width="2.5" />
                </svg>
            </button>
            <div class="tool-sep"></div>

            <div class="group-label">Relat.</div>

            <button class="tool-btn" onclick="app.setTool('perpendicular')" aria-label="Perpendiculaire"
                data-tooltip="Perpendiculaire">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <line x1="4" y1="20" x2="20" y2="20" />
                    <line x1="12" y1="4" x2="12" y2="20" />
                    <rect x="12" y="15" width="5" height="5" stroke-width="1.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('parallel')" aria-label="Parall√®le" data-tooltip="Parall√®le">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M5 20L17 4 M9 22L21 6" />
                </svg>
            </button>

            <div class="tool-sep"></div>
            <div class="group-label">Annot.</div>
            <button class="tool-btn" onclick="app.setTool('text')" aria-label="Texte / Renommer"
                data-tooltip="Texte / Renommer">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <text x="12" y="18" font-family="Arial" font-size="16" font-weight="bold"
                        text-anchor="middle">A</text>
                    <path d="M14 6 L17 6 L17 8 L15 8 L15 6 L14 6" stroke="currentColor" stroke-width="1" fill="none" />
                    <circle cx="16" cy="17" r="1" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('angle')" aria-label="Angle" data-tooltip="Angle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <line x1="4" y1="20" x2="20" y2="20" />
                    <line x1="4" y1="20" x2="16" y2="4" />
                    <path d="M 12 20 A 8 8 0 0 0 9 13" stroke-width="1.5" />
                </svg>
            </button>
            <div class="tool-sep"></div>


            <div class="group-label">Formes</div>
            <button class="tool-btn" onclick="app.setTool('circle')" aria-label="Cercle" data-tooltip="Cercle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <circle cx="12" cy="12" r="8" />
                    <path d="M11 12 L13 12 M12 11 L12 13" stroke-width="1.5" />
                </svg>
            </button>
            <button class="tool-btn" onclick="app.setTool('polygon')" aria-label="Polygone" data-tooltip="Polygone">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M12 3l9 7-4 11H7L3 10z" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Outils</div>
            <button class="tool-btn" id="btn-compass" onclick="app.toggleWidget('compass')" aria-label="Compas"
                data-tooltip="Compas">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"
                    stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="5" r="2" />
                    <line x1="12" y1="7" x2="7" y2="21" />
                    <line x1="12" y1="7" x2="17" y2="21" />
                    <line x1="7" y1="21" x2="7" y2="21" stroke-width="3" />
                    <line x1="17" y1="21" x2="17" y2="21" stroke-width="3" />
                </svg>
            </button>
            <button class="tool-btn" id="btn-setsquare" onclick="app.toggleWidget('setsquare')" aria-label="√âquerre"
                data-tooltip="√âquerre">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M4 20h16L4 4z" />
                </svg>
            </button>

            <button class="tool-btn" id="btn-protractor" onclick="app.toggleWidget('protractor')"
                aria-label="Rapporteur" data-tooltip="Rapporteur">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M 2 16 A 8 10 0 0 1 22 16 Z" />
                    <line x1="12" y1="16" x2="12" y2="12" stroke-width="1.5" />
                </svg>
            </button>

            <button class="tool-btn" id="btn-ruler" onclick="app.toggleWidget('ruler')" aria-label="R√®gle"
                data-tooltip="R√®gle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2">
                    <rect x="4" y="8" width="16" height="8" rx="1" fill="none" />
                    <path d="M6 8v3 M9 8v2 M12 8v3 M15 8v2 M18 8v3" stroke-width="1.5" />
                </svg>
            </button>
        </div>

        <div id="textEditor" style="display:none;">
            <div class="editor-toolbar">
                <select id="fontFamilyInput" title="Police">
                    <option value="'Segoe UI', sans-serif">Standard</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', serif">S√©rif</option>
                    <option value="'Courier New', monospace">Code</option>
                    <option value="'Comic Sans MS', 'Chalkboard SE', sans-serif">Fun</option>
                    <option value="Impact, sans-serif">Gras</option>
                </select>
                <input type="number" id="fontSizeInput" value="16" min="8" max="100" step="2" title="Taille (px)">
            </div>
            <input type="text" id="textInput" placeholder="Texte..." autocomplete="off">
            <div class="editor-buttons">
                <button id="btnTextCancel" title="Annuler">‚úï</button>
                <button id="btnTextSave" title="Valider">‚úì</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="geoCanvas" width=3000 height="2000"></canvas>

            <div id="replayBar">
                <div class="replay-control-group">
                    <button class="replay-btn" id="btnPlay" onclick="app.playFromStart()"
                        title="Lire depuis le d√©but">‚ñ∂</button>
                    <button class="replay-btn" id="btnStop" onclick="app.stopAnimation()"
                        title="Stop (Aller √† la fin)">‚ñ†</button>
                    <button class="replay-btn" id="btnLoop" onclick="app.toggleLoop()" title="Boucle (OFF)">üîÅ</button>
                </div>

                <div class="replay-control-group slider-container">
                    <span class="slider-icon">Vitesse</span>
                    <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="app.setSpeed(this.value)">
                </div>

                <div class="replay-control-group slider-container">
                    <span class="slider-icon">Pause</span>
                    <input type="range" id="pauseSlider" min="0" max="3000" step="100" value="1000"
                        oninput="app.setLoopDelay(this.value)">
                </div>
            </div>

            <div id="contextMenu">
                <div class="drag-handle" id="menuDragHandle"></div>

                <div class="menu-row justify-center">
                    <div class="color-dot" style="background:#222;" onclick="app.styleObject('black')"></div>
                    <div class="color-dot" style="background:#2980b9;" onclick="app.styleObject('blue')"></div>
                    <div class="color-dot" style="background:#c0392b;" onclick="app.styleObject('red')"></div>
                    <div class="color-dot" style="background:#27ae60;" onclick="app.styleObject('green')"></div>
                    <div class="color-dot" style="background:#e67e22;" onclick="app.styleObject('orange')"></div>
                </div>
                <div class="menu-row justify-center">
                    <div class="color-dot" style="background:#8e44ad;" onclick="app.styleObject('purple')"></div>
                    <div class="color-dot" style="background:#7f8c8d;" onclick="app.styleObject('gray')"></div>
                    <div class="color-dot" style="background:#e91e63;" onclick="app.styleObject('pink')"></div>
                    <div class="color-dot" style="background:#f1c40f;" onclick="app.styleObject('yellow')"></div>
                    <div class="color-dot" style="background:#1abc9c;" onclick="app.styleObject('cyan')"></div>
                </div>

                <div id="sepFill" class="sep-h" style="display:none;"></div>

                <div id="rowFill" class="menu-row" style="display:none;">
                    <div class="icon-btn" onclick="app.styleObject('fill-solid')" title="Plein">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="currentColor" opacity="0.5"
                                stroke="currentColor" stroke-width="2" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-hatch')" title="Hachures">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                            <path d="M6 18L18 6 M10 20L20 10 M4 14L14 4" stroke="currentColor" stroke-width="1" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-dots')" title="Points">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                            <circle cx="8" cy="8" r="1" fill="currentColor" />
                            <circle cx="16" cy="8" r="1" fill="currentColor" />
                            <circle cx="8" cy="16" r="1" fill="currentColor" />
                            <circle cx="16" cy="16" r="1" fill="currentColor" />
                            <circle cx="12" cy="12" r="1" fill="currentColor" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-none')" title="Vide">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                        </svg>
                    </div>
                </div>

                <div id="sep1" class="sep-h"></div>
                <div id="rowStyle" class="menu-row">
                    <div class="icon-btn" onclick="app.styleObject('solid')" title="Plein">
                        <svg viewBox="0 0 24 24">
                            <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('dashed')" title="Pointill√©s">
                        <svg viewBox="0 0 24 24">
                            <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3"
                                stroke-dasharray="4,2" />
                        </svg>
                    </div>
                    <input type="range" class="compact-slider" id="widthRange" min="1" max="8" step="1"
                        oninput="app.previewLineWidth(this.value)" onchange="app.setLineWidth(this.value)"
                        title="√âpaisseur">
                </div>

                <div id="rowMeasure" style="display:none;">
                    <div class="switch-container">
                        <div id="btnMesNone" class="switch-btn" onclick="app.styleObject('toggleLength-off')"
                            title="Masquer la mesure">
                            <svg viewBox="0 0 24 24">
                                <path
                                    d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24">
                                </path>
                                <line x1="1" y1="1" x2="23" y2="23"></line>
                            </svg>
                        </div>

                        <div id="btnMesUp" class="switch-btn" onclick="app.styleObject('measureUp')"
                            title="Mesure au-dessus">
                            <svg viewBox="0 0 24 24">
                                <line x1="2" y1="19" x2="22" y2="19"></line>
                                <rect x="7" y="5" width="10" height="8" rx="2"></rect>
                                <path d="M12 13v6"></path>
                            </svg>
                        </div>

                        <div id="btnMesDown" class="switch-btn" onclick="app.styleObject('measureDown')"
                            title="Mesure en-dessous">
                            <svg viewBox="0 0 24 24">
                                <line x1="2" y="5" x2="22" y2="5"></line>
                                <rect x="7" y="11" width="10" height="8" rx="2"></rect>
                                <path d="M12 5v6"></path>
                            </svg>
                        </div>
                    </div>
                </div>

                <div id="rowCoding" class="coding-grid" style="display:none;">
                    <div class="mark-btn" onclick="app.styleObject('mark-none')" title="Aucun">√ò</div>
                    <div class="mark-btn" onclick="app.styleObject('mark-1')"><svg viewBox="0 0 20 20">
                            <line x1="10" y1="4" x2="10" y2="16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-2')"><svg viewBox="0 0 20 20">
                            <path d="M7 4 L7 16 M13 4 L13 16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-3')"><svg viewBox="0 0 20 20">
                            <path d="M5 4 L5 16 M10 4 L10 16 M15 4 L15 16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-x')"><svg viewBox="0 0 20 20">
                            <path d="M5 5 L15 15 M15 5 L5 15" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-xx')"><svg viewBox="0 0 20 20">
                            <path d="M2 5 L8 15 M8 5 L2 15 M12 5 L18 15 M18 5 L12 15" stroke="currentColor"
                                stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-o')"><svg viewBox="0 0 20 20">
                            <circle cx="10" cy="10" r="5" fill="none" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-oo')"><svg viewBox="0 0 20 20">
                            <circle cx="6" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="2" />
                            <circle cx="14" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                </div>

                <div id="rowAngle" class="menu-row" style="display:none;">

                    <div id="btnToggleAngleVal" class="icon-btn" onclick="app.styleObject('toggleAngleVal')"
                        title="Afficher Valeur">
                        <svg viewBox="0 0 24 24">
                            <text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-family="Arial"
                                font-weight="bold" font-size="10" fill="currentColor">12¬∞</text>
                        </svg>
                    </div>

                    <div id="btnToggleAngleFill" class="icon-btn" onclick="app.styleObject('toggleAngleFill')"
                        title="Remplir">
                        <div class="icon-btn" id="btnAngleFill" onclick="app.toggleAngleFill()" title="Remplir / Vider">
                            <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linejoin="round">
                                <path d="M4 20 L4 4 A16 16 0 0 1 20 20 H4 Z" fill="none" />

                                <path d="M4 20 L4 4 A16 16 0 0 1 15.3 8.7 Z" fill="currentColor" stroke="none" />
                            </svg>
                        </div>
                    </div>

                    <div id="btnFlipAngle" class="icon-btn" onclick="app.styleObject('flipAngle')"
                        title="Inverser (360¬∞)">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 16.03 20 14.57 20 13c0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.3 7.3C4.89 8.7 4 10.74 4 13c0 4.42 3.58 8 8 8v-3l5 5-5 5v-3c-3.31 0-6-2.69-6-6z" />
                        </svg>
                    </div>

                </div>
                <div id="rowTextProps" class="menu-row justify-center"
                    style="display:none; border-bottom:1px solid #eee; padding-bottom:4px; margin-bottom:4px;">
                    <div id="btnToggleLabel" class="icon-btn" onclick="app.styleObject('toggleLabel')"
                        title="Afficher/Masquer le nom" style="margin-right:8px;">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
                                fill="currentColor" />
                        </svg>
                    </div>

                    <div class="icon-btn" onclick="app.styleObject('textSize-dec')" title="R√©duire">
                        <svg viewBox="0 0 24 24">
                            <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </div>

                    <div
                        style="font-weight:bold; color:#555; width:24px; text-align:center; font-size:14px; line-height:32px;">
                        A</div>

                    <div class="icon-btn" onclick="app.styleObject('textSize-inc')" title="Augmenter">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </div>
                </div>
                <div id="rowLabelPos" style="display:none; padding: 4px 0; border-bottom: 1px solid #eee;">
                    <div class="label-positioner" id="labelPosBox">
                        <div class="label-preview">A</div>
                        <div class="label-cross"></div>
                        <div class="label-knob" id="labelPosKnob"></div>
                    </div>
                </div>
                <div id="rowPointStyle" class="menu-row justify-center"
                    style="display:none; border-bottom:1px solid #eee; padding-bottom:4px; margin-bottom:4px;">
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-cross')" title="Croix">
                        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="3" fill="none">
                            <path d="M5 5l14 14M19 5l-14 14" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-dot')" title="Disque">
                        <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <circle cx="12" cy="12" r="6" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-pixel')" title="Pixel">
                        <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <rect x="9" y="9" width="6" height="6" />
                        </svg>
                    </div>
                </div>
                <div id="rowRenamer" style="display:none;">
                    <div class="renamer-container">
                        <button class="renamer-btn" onclick="app.cyclePointName(-1)">‚óÄ</button>

                        <div class="renamer-display" id="renamerDisplay">A</div>
                        <button class="renamer-btn" onclick="app.cyclePointName(1)">‚ñ∂</button>

                        <button class="renamer-btn" onclick="app.addPrime()" title="Ajouter '"><b>'</b></button>
                    </div>
                </div>

                <div class="menu-row">
                    <div class="icon-btn btn-trash" onclick="app.deleteFromMenu()">üóëÔ∏è</div>
                </div>
            </div>
        </div>
    </div>
    <div id="virtualKeyboard" class="v-keyboard">
    </div>
    <div id="customModal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-text" id="modalMessage">√ätes-vous s√ªr ?</div>
            <div class="modal-buttons">
                <button class="modal-btn modal-cancel" onclick="app.closeModal()">Annuler</button>
                <button class="modal-btn modal-confirm danger" id="btnModalConfirm">Confirmer</button>
            </div>
        </div>
    </div>


    <script>

        const PatternUtils = {
            // Cr√©e un motif de hachures diagonales pour le Canvas
            createHatchPattern(ctx, color) {
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 10;
                pCanvas.height = 10;
                const pCtx = pCanvas.getContext('2d');

                pCtx.strokeStyle = color;
                pCtx.lineWidth = 1;
                pCtx.lineCap = 'square';

                // Ligne diagonale /
                pCtx.beginPath();
                pCtx.moveTo(0, 10);
                pCtx.lineTo(10, 0);
                pCtx.stroke();

                return ctx.createPattern(pCanvas, 'repeat');
            },

            // Cr√©e un motif de points
            createDotPattern(ctx, color) {
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 6;
                pCanvas.height = 6;
                const pCtx = pCanvas.getContext('2d');

                pCtx.fillStyle = color;
                pCtx.beginPath();
                pCtx.arc(3, 3, 1, 0, Math.PI * 2);
                pCtx.fill();

                return ctx.createPattern(pCanvas, 'repeat');
            }
        };

        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        const UNIT = 50;
        const MathUtils = {
            /* --- DANS MathUtils --- */

            // Sym√©trie Centrale : P' = 2*Centre - P
            getCentralSymmetry(pt, center) {
                return {
                    x: 2 * center.x - pt.x,
                    y: 2 * center.y - pt.y
                };
            },
            // Sym√©trie Axiale : P' = 2*Projection - P
            getAxialSymmetry(pt, axis) {
                // 1. On trouve la projection orthogonale H sur l'axe
                const H = this.getProjectedPoint(pt.x, pt.y, axis);
                // 2. On applique la formule vectorielle
                return {
                    x: 2 * H.x - pt.x,
                    y: 2 * H.y - pt.y
                };
            },
            getLineCoords(obj) {
                if (obj.getDynamicP2) return {
                    p1: obj.p1,
                    p2: obj.getDynamicP2()
                };
                if (obj instanceof LinearObject) return {
                    p1: obj.p1,
                    p2: obj.p2
                };
                return {
                    p1: obj.p1,
                    p2: obj.p2
                };
            },
            drawInfiniteLineFromVector(ctx, x, y, dx, dy, color, width, dash) {
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return;
                const ndx = dx / len;
                const ndy = dy / len;
                const LARGE_NUM = 10000;
                ctx.beginPath();
                ctx.moveTo(x - ndx * LARGE_NUM, y - ndy * LARGE_NUM);
                ctx.lineTo(x + ndx * LARGE_NUM, y + ndy * LARGE_NUM);
                ctx.strokeStyle = color || '#000000';
                ctx.lineWidth = width || 3;
                ctx.setLineDash(dash || []);
                ctx.lineCap = 'round';
                ctx.stroke();
            },
            distanceToLineVector(mx, my, px, py, dx, dy) {
                const len2 = dx * dx + dy * dy;
                if (len2 === 0) return Infinity;
                const t = ((mx - px) * dx + (my - py) * dy) / len2;
                const projX = px + t * dx;
                const projY = py + t * dy;
                return Math.sqrt((mx - projX) ** 2 + (my - projY) ** 2);
            },
            distanceToSegment(x, y, x1, y1, x2, y2) {
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq != 0) param = dot / len_sq;
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },
            dist(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
            },
            isPointOnArc(pt, arcObj) {
                const center = (arcObj instanceof CompassArc || arcObj instanceof Arc) ? arcObj.center : arcObj.p1;
                if (!center || (center.x === undefined && !center.length)) return false;

                // R√©cup√©ration des coordonn√©es (g√®re les objets Point ou simples {x,y})
                const cx = center.x ?? 0;
                const cy = center.y ?? 0;

                // 1. Calcul de l'angle de la souris (0 √† 2PI)
                let angle = Math.atan2(pt.y - cy, pt.x - cx);
                if (angle < 0) angle += Math.PI * 2;

                // --- FIX 360¬∞ (CERCLE COMPLET) ---
                const totalRotation = Math.abs(arcObj.endAngle - arcObj.startAngle);
                const PI2 = Math.PI * 2;

                // Si c'est un cercle complet, on accepte tout
                if (totalRotation >= PI2 - 0.01) return true;

                // Normalisation des angles de l'arc (0 √† 2PI)
                let s = (arcObj.startAngle % PI2 + PI2) % PI2;
                let e = (arcObj.endAngle % PI2 + PI2) % PI2;
                const ccw = arcObj.counterClockwise;

                // Logique standard pour les arcs partiels
                if (ccw) {
                    // Sens anti-horaire
                    if (s > e) return angle <= s && angle >= e;
                    return angle <= s || angle >= e; // Passage par z√©ro
                } else {
                    // Sens horaire
                    if (s < e) return angle >= s && angle <= e;
                    return angle >= s || angle <= e; // Passage par z√©ro
                }

            },
            intersectLineCircle(p1, p2, center, radius, lineType) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const A = dx * dx + dy * dy;
                const B = 2 * (dx * (p1.x - center.x) + dy * (p1.y - center.y));
                const C = (p1.x - center.x) ** 2 + (p1.y - center.y) ** 2 - radius ** 2;
                const delta = B * B - 4 * A * C;
                const points = [];
                if (delta >= 0 && A > 0) {
                    const t1 = (-B - Math.sqrt(delta)) / (2 * A);
                    const t2 = (-B + Math.sqrt(delta)) / (2 * A);
                    const checkBounds = (t) => {
                        if (lineType === 'Segment') return t >= 0 && t <= 1;
                        if (lineType === 'Ray') return t >= 0;
                        return true;
                    };
                    if (checkBounds(t1)) points.push({
                        x: p1.x + t1 * dx,
                        y: p1.y + t1 * dy
                    });
                    if (delta > 0 && checkBounds(t2)) points.push({
                        x: p1.x + t2 * dx,
                        y: p1.y + t2 * dy
                    });
                }
                return points;
            },
            intersectCircleCircle(c1, r1, c2, r2) {
                const d2 = (c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2;
                const d = Math.sqrt(d2);
                if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];
                const a = (r1 ** 2 - r2 ** 2 + d2) / (2 * d);
                const h = Math.sqrt(Math.max(0, r1 ** 2 - a ** 2));
                const x2 = c1.x + a * (c2.x - c1.x) / d;
                const y2 = c1.y + a * (c2.y - c1.y) / d;
                const pts = [];
                pts.push({
                    x: x2 + h * (c2.y - c1.y) / d,
                    y: y2 - h * (c2.x - c1.x) / d
                });
                if (h > 0.001) pts.push({
                    x: x2 - h * (c2.y - c1.y) / d,
                    y: y2 + h * (c2.x - c1.x) / d
                });
                return pts;
            },
            getIntersections(obj1, obj2) {
                // 1. D√©finition des types
                const isLin1 = (obj1 instanceof LinearObject || obj1 instanceof ParallelLine || obj1 instanceof PerpendicularLine);
                const isLin2 = (obj2 instanceof LinearObject || obj2 instanceof ParallelLine || obj2 instanceof PerpendicularLine);

                const isCirc1 = (obj1 instanceof Circle || obj1 instanceof Arc || obj1 instanceof CompassArc || obj1 instanceof CompassCircle);
                const isCirc2 = (obj2 instanceof Circle || obj2 instanceof Arc || obj2 instanceof CompassArc || obj2 instanceof CompassCircle);

                // 2. Helper pour extraire proprement Centre et Rayon de n'importe quoi
                const getCircleData = (o) => {
                    if (o instanceof CompassCircle) return { c: o.center || o.p1, r: o.getRadius() };
                    if (o instanceof CompassArc) return { c: o.center, r: o.radius };
                    if (o instanceof Arc) return { c: o.center, r: o.radius };
                    // Pour un cercle standard d√©fini par 2 points
                    return { c: o.p1, r: MathUtils.dist(o.p1.x, o.p1.y, o.p2.x, o.p2.y) };
                };

                let rawPoints = [];

                // --- CAS 1 : LIGNE vs LIGNE ---
                if (isLin1 && isLin2) {
                    const c1 = MathUtils.getLineCoords(obj1);
                    const c2 = MathUtils.getLineCoords(obj2);
                    const A = c1.p1, B = c1.p2;
                    const C = c2.p1, D = c2.p2;

                    if (!A || !B || !C || !D) return [];

                    const det = (B.x - A.x) * (D.y - C.y) - (D.x - C.x) * (B.y - A.y);
                    if (det === 0) return []; // Parall√®les

                    const t = ((C.x - A.x) * (D.y - C.y) - (C.y - A.y) * (D.x - C.x)) / det;
                    const u = ((C.x - A.x) * (B.y - A.y) - (C.y - A.y) * (B.x - A.x)) / det;

                    const check = (val, type) => {
                        if (type === 'Segment') return val >= 0 && val <= 1;
                        if (type === 'Ray') return val >= 0;
                        return true;
                    };

                    // On v√©rifie que l'intersection est bien SUR les segments/demi-droites
                    if (check(t, obj1.constructor.name) && check(u, obj2.constructor.name)) {
                        return [{
                            x: A.x + t * (B.x - A.x),
                            y: A.y + t * (B.y - A.y)
                        }];
                    }
                    return [];
                }

                // --- CAS 2 : LIGNE vs CERCLE (Crois√©) ---
                else if (isLin1 && isCirc2) {
                    const c = MathUtils.getLineCoords(obj1);
                    const circle = getCircleData(obj2);
                    rawPoints = MathUtils.intersectLineCircle(c.p1, c.p2, circle.c, circle.r, obj1.constructor.name);
                }
                else if (isCirc1 && isLin2) {
                    const c = MathUtils.getLineCoords(obj2);
                    const circle = getCircleData(obj1);
                    rawPoints = MathUtils.intersectLineCircle(c.p1, c.p2, circle.c, circle.r, obj2.constructor.name);
                }

                // --- CAS 3 : CERCLE vs CERCLE ---
                else if (isCirc1 && isCirc2) {
                    const c1 = getCircleData(obj1);
                    const c2 = getCircleData(obj2);
                    rawPoints = MathUtils.intersectCircleCircle(c1.c, c1.r, c2.c, c2.r);
                }

                // 3. Filtrage final : On v√©rifie si les points sont bien SUR les arcs
                return rawPoints.filter(pt => {
                    let ok1 = true;
                    let ok2 = true;

                    // Si l'objet est un Arc ou un CompassArc, on v√©rifie les angles
                    if (obj1 instanceof Arc || obj1 instanceof CompassArc) ok1 = MathUtils.isPointOnArc(pt, obj1);
                    if (obj2 instanceof Arc || obj2 instanceof CompassArc) ok2 = MathUtils.isPointOnArc(pt, obj2);

                    return ok1 && ok2;
                });
            },
            distanceToLine(px, py, A, B, type) {
                if (!A || !B) return Infinity;
                const l2 = (A.x - B.x) ** 2 + (A.y - B.y) ** 2;
                if (l2 === 0) return Infinity;
                let t = ((px - A.x) * (B.x - A.x) + (py - A.y) * (B.y - A.y)) / l2;
                if (type === 'Segment') t = Math.max(0, Math.min(1, t));
                else if (type === 'Ray') t = Math.max(0, t);
                const projX = A.x + t * (B.x - A.x);
                const projY = A.y + t * (B.y - A.y);
                return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
            },
            getProjectedPoint(px, py, obj) {
                // 1. CAS CERCLES & ARCS
                if (obj instanceof Circle || obj instanceof Arc || obj instanceof CompassArc || obj instanceof CompassCircle) {
                    let center, radius;

                    if (obj instanceof CompassCircle || obj instanceof CompassArc) {
                        center = obj.center;
                        radius = obj.radius;
                        if (obj instanceof CompassCircle && obj.rP1) {
                            radius = MathUtils.dist(obj.rP1.x, obj.rP1.y, obj.rP2.x, obj.rP2.y);
                        }
                    } else {
                        center = obj.center || obj.p1;
                        radius = obj.radius || MathUtils.dist(obj.p1.x, obj.p1.y, obj.p2.x, obj.p2.y);
                    }

                    if (!center) return { x: px, y: py };

                    const angle = Math.atan2(py - center.y, px - center.x);
                    const finalX = center.x + radius * Math.cos(angle);
                    const finalY = center.y + radius * Math.sin(angle);

                    if (obj instanceof Arc || obj instanceof CompassArc) {
                        if (MathUtils.isPointOnArc({ x: finalX, y: finalY }, obj)) {
                            return { x: finalX, y: finalY };
                        } else {
                            const sx = center.x + radius * Math.cos(obj.startAngle);
                            const sy = center.y + radius * Math.sin(obj.startAngle);
                            const ex = center.x + radius * Math.cos(obj.endAngle);
                            const ey = center.y + radius * Math.sin(obj.endAngle);

                            const dStart = (px - sx) ** 2 + (py - sy) ** 2;
                            const dEnd = (px - ex) ** 2 + (py - ey) ** 2;

                            return (dStart < dEnd) ? { x: sx, y: sy } : { x: ex, y: ey };
                        }
                    }

                    return { x: finalX, y: finalY };
                }

                const c = MathUtils.getLineCoords(obj);
                const A = c.p1;
                const B = c.p2;
                if (!A || !B) return {
                    x: px,
                    y: py
                };
                const l2 = (A.x - B.x) ** 2 + (A.y - B.y) ** 2;
                if (l2 === 0) return {
                    x: A.x,
                    y: A.y
                };
                let t = ((px - A.x) * (B.x - A.x) + (py - A.y) * (B.y - A.y)) / l2;
                if (obj.constructor.name === 'Segment') t = Math.max(0, Math.min(1, t));
                else if (obj.constructor.name === 'Ray') t = Math.max(0, t);
                return {
                    x: A.x + t * (B.x - A.x),
                    y: A.y + t * (B.y - A.y)
                };
            }
        };

        // Class //
        class GeometryObject {
            constructor(p1, p2, id = null) {
                this.id = id || generateId();
                this.p1 = p1;
                this.p2 = p2;
                this.color = null;
                this.dash = [];
                this.lineWidth = 2;
            }
            getStyle(defaultColor, isHovered, isToDelete) {
                const baseColor = this.color || defaultColor;
                const baseWidth = this.lineWidth || 2;
                if (isToDelete) return {
                    color: "#d32f2f",
                    width: baseWidth + 3,
                    dash: []
                };
                if (isHovered) return {
                    color: baseColor,
                    width: baseWidth + 3,
                    dash: this.dash
                };
                return {
                    color: baseColor,
                    width: baseWidth,
                    dash: this.dash
                };
            }
            getCoords() {
                return {
                    p1: this.p1,
                    p2: this.p2
                };
            }
        }

        class Point extends GeometryObject {
            constructor(x, y, label = "", parents = [], id = null, subType = null) {
                super(null, null, id);
                this.x = x;
                this.y = y;
                this.label = label;
                this.size = 6;
                this.parents = parents;
                this.visible = true;
                this.labelAngle = -Math.PI / 4;
                this.fontSize = 14;
                this.showLabel = true;
                this.pointStyle = 'cross';
                this.subType = subType;
            }
            update() {
                if (this.subType === 'symmetry_central' && this.parents.length === 2) {
                    const origin = this.parents[0];
                    const center = this.parents[1];
                    const res = MathUtils.getCentralSymmetry(origin, center);
                    this.x = res.x;
                    this.y = res.y;
                    return;
                }
                if (this.subType === 'symmetry_axial' && this.parents.length === 2) {
                    const origin = this.parents[0];
                    const axis = this.parents[1];
                    const res = MathUtils.getAxialSymmetry(origin, axis);
                    this.x = res.x;
                    this.y = res.y;
                    return;
                }
                if (this.parents.length === 2) {
                    if (this.parents[0] instanceof Point && this.parents[1] instanceof Point) {
                        this.x = (this.parents[0].x + this.parents[1].x) / 2;
                        this.y = (this.parents[0].y + this.parents[1].y) / 2;
                        this.visible = true;
                    } else {
                        const pts = MathUtils.getIntersections(this.parents[0], this.parents[1]);
                        if (pts.length === 0) this.visible = false;
                        else {
                            this.visible = true;
                            if (pts.length === 1) {
                                this.x = pts[0].x;
                                this.y = pts[0].y;
                            } else {
                                const d1 = (this.x - pts[0].x) ** 2 + (this.y - pts[0].y) ** 2;
                                const d2 = (this.x - pts[1].x) ** 2 + (this.y - pts[1].y) ** 2;
                                if (d1 < d2) {
                                    this.x = pts[0].x;
                                    this.y = pts[0].y;
                                } else {
                                    this.x = pts[1].x;
                                    this.y = pts[1].y;
                                }
                            }
                        }
                    }
                } else if (this.parents.length === 1) {
                    const proj = MathUtils.getProjectedPoint(this.x, this.y, this.parents[0]);

                    if (proj) {
                        this.x = proj.x;
                        this.y = proj.y;
                    }
                }
            }
            isNear(mx, my) {
                return this.visible && Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2) < 12;
            }
            draw(ctx, opts) {
                if (this.visible === false) return;
                if (!this.visible && !opts.isSelected) return;
                ctx.beginPath();
                const base = this.color || (this.parents.length > 0 ? "#333" : "red");
                const style = opts.isToDelete ? "#d32f2f" : (opts.isHovered ? base : (opts.isSelected ? "orange" : base));
                const w = (opts.isHovered || opts.isSelected || opts.isToDelete) ? 4 : 2;
                ctx.strokeStyle = style;
                ctx.lineWidth = w;
                ctx.setLineDash([]);
                if (this.pointStyle === 'dot') {
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                else if (this.pointStyle === 'pixel') {
                    ctx.rect(this.x - 1, this.y - 1, 2, 2);
                    ctx.fill();
                    ctx.stroke();
                }
                else {
                    ctx.moveTo(this.x - this.size, this.y - this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.moveTo(this.x + this.size, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.stroke();
                }
                if (this.label && this.showLabel) {
                    ctx.fillStyle = "black";
                    const fs = this.fontSize || 14;
                    ctx.font = `bold ${fs}px Arial`;

                    const angle = (this.labelAngle !== undefined) ? this.labelAngle : -Math.PI / 4;
                    const dist = 12 + fs / 2;
                    const lx = this.x + Math.cos(angle) * dist;
                    const ly = this.y + Math.sin(angle) * dist;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(this.label, lx, ly);
                }
            }
        }

        class TextLabel extends GeometryObject {
            constructor(x, y, text, id = null) {
                super(null, null, id);
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = "black";
                this.font = "16px Segoe UI";
                this.fontSize = 16;
                this.fontFamily = "'Segoe UI', sans-serif";
            }
            isNear(mx, my) {
                if (!this.text) return false;
                const estWidth = this.text.length * 10;
                const estHeight = 20;
                return (Math.abs(mx - this.x) < estWidth / 2 + 10) && (Math.abs(my - this.y) < estHeight / 2 + 10);
            }
            draw(ctx, opts) {
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.fillStyle = opts.isHovered ? "#2980b9" : (opts.isSelected ? "#e67e22" : (this.color || "black"));
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.text, this.x, this.y);

                if (opts.isHovered || opts.isSelected) {
                    const w = ctx.measureText(this.text).width + 10;
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.strokeRect(this.x - w / 2, this.y - 10, w, 20);
                    ctx.setLineDash([]);
                }
            }
        }

        class LinearObject extends GeometryObject {
            isNear(mx, my) {
                return this.p1 && this.p2 && MathUtils.distanceToLine(mx, my, this.p1, this.p2, this.constructor.name) < 8;
            }
            drawInfinite(ctx, startMult, endMult, style) {
                if (!this.p1 || !this.p2) return;
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                ctx.beginPath();
                ctx.moveTo(this.p1.x + dx * startMult, this.p1.y + dy * startMult);
                ctx.lineTo(this.p1.x + dx * endMult, this.p1.y + dy * endMult);
                ctx.strokeStyle = style.color;
                ctx.lineWidth = style.width;
                ctx.setLineDash(style.dash);
                ctx.stroke();
            }
        }
        class Segment extends LinearObject {
            constructor(p1, p2, id) {
                super(p1, p2, id);
                this.showLength = false;
                this.measureOffset = -15;
                this.coding = null; // 'mark-1', 'mark-2', 'mark-x', etc.
            }
            draw(ctx, {
                isHovered,
                isToDelete
            }) {
                const s = this.getStyle("blue", isHovered, isToDelete);
                this.drawInfinite(ctx, 0, 1, s);

                if (!this.p1 || !this.p2) return;

                // --- DESSIN DU CODAGE ---
                if (this.coding && this.coding !== 'mark-none') {
                    const mx = (this.p1.x + this.p2.x) / 2;
                    const my = (this.p1.y + this.p2.y) / 2;
                    const angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);

                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const h = 6; // hauteur du trait

                    if (this.coding === 'mark-1') {
                        ctx.moveTo(0, -h); ctx.lineTo(0, h);
                    } else if (this.coding === 'mark-2') {
                        ctx.moveTo(-2, -h); ctx.lineTo(-2, h);
                        ctx.moveTo(2, -h); ctx.lineTo(2, h);
                    } else if (this.coding === 'mark-3') {
                        ctx.moveTo(-4, -h); ctx.lineTo(-4, h);
                        ctx.moveTo(0, -h); ctx.lineTo(0, h);
                        ctx.moveTo(4, -h); ctx.lineTo(4, h);
                    } else if (this.coding === 'mark-x') {
                        ctx.moveTo(-4, -4); ctx.lineTo(4, 4);
                        ctx.moveTo(-4, 4); ctx.lineTo(4, -4);
                    } else if (this.coding === 'mark-xx') {
                        ctx.translate(-5, 0);
                        ctx.moveTo(-3, -3); ctx.lineTo(3, 3);
                        ctx.moveTo(-3, 3); ctx.lineTo(3, -3);
                        ctx.translate(10, 0);
                        ctx.moveTo(-3, -3); ctx.lineTo(3, 3);
                        ctx.moveTo(-3, 3); ctx.lineTo(3, -3);
                    } else if (this.coding === 'mark-o') {
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    } else if (this.coding === 'mark-oo') {
                        ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(5, 0, 3, 0, Math.PI * 2);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // --- DESSIN DE LA MESURE ---
                if (this.showLength) {
                    const px = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                    const val = (px / UNIT).toFixed(1);
                    const mx = (this.p1.x + this.p2.x) / 2;
                    const my = (this.p1.y + this.p2.y) / 2;
                    let angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
                    let off = this.measureOffset;
                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        angle += Math.PI;
                        off = -off;
                    }
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    ctx.font = "14px Segoe UI";
                    const w = ctx.measureText(val).width;
                    ctx.fillStyle = "rgba(255,255,255,0.7)";
                    ctx.fillRect(-w / 2 - 2, off - 12, w + 4, 16);
                    ctx.fillStyle = this.color || "blue";
                    ctx.textAlign = "center";
                    ctx.fillText(val, 0, off);
                    ctx.restore();
                }
            }
        }
        class Ray extends LinearObject {
            draw(ctx, o) {
                this.drawInfinite(ctx, 0, 1000, this.getStyle("green", o.isHovered, o.isToDelete));
            }
        }
        class Line extends LinearObject {
            draw(ctx, o) {
                this.drawInfinite(ctx, -1000, 1000, this.getStyle("black", o.isHovered, o.isToDelete));
            }
        }
        class Circle extends GeometryObject {
            isNear(mx, my) {
                if (!this.p1 || !this.p2) return false;
                const r = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                return Math.abs(MathUtils.dist(mx, my, this.p1.x, this.p1.y) - r) < 8;
            }
            draw(ctx, o) {
                if (!this.p1 || !this.p2) return;
                const r = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                ctx.beginPath();
                ctx.arc(this.p1.x, this.p1.y, r, 0, Math.PI * 2);
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.stroke();
            }
        }
        class CompassCircle extends GeometryObject {
            constructor(center, rP1, rP2, id = null) {
                super(center, null, id);
                this.rP1 = rP1;
                this.rP2 = rP2;
            }
            getRadius() {
                if (this.rP1 && this.rP2) return MathUtils.dist(this.rP1.x, this.rP1.y, this.rP2.x, this.rP2.y);
                return 0;
            }
            isNear(mx, my) {
                if (!this.p1) return false;
                const r = this.getRadius();
                return Math.abs(MathUtils.dist(mx, my, this.p1.x, this.p1.y) - r) < 8;
            }
            draw(ctx, o) {
                if (!this.p1) return;
                const r = this.getRadius();
                ctx.beginPath();
                ctx.arc(this.p1.x, this.p1.y, r, 0, Math.PI * 2);
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.stroke();
            }
        }
        class CompassArc extends GeometryObject {
            constructor(center, radius, startAngle, endAngle, counterClockwise = false, id = null) {
                super(center, null, id);
                this.center = center;
                this.radius = radius;
                this.startAngle = startAngle;
                this.endAngle = endAngle;
                this.counterClockwise = counterClockwise;
            }

            isNear(mx, my) {
                if (!this.center) return false;
                const cx = this.center.x !== undefined ? this.center.x : 0;
                const cy = this.center.y !== undefined ? this.center.y : 0;

                const d = MathUtils.dist(mx, my, cx, cy);
                if (Math.abs(d - this.radius) > 8) return false;

                return MathUtils.isPointOnArc({ x: mx, y: my }, this);
            }

            draw(ctx, opts) {
                if (!this.center) return;
                const cx = this.center.x !== undefined ? this.center.x : 0;
                const cy = this.center.y !== undefined ? this.center.y : 0;

                ctx.beginPath();
                const s = this.getStyle("black", opts.isHovered, opts.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);

                ctx.arc(cx, cy, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
                ctx.stroke();
            }
        }

        class Angle extends GeometryObject {
            constructor(p1, p2, p3, id = null) {
                super(p1, p2, id);
                this.p3 = p3;
                this.showValue = true;
                this.isFilled = false;
                this.isCounterClockwise = false;

                if (p1 && p2 && p3) {
                    const a1 = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                    const a2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                    let diff = a2 - a1;
                    while (diff <= -Math.PI) diff += 2 * Math.PI;
                    while (diff > Math.PI) diff -= 2 * Math.PI;
                    this.isCounterClockwise = (diff > 0);
                }
            }

            isNear(mx, my) {
                if (!this.p2) return false;
                const d = MathUtils.dist(mx, my, this.p2.x, this.p2.y);
                return (d > 10 && d < 50);
            }
            getAngleValue() {
                if (!this.p1 || !this.p2 || !this.p3) return 0;
                const a1 = Math.atan2(this.p1.y - this.p2.y, this.p1.x - this.p2.x);
                const a2 = Math.atan2(this.p3.y - this.p2.y, this.p3.x - this.p2.x);
                let diff = a2 - a1;
                if (this.isCounterClockwise) {
                    if (diff < 0) diff += 2 * Math.PI;
                } else {
                    if (diff > 0) diff -= 2 * Math.PI;
                }
                return Math.abs(diff * 180 / Math.PI);
            }
            draw(ctx, { isHovered, isToDelete }) {
                if (!this.p1 || !this.p2 || !this.p3) return;

                const val = this.getAngleValue();
                const isRightAngle = Math.abs(val - 90) < 0.5;
                const radius = 25;

                let baseColor = this.color || "green";
                if (window.app && window.app.getThemeColor) baseColor = window.app.getThemeColor(baseColor);

                const isSelected = arguments[1] ? arguments[1].isSelected : false;
                const s = isToDelete ? "#d32f2f" : (isHovered ? baseColor : (isSelected ? "orange" : baseColor));
                const width = (isHovered || isSelected || isToDelete) ? 4 : 2;

                ctx.beginPath();
                ctx.strokeStyle = s;
                ctx.lineWidth = width;
                ctx.setLineDash([]);

                const a1 = Math.atan2(this.p1.y - this.p2.y, this.p1.x - this.p2.x);
                const a2 = Math.atan2(this.p3.y - this.p2.y, this.p3.x - this.p2.x);

                if (isRightAngle) {
                    const size = 16;
                    const d1 = MathUtils.dist(this.p2.x, this.p2.y, this.p1.x, this.p1.y);
                    const d2 = MathUtils.dist(this.p2.x, this.p2.y, this.p3.x, this.p3.y);
                    if (d1 > 0 && d2 > 0) {
                        const ux = (this.p1.x - this.p2.x) / d1 * size, uy = (this.p1.y - this.p2.y) / d1 * size;
                        const vx = (this.p3.x - this.p2.x) / d2 * size, vy = (this.p3.y - this.p2.y) / d2 * size;
                        ctx.moveTo(this.p2.x + ux, this.p2.y + uy);
                        ctx.lineTo(this.p2.x + ux + vx, this.p2.y + uy + vy);
                        ctx.lineTo(this.p2.x + vx, this.p2.y + vy);

                        if (this.isFilled) {
                            ctx.lineTo(this.p2.x, this.p2.y);
                            ctx.fillStyle = this.color ? this.color.replace('0.2', '0.4') : "rgba(39, 174, 96, 0.3)";
                            ctx.fill();
                        }
                        ctx.stroke();
                    }
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.p2.x, this.p2.y);
                    ctx.arc(this.p2.x, this.p2.y, radius, a1, a2, !this.isCounterClockwise);
                    ctx.closePath();

                    if (this.isFilled) {
                        ctx.fillStyle = this.color ? this.color.replace('0.2', '0.4') : "rgba(39, 174, 96, 0.3)";
                        ctx.fill();
                    }
                    ctx.stroke();
                }

                if (this.showValue && !isRightAngle) {
                    let diff = a2 - a1;
                    if (this.isCounterClockwise) {
                        if (diff < 0) diff += 2 * Math.PI;
                    } else {
                        if (diff > 0) diff -= 2 * Math.PI;
                    }

                    const midAngle = a1 + diff / 2;
                    const textDist = radius + 15;
                    const txtVal = Math.round(val) + "¬∞";

                    const tx = this.p2.x + Math.cos(midAngle) * textDist;
                    const ty = this.p2.y + Math.sin(midAngle) * textDist;

                    ctx.font = "bold 12px Segoe UI";
                    const tw = ctx.measureText(txtVal).width;
                    ctx.fillStyle = "rgba(255,255,255,0.7)";
                    ctx.fillRect(tx - tw / 2 - 2, ty - 8, tw + 4, 16);

                    ctx.fillStyle = s;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(txtVal, tx, ty);
                }
            }
        }

        class ParallelLine extends GeometryObject {
            constructor(p1, refLine, id = null) {
                super(p1, null, id);
                this.refLine = refLine;
                this.lineWidth = 3;
            }
            getDynamicP2() {
                if (!this.p1 || !this.refLine) return null;
                const c = MathUtils.getLineCoords(this.refLine);
                if (!c.p1 || !c.p2) return null;
                return {
                    x: this.p1.x + (c.p2.x - c.p1.x),
                    y: this.p1.y + (c.p2.y - c.p1.y)
                };
            }
            isNear(mx, my) {
                const p2 = this.getDynamicP2();
                if (!p2) return false;
                return MathUtils.distanceToLineVector(mx, my, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y) < 8;
            }
            draw(ctx, o) {
                const p2 = this.getDynamicP2();
                if (!this.p1 || !p2) return;
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                MathUtils.drawInfiniteLineFromVector(ctx, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y, s.color, s.width, s.dash);
            }
        }
        class PerpendicularLine extends GeometryObject {
            constructor(p1, refLine, id = null) {
                super(p1, null, id);
                this.refLine = refLine;
                this.lineWidth = 2;
            }

            getDynamicP2() {
                if (!this.p1 || !this.refLine) return null;
                const c = MathUtils.getLineCoords(this.refLine);
                if (!c.p1 || !c.p2) return null;
                const dx = c.p2.x - c.p1.x;
                const dy = c.p2.y - c.p1.y;
                return { x: this.p1.x - dy, y: this.p1.y + dx };
            }

            isNear(mx, my) {
                const p2 = this.getDynamicP2();
                if (!p2) return false;
                return MathUtils.distanceToLineVector(mx, my, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y) < 8;
            }

            draw(ctx, o) {
                const p2 = this.getDynamicP2();
                if (!this.p1 || !p2) return;

                const s = this.getStyle("black", o.isHovered, o.isToDelete);

                // 1. Tracer la ligne infinie
                MathUtils.drawInfiniteLineFromVector(ctx, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y, s.color, s.width, s.dash);

                // 2. Tracer le codage (Petit carr√©)
                const c = MathUtils.getLineCoords(this.refLine);
                if (c.p1 && c.p2) {
                    const infiniteRef = { p1: c.p1, p2: c.p2, constructor: { name: 'Line' } };
                    const H = MathUtils.getProjectedPoint(this.p1.x, this.p1.y, infiniteRef);
                    const angle = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);

                    ctx.save();
                    ctx.translate(H.x, H.y);
                    ctx.rotate(angle);

                    const dx = this.p1.x - H.x;
                    const dy = this.p1.y - H.y;
                    const localY = -dx * Math.sin(angle) + dy * Math.cos(angle);
                    const sign = localY >= 0 ? 1 : -1;

                    const size = 12;
                    ctx.beginPath();
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = s.color;
                    ctx.setLineDash([]);

                    ctx.moveTo(size, 0);
                    ctx.lineTo(size, sign * size);
                    ctx.lineTo(0, sign * size);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        class Polygon extends GeometryObject {
            constructor(points, id) {
                super(null, null, id);
                this.points = points;
                this.color = 'rgba(0, 150, 255, 0.2)';
                this.fillMode = 'solid';
                this.opacity = 0.2; // Opacit√© standard
            }
            getClosestSegment(mx, my) {
                let m = Infinity;
                let s = null;
                for (let i = 0; i < this.points.length; i++) {
                    const p1 = this.points[i],
                        p2 = this.points[(i + 1) % this.points.length];
                    const d = MathUtils.distanceToLine(mx, my, p1.x, p1.y, p2.x, p2.y, 'Segment');
                    if (d < m) {
                        m = d;
                        s = [p1, p2];
                    }
                }
                return {
                    seg: s,
                    dist: m
                };
            }
            isNear(mx, my) {
                if (!this.points || this.points.length < 3) return false;
                // Si on clique trop pr√®s du bord, on laisse la main aux segments du contour
                if (this.getClosestSegment(mx, my).dist < 8) return false;

                let inside = false;
                for (let i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
                    const xi = this.points[i].x;
                    const yi = this.points[i].y;
                    const xj = this.points[j].x;
                    const yj = this.points[j].y;

                    const intersect = ((yi > my) !== (yj > my)) &&
                        (mx < (xj - xi) * (my - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }
                return inside;
            }
            draw(ctx, o) {
                if (this.points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
                ctx.closePath();
                ctx.fillStyle = this.color;
                if (o.isHovered) ctx.fillStyle = 'rgba(0, 200, 255, 0.4)';
                if (o.isToDelete) ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.globalAlpha = 0.5;
                if (this.fillMode === 'solid') {
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                else if (this.fillMode === 'hatch') {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = PatternUtils.createHatchPattern(ctx, this.color);
                    ctx.fill();
                }
                else if (this.fillMode === 'dots') {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = PatternUtils.createDotPattern(ctx, this.color);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.strokeStyle = o.isToDelete ? '#d32f2f' : (o.isHovered ? '#00bcd4' : '#555');
                ctx.lineWidth = 1;
                ctx.setLineDash(this.dash);
                ctx.stroke();
            }
        }
        class Arc extends GeometryObject {
            constructor(center, radius, startAngle, endAngle, id = null) {
                super(null, null, id);
                this.center = center;
                this.radius = radius;
                this.startAngle = startAngle;
                this.endAngle = endAngle;
            }
            isNear(mx, my) {
                if (!this.center) return false;
                const d = MathUtils.dist(mx, my, this.center.x, this.center.y);
                if (Math.abs(d - this.radius) > 8) return false;
                return MathUtils.isPointOnArc({
                    x: mx,
                    y: my
                }, this);
            }
            draw(ctx, opts) {
                if (!this.center) return;
                ctx.beginPath();
                const s = this.getStyle("black", opts.isHovered, opts.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.arc(this.center.x, this.center.y, this.radius, this.startAngle, this.endAngle, this.startAngle > this.endAngle);
                ctx.stroke();
            }
        }

        // --- WIDGETS ---
        // =================================================================
        // CONFIGURATION GLOBALE DU STYLE
        // Modifiez ces valeurs pour changer l'apparence de tous les outils
        // =================================================================

        const ToolStyleArray = {
            pantoneVibrant: {
                name: "Pantone Vibrant üé®",
                compass: {
                    // M√©lange de "Little Boy Blue" et "Nautical Blue"
                    // Contour tr√®s fonc√© (Bleu marine profond)
                    colors: {
                        metalLight: '#7AA8D4', // Little Boy Blue
                        metalDark: '#2E4884',  // Nautical Blue
                        joint: '#BD3874',      // Pink Yarrow (Jointure rose vif)
                        needle: '#000000',
                        pencil: '#BD3874',     // Pink Yarrow
                        wood: '#FBC49F',       // Peach Fuzz
                        lead: '#000000',
                        knob: '#2E4884',       // Nautical Blue
                        outline: '#1A2B52'     // Nautical Blue tr√®s fonc√©
                    },
                    widths: { outline: 15, body: 13, arm: 11 }
                },
                setSquare: {
                    background: { color: '116, 201, 179', opacity: 0.8 }, // Bermuda (#74C9B3)
                    border: { color: '45, 99, 99', opacity: 1, width: 2 }, // Baltic Fonc√©
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" },
                    toggleBtn: { active: '#BD3874', inactive: '#E190AB' } // Pink Yarrow / Aurora
                },
                ruler: {
                    background: { color: '251, 196, 159', opacity: 0.85 }, // Peach Fuzz (#FBC49F)
                    border: { color: '186, 107, 30', opacity: 1, width: 2 }, // Blazing Orange Fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" },
                },
                protractor: {
                    background: { color: '225, 144, 171', opacity: 0.75 }, // Aurora Pink (#E190AB)
                    border: { color: '138, 34, 81', opacity: 1, width: 2 }, // Pink Yarrow Fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" },
                    components: { target: '#000000', lockActive: '#2E4884', lockInactive: '#74C9B3', swap: '#FCA757' }
                }
            },
            // =================================================================
            // 7. BOHO CHIC (Version R√©vis√©e : Textes Noirs & Bords Fonc√©s)
            // =================================================================
            default: {
                name: "D√©faut",
                compass: {
                    // Outline tr√®s fonc√© (#5e2a18) pour bien voir le compas
                    colors: { metalLight: '#D97D55', metalDark: '#A05030', joint: '#F4E9D7', needle: '#000000', pencil: '#6FA4AF', wood: '#F4E9D7', lead: '#000000', knob: '#F4E9D7', outline: '#5e2a18' },
                    widths: { outline: 14, body: 12, arm: 10 }
                },
                setSquare: {
                    background: { color: '244, 233, 215', opacity: 0.85 }, // Fond Lin
                    border: { color: '140, 70, 47', opacity: 1, width: 2 }, // Bordure Rouille fonc√©
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" }, // Texte Noir
                    toggleBtn: { active: '#6FA4AF', inactive: '#D97D55' }
                },
                ruler: {
                    background: { color: '184, 196, 169', opacity: 0.8 }, // Fond Vert gris
                    border: { color: '85, 96, 70', opacity: 1, width: 2 }, // Bordure Olive fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" }, // Texte Noir
                },
                protractor: {
                    background: { color: '111, 164, 175', opacity: 0.7 }, // Fond Bleu gris
                    border: { color: '40, 62, 68', opacity: 1, width: 2 }, // Bordure Bleu p√©trole fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" }, // Texte Noir
                    components: { target: '#000000', lockActive: '#D97D55', lockInactive: '#B8C4A9', swap: '#F4E9D7' }
                }
            },
            // =================================================================
            // 1. DEFAULT (Style Polypad / Material)
            // =================================================================
            classic: {
                name: "Classique üü¶", // <--- Le nom est ici maintenant
                compass: {
                    colors: { metalLight: '#dfe6e9', metalDark: '#b2bec3', joint: '#2d3436', needle: '#636e72', pencil: '#c0392b', wood: '#f3d2b5', lead: '#2d3436', knob: '#34495e', outline: '#000000' },
                    widths: { outline: 16, body: 14, arm: 12 }
                },
                setSquare: {
                    background: { color: '255, 213, 79', opacity: 0.6 },
                    border: { color: '0, 0, 0', opacity: 1, width: 1 },
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" },
                    toggleBtn: { active: '#66bb6a', inactive: '#ffa726' }
                },
                ruler: {
                    background: { color: '41, 182, 246', opacity: 0.6 },
                    border: { color: '0, 0, 0', opacity: 1, width: 1 },
                    graduations: { color: '#000000', strokeOpacity: 0.8, width: 1.5, font: "bold 12px sans-serif" },
                },
                protractor: {
                    background: { color: '128, 222, 234', opacity: 0.5 },
                    border: { color: '0, 0, 0', opacity: 1, width: 1 },
                    graduations: { color: '#000000', strokeOpacity: 0.8, width: 1, widthMajor: 2, font: "bold 11px sans-serif" },
                    components: { target: '#000000', lockActive: '#ef5350', lockInactive: '#66bb6a', swap: '#42a5f5' }
                }
            },
            // =================================================================
            // 8. MODERN GRAY (Version Monochrome : Contraste & √âl√©gance)
            // =================================================================
            modernGray: {
                name: "Gris Moderne üåö",
                compass: {
                    // Outline tr√®s fonc√© (#1F2937) pour d√©tacher le compas du fond
                    // MetalLight/Dark : Effet argent√© et acier
                    colors: { metalLight: '#D1D5DB', metalDark: '#6B7280', joint: '#F3F4F6', needle: '#000000', pencil: '#9CA3AF', wood: '#E5E7EB', lead: '#000000', knob: '#F3F4F6', outline: '#1F2937' },
                    widths: { outline: 14, body: 12, arm: 10 }
                },
                setSquare: {
                    background: { color: '229, 231, 235', opacity: 0.85 }, // Fond Gris tr√®s clair (presque blanc)
                    border: { color: '55, 65, 81', opacity: 1, width: 2 }, // Bordure Gris Anthracite
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" }, // Texte Noir
                    toggleBtn: { active: '#374151', inactive: '#D1D5DB' }
                },
                ruler: {
                    background: { color: '209, 213, 219', opacity: 0.8 }, // Fond Gris Argent√© (un peu plus soutenu)
                    border: { color: '31, 41, 55', opacity: 1, width: 2 }, // Bordure Gris tr√®s fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" }, // Texte Noir
                },
                protractor: {
                    background: { color: '156, 163, 175', opacity: 0.7 }, // Fond Gris Moyen (effet verre fum√©)
                    border: { color: '17, 24, 39', opacity: 1, width: 2 }, // Bordure Presque Noir
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" }, // Texte Noir
                    components: { target: '#000000', lockActive: '#4B5563', lockInactive: '#E5E7EB', swap: '#F9FAFB' }
                }
            },

            // =================================================================
            // 2. BLACK & WHITE
            // =================================================================
            blackAndWhite: {
                name: "Noir & Blanc üìì",
                compass: {
                    colors: { metalLight: '#ffffff', metalDark: '#dcdcdc', joint: '#000000', needle: '#000000', pencil: '#ffffff', wood: '#ffffff', lead: '#000000', knob: '#ffffff', outline: '#000000' },
                    widths: { outline: 16, body: 14, arm: 12 }
                },
                setSquare: {
                    background: { color: '255, 255, 255', opacity: 0.8 },
                    border: { color: '0, 0, 0', opacity: 1, width: 2 },
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px Courier New" },
                    toggleBtn: { active: '#000000', inactive: '#ffffff' }
                },
                ruler: {
                    background: { color: '255, 255, 255', opacity: 0.8 },
                    border: { color: '0, 0, 0', opacity: 1, width: 2 },
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px Courier New" },
                },
                protractor: {
                    background: { color: '255, 255, 255', opacity: 0.8 },
                    border: { color: '0, 0, 0', opacity: 1, width: 2 },
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px Courier New" },
                    components: { target: '#000000', lockActive: '#000000', lockInactive: '#ffffff', swap: '#000000' }
                }
            },

            // =================================================================
            // 3. RETRO VINTAGE
            // =================================================================
            retro: {
                name: "R√©tro Vintage üìú",
                compass: {
                    colors: { metalLight: '#d4af37', metalDark: '#aa8c2c', joint: '#3e2723', needle: '#2f3640', pencil: '#8b4513', wood: '#deb887', lead: '#2f3640', knob: '#8b4513', outline: '#3e2723' },
                    widths: { outline: 16, body: 14, arm: 12 }
                },
                setSquare: {
                    background: { color: '210, 105, 30', opacity: 0.5 },
                    border: { color: '139, 69, 19', opacity: 1, width: 2 },
                    graduations: { color: '#3e2723', width: 1.5, font: "bold 12px Times New Roman" },
                    toggleBtn: { active: '#556b2f', inactive: '#cd853f' }
                },
                ruler: {
                    background: { color: '222, 184, 135', opacity: 0.8 },
                    border: { color: '139, 69, 19', opacity: 1, width: 2 },
                    graduations: { color: '#3e2723', strokeOpacity: 0.9, width: 1.5, font: "bold 12px Times New Roman" },
                },
                protractor: {
                    background: { color: '240, 230, 140', opacity: 0.6 },
                    border: { color: '85, 107, 47', opacity: 1, width: 2 },
                    graduations: { color: '#3e2723', strokeOpacity: 0.9, width: 1, widthMajor: 2, font: "bold 11px Times New Roman" },
                    components: { target: '#3e2723', lockActive: '#8b0000', lockInactive: '#556b2f', swap: '#cd853f' }
                }
            },




            // =================================================================
            // 6. EARTH & FOREST
            // =================================================================
            earthForest: {
                name: "For√™t & Terre üå≤",
                compass: {
                    colors: { metalLight: '#9E3C59', metalDark: '#1A253A', joint: '#E5BA41', needle: '#D1855C', pencil: '#D1855C', wood: '#E5BA41', lead: '#2c3e50', knob: '#94A378', outline: '#1A253A' },
                    widths: { outline: 16, body: 14, arm: 12 }
                },
                setSquare: {
                    background: { color: '148, 163, 120', opacity: 0.75 },
                    border: { color: '45, 60, 89', opacity: 1, width: 2 },
                    graduations: { color: '#2D3C59', width: 1.5, font: "bold 12px serif" },
                    toggleBtn: { active: '#E5BA41', inactive: '#D1855C' }
                },
                ruler: {
                    background: { color: '229, 186, 65', opacity: 0.7 },
                    border: { color: '209, 133, 92', opacity: 1, width: 2 },
                    graduations: { color: '#2D3C59', strokeOpacity: 0.9, width: 1.5, font: "bold 12px serif" },
                },
                protractor: {
                    background: { color: '209, 133, 92', opacity: 0.7 },
                    border: { color: '100, 50, 30', opacity: 1, width: 2 },
                    graduations: { color: '#2D3C59', strokeOpacity: 0.9, width: 1, widthMajor: 2, font: "bold 11px serif" },
                    components: { target: '#2D3C59', lockActive: '#2D3C59', lockInactive: '#94A378', swap: '#E5BA41' }
                }
            },

            // =================================================================
            // 7. BOHO CHIC
            // =================================================================



            // =================================================================
            // STYLE B : INTERIOR 2025 (Image 3)
            // Couleurs : Mocha, True Joy (Moutarde), Purple Basil, Encore (Bleu)
            // =================================================================


            // =================================================================
            // STYLE C : POP ART CYMK (Image 4)
            // Couleurs : Violet (#7F58AF), Cyan (#64C5EB), Rose (#E84D8A), Jaune (#FEB326)
            // =================================================================
            popArt: {
                name: "Pop Art üç≠",
                compass: {
                    colors: { metalLight: '#7F58AF', metalDark: '#503080', joint: '#FEB326', needle: '#000000', pencil: '#E84D8A', wood: '#FEB326', lead: '#000000', knob: '#64C5EB', outline: '#503080' },
                    widths: { outline: 15, body: 13, arm: 11 }
                },
                setSquare: {
                    background: { color: '100, 197, 235', opacity: 0.8 }, // Cyan
                    border: { color: '40, 120, 160', opacity: 1, width: 2 }, // Cyan fonc√©
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" },
                    toggleBtn: { active: '#E84D8A', inactive: '#FEB326' }
                },
                ruler: {
                    background: { color: '254, 179, 38', opacity: 0.85 }, // Jaune
                    border: { color: '180, 120, 10', opacity: 1, width: 2 }, // Moutarde fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" },
                },
                protractor: {
                    background: { color: '232, 77, 138', opacity: 0.75 }, // Rose
                    border: { color: '150, 40, 80', opacity: 1, width: 2 }, // Bordeaux
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" },
                    components: { target: '#000000', lockActive: '#7F58AF', lockInactive: '#FEB326', swap: '#64C5EB' }
                }
            },

            // =================================================================
            // STYLE D : NAVY & CORAL (Image 5)
            // Couleurs : Navy (#1A2C79), Magenta (#E80566), P√™che (#FF8D68), Cr√®me (#F4EABC)
            // =================================================================


            // =================================================================
            // STYLE E : BERRY & TEAL (Image 6)
            // Couleurs : Berry (#C14364), Coral (#FF916B), Cream (#EEE2D1), Teal (#2CA18C)
            // =================================================================


            // =================================================================
            // STYLE F : BLUE LAGOON (Image 7)
            // Couleurs : Navy (#0A1D37), Slate (#3A6D8C), Muted Blue (#6A9AB0), Beige (#EAD8B1)
            // =================================================================
            blueLagoon: {
                name: "Blue Lagoon üåä",
                compass: {
                    colors: { metalLight: '#3A6D8C', metalDark: '#0A1D37', joint: '#EAD8B1', needle: '#000000', pencil: '#6A9AB0', wood: '#EAD8B1', lead: '#000000', knob: '#0A1D37', outline: '#000000' },
                    widths: { outline: 15, body: 13, arm: 11 }
                },
                setSquare: {
                    background: { color: '234, 216, 177', opacity: 0.85 }, // Beige
                    border: { color: '10, 29, 55', opacity: 1, width: 2 }, // Bordure Navy pour contraste fort
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" },
                    toggleBtn: { active: '#3A6D8C', inactive: '#6A9AB0' }
                },
                ruler: {
                    background: { color: '58, 109, 140', opacity: 0.8 }, // Slate Blue
                    border: { color: '10, 29, 55', opacity: 1, width: 2 }, // Navy
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" },
                },
                protractor: {
                    background: { color: '106, 154, 176', opacity: 0.75 }, // Muted Blue
                    border: { color: '30, 60, 80', opacity: 1, width: 2 }, // Bleu fonc√©
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" },
                    components: { target: '#000000', lockActive: '#EAD8B1', lockInactive: '#0A1D37', swap: '#3A6D8C' }
                }
            },

            // =================================================================
            // 9. NORDIC ICE
            // =================================================================

            // =================================================================
            // 17. TREND 2025 (Palette Design)
            // Couleurs : Mocha Mousse, Rumors, Cinnamon Slate, True Joy,
            //            Purple Basil, Encore, Raku, Quietude.
            // =================================================================
            trend2025: {
                name: "Trend 2025 üé®",
                compass: {
                    // Un m√©lange sophistiqu√© de Gris chaud, Sauge et accents Prune
                    colors: {
                        metalLight: '#A8B8B0', // Quietude (Sauge clair)
                        metalDark: '#7C6E70',  // Cinnamon Slate (Gris chaud)
                        joint: '#683B39',      // Rumors (Bordeaux)
                        needle: '#000000',
                        pencil: '#DDB756',     // True Joy (Moutarde)
                        wood: '#9A6B58',       // Mocha Mousse (Terracotta)
                        lead: '#000000',
                        knob: '#554452',       // Purple Basil (Prune)
                        outline: '#38221D'     // Raku (Brun noir tr√®s fonc√©)
                    },
                    widths: { outline: 15, body: 13, arm: 11 }
                },
                setSquare: {
                    background: { color: '221, 183, 86', opacity: 0.85 }, // True Joy (Moutarde)
                    border: { color: '85, 68, 82', opacity: 1, width: 2 }, // Purple Basil (Prune fonc√©)
                    graduations: { color: '#000000', width: 1.5, font: "bold 12px sans-serif" },
                    toggleBtn: { active: '#683B39', inactive: '#9A6B58' } // Rumors / Mocha
                },
                ruler: {
                    background: { color: '154, 107, 88', opacity: 0.8 }, // Mocha Mousse (Terracotta)
                    border: { color: '56, 34, 29', opacity: 1, width: 2 }, // Raku (Brun noir)
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1.5, font: "bold 12px sans-serif" },
                },
                protractor: {
                    background: { color: '168, 184, 176', opacity: 0.8 }, // Quietude (Sauge)
                    border: { color: '36, 70, 107', opacity: 1, width: 2 }, // Encore (Bleu Nuit)
                    graduations: { color: '#000000', strokeOpacity: 1, width: 1, widthMajor: 2, font: "bold 11px sans-serif" },
                    components: { target: '#000000', lockActive: '#683B39', lockInactive: '#24466B', swap: '#DDB756' }
                }
            }
        }


        let ToolStyle = ToolStyleArray['default'];

        // =================================================================

        // =================================================================
        // CLASSES DES WIDGETS
        // =================================================================

        class CompassWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 120;
                this.angle = 0;
                this.legLength = 280;
                this.widgetRotationOffset = 0;
                // On utilise directement ToolStyle.compass dans le draw
            }
            toGlobal(lx, ly) {
                // On inverse la formule de rotation/translation
                return {
                    x: this.x + lx * Math.cos(this.angle) - ly * Math.sin(this.angle),
                    y: this.y + lx * Math.sin(this.angle) + ly * Math.cos(this.angle)
                };
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }

            getHitZone(mx, my) {
                const local = this.toLocal(mx, my);
                const h = Math.sqrt(this.legLength ** 2 - (this.radius / 2) ** 2);
                const headX = this.radius / 2;
                const headY = -h;

                // 1. Zone de TRAC√â (La mine du crayon)
                if (MathUtils.dist(local.x, local.y, this.radius, 0) < 20) return 'trace';

                // 2. Zone de D√âPLACEMENT (Le corps principal)
                if (MathUtils.distanceToSegment(local.x, local.y, headX, headY - 30, 0, 0) < 15) return 'move';
                // Pointe s√®che
                //if (MathUtils.dist(local.x, local.y, 0, 0) < 5) return 'move';

                // 3. Zone d'√âCARTEMENT (La branche du crayon)
                const legStartX = this.radius;
                const legStartY = 0;
                const resizeEndPos = { x: legStartX + (headX - legStartX) * 0.15, y: legStartY + (headY - legStartY) * 0.15 };
                if (MathUtils.distanceToSegment(local.x, local.y, legStartX, legStartY - 20, resizeEndPos.x, resizeEndPos.y) < 20) return 'resize';

                // ==================================================
                // 4. NOUVELLE ZONE DE ROTATION (Le "Coude" droit)
                // ==================================================
                const elbowX = this.radius;
                const elbowY = -25;
                // On d√©finit une zone ronde autour de l'articulation du crayon
                if (MathUtils.distanceToSegment(local.x, local.y, headX, headY, elbowX, elbowY) < 25) {
                    return 'rotate'; // <--- C'est ici que la magie op√®re
                }

                // (L'ancienne zone en haut est supprim√©e)

                return null;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const style = ToolStyle.compass; // Raccourci vers la config

                // --- G√âOM√âTRIE ---
                const h = Math.sqrt(this.legLength ** 2 - (this.radius / 2) ** 2);
                const headX = this.radius / 2;
                const headY = -h;

                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                // ==================================================
                // 1. BRANCHE GAUCHE (Pointe S√®che)
                // ==================================================

                // A. Le contour NOIR
                ctx.beginPath();
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = style.widths.outline;
                ctx.moveTo(headX, headY);
                ctx.lineTo(0, -15);
                ctx.stroke();

                // B. L'int√©rieur M√âTAL
                ctx.beginPath();
                ctx.strokeStyle = style.colors.metalLight;
                ctx.lineWidth = style.widths.body;
                ctx.moveTo(headX, headY);
                ctx.lineTo(0, -15);
                ctx.stroke();

                // Pointe
                ctx.beginPath();
                ctx.fillStyle = style.colors.needle;
                ctx.moveTo(-3, -15); ctx.lineTo(3, -15); ctx.lineTo(0, 0); ctx.fill();
                ctx.beginPath(); ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1; ctx.moveTo(-1, -14); ctx.lineTo(0, -2); ctx.stroke();

                // Articulation bas gauche
                ctx.beginPath();
                ctx.fillStyle = style.colors.outline;
                ctx.arc(0, -15, 7, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = style.colors.metalDark;
                ctx.arc(0, -15, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = style.colors.joint;
                ctx.arc(0, -15, 2, 0, Math.PI * 2);
                ctx.fill();

                // ==================================================
                // 2. BRANCHE DROITE (Porte-Crayon)
                // ==================================================
                const elbowX = this.radius;
                const elbowY = -25;

                // A. Le contour NOIR
                ctx.beginPath();
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = style.widths.outline;
                ctx.moveTo(headX, headY);
                ctx.lineTo(elbowX - 6, elbowY - 10);
                ctx.stroke();

                // B. L'int√©rieur M√âTAL
                ctx.beginPath();
                ctx.strokeStyle = style.colors.metalLight;
                ctx.lineWidth = style.widths.body;
                ctx.moveTo(headX, headY);
                ctx.lineTo(elbowX - 6, elbowY - 10);
                ctx.stroke();

                // ==================================================
                // 3. LE CRAYON
                // ==================================================
                ctx.save();
                ctx.translate(this.radius, 0);
                // Mine
                ctx.beginPath(); ctx.fillStyle = style.colors.lead; ctx.moveTo(0, 0); ctx.lineTo(1.5, -5); ctx.lineTo(-1.5, -5); ctx.fill();
                // Bois
                ctx.beginPath(); ctx.fillStyle = style.colors.wood; ctx.moveTo(-1.5, -5); ctx.lineTo(1.5, -5); ctx.lineTo(5, -18); ctx.lineTo(-5, -18); ctx.fill();

                // Corps du crayon
                const penH = 55;
                ctx.fillStyle = style.colors.pencil;
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = 1;

                ctx.fillRect(-5, -18 - penH, 10, penH);
                ctx.strokeRect(-5, -18 - penH, 10, penH);

                ctx.fillStyle = "rgba(255,255,255,0.2)";
                ctx.fillRect(-2, -18 - penH, 2, penH);

                // Bague
                ctx.translate(0, elbowY);
                ctx.beginPath();
                ctx.fillStyle = style.colors.metalDark;
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = 1;
                if (ctx.roundRect) {
                    ctx.roundRect(-7, -8, 14, 16, 2);
                    ctx.fill(); ctx.stroke();
                } else {
                    ctx.rect(-7, -8, 14, 16);
                    ctx.fill(); ctx.stroke();
                }
                ctx.restore();

                // ==================================================
                // 4. BRAS DE FIXATION & VIS
                // ==================================================

                // A. Contour Noir
                ctx.beginPath();
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = style.widths.arm + 2; // +2 pour le contour
                ctx.lineCap = "butt";
                ctx.moveTo(elbowX - 10, elbowY - 10);
                ctx.lineTo(this.radius, elbowY - 10);
                ctx.stroke();

                // B. Int√©rieur M√©tal
                ctx.beginPath();
                ctx.strokeStyle = style.colors.metalLight;
                ctx.lineWidth = style.widths.arm;
                ctx.lineCap = "butt";
                ctx.moveTo(elbowX - 10, elbowY - 10);
                ctx.lineTo(this.radius, elbowY - 10);
                ctx.stroke();

                // 5. POIGN√âE DE ROTATION (MOLETTE)
                ctx.save();
                ctx.translate(elbowX, elbowY - 10);
                ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 6; ctx.shadowOffsetY = 3;

                ctx.beginPath();
                ctx.fillStyle = style.colors.knob;
                ctx.arc(0, 0, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.lineWidth = 1; ctx.strokeStyle = "#000"; ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.beginPath(); ctx.fillStyle = style.colors.metalDark; ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.fillStyle = "#dfe6e9"; ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();

                ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    ctx.save(); ctx.rotate((i / 12) * Math.PI * 2); ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(14, 0); ctx.stroke(); ctx.restore();
                }
                ctx.restore();

                // 6. T√äTE DU COMPAS
                ctx.save();
                ctx.translate(headX, headY);

                ctx.beginPath();
                ctx.fillStyle = style.colors.metalLight;
                ctx.arc(0, 0, 13, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.strokeStyle = style.colors.outline;
                ctx.lineWidth = 1.5;
                ctx.arc(0, 0, 13, 0, Math.PI * 2);
                ctx.stroke();

                ctx.beginPath(); ctx.fillStyle = style.colors.joint; ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                // 7. GHOST (Mesure)
                if (typeof app !== 'undefined' && app.draggedWidgetMode === 'resize' && app.draggedWidget === this) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([3, 3]);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.radius, 0);
                    ctx.stroke();
                    ctx.translate(this.radius / 2, -40);
                    ctx.rotate(-this.angle);
                    const val = Math.round(this.radius / 5) / 10;
                    const text = val + " cm";
                    ctx.font = "bold 13px Segoe UI, sans-serif";
                    const w = ctx.measureText(text).width + 12;
                    ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
                    ctx.shadowColor = "rgba(0,0,0,0.2)";
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    if (ctx.roundRect) ctx.roundRect(-w / 2, -12, w, 24, 4);
                    else ctx.fillRect(-w / 2, -12, w, 24);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = "#2c3e50";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(text, 0, 1);
                    ctx.restore();
                }

                ctx.restore();
            }
        }

        class SetSquareWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.scale = 1;
                this.width = 400;
                this.height = 250;
                this.widgetRotationOffset = 0;
                this.slideMode = false;
            }
            toGlobal(lx, ly) {
                // On inverse la formule de rotation/translation
                return {
                    x: this.x + lx * Math.cos(this.angle) - ly * Math.sin(this.angle),
                    y: this.y + lx * Math.sin(this.angle) + ly * Math.cos(this.angle)
                };
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }
            getHitZone(mx, my) {
                const coll = 15; // Constante pour laisser l'angle droit
                const l = this.toLocal(mx, my);
                if (l.x < coll && l.y < coll) return null;
                if (l.x > 20 && l.x < 60 && l.y > 20 && l.y < 60) return 'toggleSlide';
                if (l.x >= coll && l.y >= coll && (l.y <= -this.height / this.width * l.x + this.height)) {
                    if (l.y < 30) return this.slideMode ? 'slideX' : 'rotate';
                    if (l.x < 30) return this.slideMode ? 'slideY' : 'rotate';
                    return 'move';
                }
                return null;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const style = ToolStyle.setSquare;

                // --- 0. FONCTION CONTRASTE ---
                const getContrastColor = (hex) => {
                    if (!hex) return 'white';
                    hex = hex.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                    return (yiq >= 128) ? '#333333' : 'white';
                };

                // --- 1. FORME PRINCIPALE ---
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.width, 0);
                ctx.lineTo(0, this.height);
                ctx.closePath();

                ctx.fillStyle = `rgba(${style.background.color}, ${style.background.opacity})`;
                ctx.fill();

                ctx.lineWidth = style.border.width;
                ctx.strokeStyle = `rgba(${style.border.color}, ${style.border.opacity})`;
                ctx.stroke();

                // --- 2. GRADUATIONS ---
                const mm = 5;
                const cm = 50;
                const padding = 30;

                ctx.fillStyle = style.graduations.color;
                ctx.strokeStyle = style.graduations.color;
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.font = style.graduations.font;
                ctx.lineWidth = style.graduations.width;

                // Axe X
                for (let i = 0; i <= this.width - padding; i += mm) {
                    let len = 6;
                    if (i % cm === 0) len = 14;
                    else if (i % (cm / 2) === 0) len = 9;

                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, len);
                    ctx.stroke();
                    if (i > 0 && i % cm === 0) ctx.fillText(i / cm, i, 28);
                }

                // Axe Y
                ctx.textBaseline = "middle";
                for (let i = 0; i <= this.height - padding; i += mm) {
                    let len = 6;
                    if (i % cm === 0) len = 14;
                    else if (i % (cm / 2) === 0) len = 9;

                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(len, i);
                    ctx.stroke();
                    if (i > 0 && i % cm === 0) {
                        ctx.save();
                        ctx.translate(22, i);
                        ctx.rotate(-Math.PI / 2);
                        ctx.fillText(i / cm, 0, 0);
                        ctx.restore();
                    }
                }

                // --- 3. BOUTON TOGGLE AJUST√â ---

                // D√©calage l√©ger en bas √† droite (+3px)
                const btnX = 50;
                const btnY = 50;
                const btnColor = this.slideMode ? style.toggleBtn.active : style.toggleBtn.inactive;

                const drawBtn = (bx, by, color, isSlideMode) => {
                    const size = 26; // Taille r√©duite (√©tait 30)
                    const radius = 6; // Arrondi un peu plus doux

                    ctx.save();
                    ctx.translate(bx, by);

                    // A. Fond Carr√© Arrondi
                    ctx.beginPath();
                    if (ctx.roundRect) ctx.roundRect(-size / 2, -size / 2, size, size, radius);
                    else ctx.rect(-size / 2, -size / 2, size, size);
                    ctx.fillStyle = color;
                    ctx.fill();

                    // B. Contour
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = "white";
                    ctx.stroke();

                    // C. Ic√¥ne
                    const iconColor = getContrastColor(color);
                    ctx.strokeStyle = iconColor;
                    ctx.fillStyle = iconColor;
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";

                    if (isSlideMode) {
                        // MODE SLIDE (Croix fine)
                        const len = 6; // un peu plus petit pour rentrer dans 26px
                        const tip = 2;

                        ctx.beginPath();
                        // Horizontal
                        ctx.moveTo(-len, 0); ctx.lineTo(len, 0);
                        ctx.moveTo(-len + tip, -tip); ctx.lineTo(-len, 0); ctx.lineTo(-len + tip, tip);
                        ctx.moveTo(len - tip, -tip); ctx.lineTo(len, 0); ctx.lineTo(len - tip, tip);
                        // Vertical
                        ctx.moveTo(0, -len); ctx.lineTo(0, len);
                        ctx.moveTo(-tip, -len + tip); ctx.lineTo(0, -len); ctx.lineTo(tip, -len + tip);
                        ctx.moveTo(-tip, len - tip); ctx.lineTo(0, len); ctx.lineTo(tip, len - tip);
                        ctx.stroke();

                    } else {
                        // MODE ROTATION (Sens invers√© : Horaire)
                        const r = 5.5; // Rayon adapt√© √† la nouvelle taille

                        ctx.beginPath();
                        // Arc de cercle (sens horaire : de PI √† -PI/2 par ex)
                        // On part de la gauche (PI) on va vers le haut (-PI/2)
                        ctx.arc(0, 0, r, 0, 3 * Math.PI / 2, false);
                        ctx.stroke();

                        // Pointe de la fl√®che (au bout, en haut)
                        // L'arc finit √† -PI/2 (en haut : 0, -r)
                        // La fl√®che doit pointer vers la droite (sens horaire)
                        ctx.beginPath();
                        ctx.moveTo(-2, -r - 2); // Point haut gauche
                        ctx.lineTo(1, -r);      // Pointe sur le cercle (un peu d√©cal√©e pour le style)
                        ctx.lineTo(-2, -r + 2); // Point bas gauche
                        ctx.stroke();

                        // Pivot central
                        ctx.beginPath();
                        ctx.arc(0, 0, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                };

                drawBtn(btnX, btnY, btnColor, this.slideMode);

                ctx.restore();
            }
        }

        class RulerWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.width = 600;
                this.height = 60;
                this.widgetRotationOffset = 0;
            }
            toGlobal(lx, ly) {
                // On inverse la formule de rotation/translation
                return {
                    x: this.x + lx * Math.cos(this.angle) - ly * Math.sin(this.angle),
                    y: this.y + lx * Math.sin(this.angle) + ly * Math.cos(this.angle)
                };
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }
            getHitZone(mx, my) {
                const l = this.toLocal(mx, my);
                if (l.x >= 0 && l.x <= this.width && l.y >= 5 && l.y <= this.height) {
                    if (l.y < 20 && l.y > 5) return 'rotate';
                    if (l.y > 20 && l.y < this.height - 5 && l.x > 20 && l.x < this.width - 20) return 'move';
                    return null;
                }
                return null;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const style = ToolStyle.ruler; // CONFIG

                // --- FOND ---
                ctx.fillStyle = `rgba(${style.background.color}, ${style.background.opacity})`;

                ctx.beginPath();
                ctx.rect(0, 0, this.width, this.height);
                ctx.fill();

                // Reflet l√©ger (reste en blanc pur pour l'instant avec opacit√© faible)
                ctx.fillStyle = "rgba(255,255,255,0.2)";
                ctx.fillRect(0, 0, this.width, this.height / 2);

                // Bordure (si d√©finie)
                if (style.border.width > 0) {
                    ctx.lineWidth = style.border.width;
                    ctx.strokeStyle = `rgba(${style.border.color}, ${style.border.opacity})`;
                    ctx.strokeRect(0, 0, this.width, this.height);
                }

                const mm = 5;
                const cm = 50;

                // --- GRADUATIONS ---
                ctx.strokeStyle = `rgba(0, 0, 0, ${style.graduations.strokeOpacity})`;
                ctx.fillStyle = style.graduations.color;
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.font = style.graduations.font;
                ctx.lineWidth = style.graduations.width;

                for (let i = 0; i <= this.width - 20; i += mm) {
                    let len = 6;
                    if (i % cm === 0) len = 18;
                    else if (i % (cm / 2) === 0) len = 12;

                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, len);
                    ctx.stroke();

                    if (i > 0 && i % cm === 0) {
                        ctx.fillText(i / cm, i, 22);
                    }
                }
                ctx.restore();
            }
        }

        class ProtractorWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.radius = 180;
                this.isLocked = false;
                this.isReversed = false;
            }
            toGlobal(lx, ly) {
                // On inverse la formule de rotation/translation
                return {
                    x: this.x + lx * Math.cos(this.angle) - ly * Math.sin(this.angle),
                    y: this.y + lx * Math.sin(this.angle) + ly * Math.cos(this.angle)
                };
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }

            getHitZone(mx, my) {
                const l = this.toLocal(mx, my);
                const d = Math.sqrt(l.x * l.x + l.y * l.y);
                if (Math.abs(l.x) < 12 && l.y < -30 && l.y > -60) return 'toggleLock';
                if (Math.abs(l.x) < 12 && l.y >= -85 && l.y <= -61) return 'toggleSwap';
                if (this.isLocked) {
                    if (d < 30) return 'traceAngle';
                    return null;
                }
                if (d < 20) return 'move';
                if (d > this.radius - 30 && d < this.radius + 10 && l.y < 0) return 'rotate';
                if (d < this.radius && l.y < 0) return 'move';
                return null;
            }


            draw(ctx) {
                if (!ToolStyle.protractor) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                const style = ToolStyle.protractor;
                const r = this.radius;
                const skirt = 15;

                // --- 0. FONCTION MAGIQUE (Calcul du contraste) ---
                // Cette fonction d√©cide si l'ic√¥ne doit √™tre blanche ou noire
                const getContrastColor = (hex) => {
                    if (!hex) return 'white';
                    // On enl√®ve le # si pr√©sent
                    hex = hex.replace('#', '');
                    // On extrait Rouge, Vert, Bleu
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    // Formule de luminosit√© per√ßue (YIQ)
                    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                    // Si > 128 c'est clair -> texte fonc√© (#333), sinon texte blanc
                    return (yiq >= 128) ? '#333333' : 'white';
                };

                // ============================================================
                // 1. FOND
                // ============================================================
                ctx.beginPath();
                ctx.moveTo(-r, skirt);
                ctx.lineTo(r, skirt);
                ctx.lineTo(r, 0);
                ctx.arc(0, 0, r, 0, Math.PI, true);
                ctx.closePath();

                ctx.fillStyle = `rgba(${style.background.color}, 0.4)`;
                ctx.fill();

                if (style.border.width > 0) {
                    ctx.lineWidth = style.border.width;
                    ctx.strokeStyle = `rgba(${style.border.color}, ${style.border.opacity})`;
                    ctx.stroke();
                }

                // ============================================================
                // 2. LIGNE DE BASE & VISEUR
                // ============================================================
                const gap = 35;
                ctx.beginPath();
                ctx.moveTo(-(r - gap), 0);
                ctx.lineTo((r - gap), 0);

                // Viseur
                ctx.moveTo(0, -6); ctx.lineTo(0, 8);
                ctx.moveTo(-6, 0); ctx.lineTo(6, 0);

                ctx.lineWidth = 1.5;
                ctx.strokeStyle = '#000000';
                ctx.stroke();

                // ============================================================
                // 3. GRADUATIONS
                // ============================================================
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = style.graduations.font;

                for (let i = 0; i <= 180; i++) {
                    const ang = Math.PI + (i * Math.PI / 180);
                    const cos = Math.cos(ang);
                    const sin = Math.sin(ang);

                    let len = 6;
                    ctx.lineWidth = style.graduations.width;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${style.graduations.strokeOpacity})`;

                    if (i % 5 === 0) len = 10;
                    if (i % 10 === 0) {
                        len = 15;
                        ctx.lineWidth = style.graduations.widthMajor;
                    }

                    ctx.beginPath();
                    ctx.moveTo(cos * (r - len), sin * (r - len));
                    ctx.lineTo(cos * r, sin * r);
                    ctx.stroke();

                    if (i % 10 === 0) {
                        const valOuter = this.isReversed ? (180 - i) : i;
                        ctx.fillStyle = style.graduations.color;
                        let tx = cos * (r - 25);
                        let ty = sin * (r - 25);
                        if (i === 0 || i === 180) ty = 0;
                        ctx.fillText(valOuter, tx, ty);
                    }
                }

                // ============================================================
                // 4. BOUTONS AUTOMATIQUES
                // ============================================================

                // J'ai enlev√© le param√®tre "iconColor" car il est calcul√© dedans maintenant
                const drawIconBtn = (y, btnColor, type) => {
                    const size = 24;
                    const radius = 6;

                    // --- AUTO-CONTRASTE ICI ---
                    const autoIconColor = getContrastColor(btnColor);

                    ctx.save();
                    ctx.translate(0, y);

                    // A. Fond
                    ctx.beginPath();
                    if (ctx.roundRect) ctx.roundRect(-size / 2, -size / 2, size, size, radius);
                    else ctx.rect(-size / 2, -size / 2, size, size);

                    ctx.fillStyle = btnColor;
                    ctx.fill();

                    // B. Contour
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "white";
                    ctx.stroke();

                    // C. Ic√¥ne (avec la couleur automatique)
                    ctx.fillStyle = autoIconColor;
                    ctx.strokeStyle = autoIconColor;

                    ctx.lineCap = "round";
                    ctx.lineJoin = "round";
                    ctx.lineWidth = 2;

                    if (type === 'swap') {
                        const w = 5; // Demi-largeur (total 10px)
                        const h = 2.5; // Demi-hauteur de la pointe (total 5px)

                        ctx.beginPath();

                        // 1. La barre horizontale (fine)
                        ctx.moveTo(-w, 0);
                        ctx.lineTo(w, 0);

                        // 2. Pointe Gauche (<)
                        ctx.moveTo(-w + h, -h);
                        ctx.lineTo(-w, 0);
                        ctx.lineTo(-w + h, h);

                        // 3. Pointe Droite (>)
                        ctx.moveTo(w - h, -h);
                        ctx.lineTo(w, 0);
                        ctx.lineTo(w - h, h);

                        ctx.stroke();

                    } else if (type === 'lock' || type === 'unlock') {
                        // Corps
                        const w = 10; const h = 8;
                        ctx.beginPath();
                        if (ctx.roundRect) ctx.roundRect(-w / 2, 0, w, h, 2);
                        else ctx.rect(-w / 2, 0, w, h);
                        ctx.fill(); // Rempli plein

                        // Anse
                        ctx.beginPath();
                        const arcR = 3.5;
                        if (type === 'lock') ctx.arc(0, -1, arcR, Math.PI, 0);
                        else ctx.arc(2, -1, arcR, Math.PI, 0);
                        ctx.stroke();

                        // Trou de serrure (Inverse de l'icone pour le contraste)
                        ctx.fillStyle = btnColor;
                        ctx.beginPath();
                        ctx.arc(0, 4, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                };

                // --- APPEL SIMPLIFI√â ---

                // Plus besoin de pr√©ciser la couleur de l'ic√¥ne !

                // 1. Swap
                drawIconBtn(-73, style.components.swap, 'swap');

                // 2. Lock
                const lockColor = this.isLocked ? style.components.lockActive : style.components.lockInactive;
                const lockType = this.isLocked ? 'lock' : 'unlock';
                drawIconBtn(-45, lockColor, lockType);

                ctx.restore();
            }
        }      // ADDED: ToolAnimation class for recording movements


        class ToolAnimation {
            constructor(widgetType, startState, endState, id = null) {
                this.id = id || generateId();
                this.widgetType = widgetType;
                this.startState = startState;
                this.endState = endState;
            }
            draw(ctx) { } // Invisible
            isNear() {
                return false;
            }
        }

        class GeometrieApp {
            getSnappedPos(mx, my) {
                const snapDistPoint = 10; // Distance pour coller au point (coin)
                const snapDistLine = 10;  // Distance pour coller √† la ligne (bord)

                // 1. √âQUERRE (SetSquare)
                if (this.activeWidgets.setsquare && this.setSquareWidget) {
                    const w = this.setSquareWidget;
                    const l = w.toLocal(mx, my);

                    // A. Coller √† l'angle droit (Origine 0,0)
                    if (Math.abs(l.x) < snapDistPoint && Math.abs(l.y) < snapDistPoint) {
                        return { ...w.toGlobal(0, 0), snapped: true };
                    }

                    // B. Coller au bord Horizontal (Axe X)
                    // Si on est le long de la r√®gle (entre 0 et width) et proche de 0 en Y
                    if (l.x > 0 && l.x < w.width && Math.abs(l.y) < snapDistLine) {
                        // On force Y √† 0 (on colle au bord), on garde X tel quel
                        return { ...w.toGlobal(l.x, 0), snapped: true };
                    }

                    // C. Coller au bord Vertical (Axe Y)
                    if (l.y > 0 && l.y < w.height && Math.abs(l.x) < snapDistLine) {
                        // On force X √† 0, on garde Y tel quel
                        return { ...w.toGlobal(0, l.y), snapped: true };
                    }

                    // (Optionnel) D. Coller √† l'hypot√©nuse
                    // C'est un peu plus complexe (projection sur la pente), dis-moi si tu le veux !
                }

                // 2. RAPPORTEUR (Protractor)
                if (this.activeWidgets.protractor && this.protractorWidget) {
                    const w = this.protractorWidget;
                    const l = w.toLocal(mx, my);

                    // Coller au centre
                    if (Math.abs(l.x) < snapDistPoint && Math.abs(l.y) < snapDistPoint) {
                        return { ...w.toGlobal(0, 0), snapped: true };
                    }
                }

                // 3. COMPAS (Compass)
                if (this.activeWidgets.compass && this.compassWidget) {
                    const w = this.compassWidget;
                    const l = w.toLocal(mx, my);
                    // Coller √† la pointe s√®che
                    if (Math.abs(l.x) < 5 && Math.abs(l.y) < 5) { // Seuil plus petit pour pr√©cision
                        return { ...w.toGlobal(0, 0), snapped: true };
                    }
                }

                // Si rien n'est trouv√©, on retourne la position normale
                return { x: mx, y: my, snapped: false };
            }
            toggleFullscreen() {
                const elem = document.documentElement; // Tout le document

                if (!document.fullscreenElement) {
                    // --- 1. ENTRER EN PLEIN √âCRAN ---
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen().catch(err => {
                            this.showToast(`Erreur : ${err.message}`);
                        });
                    }
                } else {
                    // --- 2. QUITTER LE PLEIN √âCRAN ---
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }
            cycleStyle() {
                // 1. R√©cup√©rer les cl√©s des styles disponibles
                const styles = Object.keys(ToolStyleArray);

                let currentKey = styles.find(key => ToolStyleArray[key] === ToolStyle) || 'default';
                let currentIndex = styles.indexOf(currentKey);
                let nextIndex = (currentIndex + 1) % styles.length;
                let nextKey = styles[nextIndex];
                ToolStyle = ToolStyleArray[nextKey];
                localStorage.setItem('geoToolStyle', nextKey);
                this.render();
                const nomStyle = ToolStyle.name || "Style Inconnu";
                this.showToast(`üé® Th√®me : ${nomStyle}`)
            }


            showToast(message) {
                const toast = document.getElementById("toast-notification");
                if (!toast) return;
                toast.innerText = message;
                toast.className = "show";
                if (this.toastTimeout) clearTimeout(this.toastTimeout);
                this.toastTimeout = setTimeout(() => {
                    toast.className = toast.className.replace("show", "");
                }, 3000);
            }

            toggleInstructions() {
                const box = document.getElementById('instructionBox');
                if (box.style.display === 'none') {
                    box.style.display = 'flex';
                    this.initInstructionDrag(); // On active le drag
                } else {
                    box.style.display = 'none';
                }
            }

            // Logique de d√©placement (m√™me principe que le clavier virtuel)
            initInstructionDrag() {
                const box = document.getElementById('instructionBox');
                const handle = document.getElementById('instrDragHandle');

                // √âvite d'ajouter 50 √©couteurs si on clique plusieurs fois
                if (box.dataset.draggable === "true") return;
                box.dataset.draggable = "true";

                let isDragging = false;
                let startX, startY, initLeft, initTop;

                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = box.getBoundingClientRect();
                    initLeft = rect.left;
                    initTop = rect.top;
                    e.preventDefault(); // Important
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    box.style.left = (initLeft + dx) + 'px';
                    box.style.top = (initTop + dy) + 'px';
                    box.style.right = 'auto'; // On casse l'ancrage √† droite par d√©faut
                });

                window.addEventListener('mouseup', () => isDragging = false);
            }
            copyToClipboard() {
                // 1. Calcul de la zone utile (Exactement comme exportImage)
                const bounds = this.getSceneBounds();
                if (!bounds) {
                    alert("La feuille est vide !");
                    return;
                }

                // 2. Marge
                const padding = 40;
                const width = bounds.maxX - bounds.minX + (padding * 2);
                const height = bounds.maxY - bounds.minY + (padding * 2);

                // 3. Canvas temporaire
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width * this.dpr;
                tempCanvas.height = height * this.dpr;
                const ctx = tempCanvas.getContext('2d');

                // 4. Dessin
                ctx.scale(this.dpr, this.dpr);

                // Fond BLANC obligatoire (sinon fond noir/transparent al√©atoire selon o√π on colle)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                ctx.translate(-bounds.minX + padding, -bounds.minY + padding);

                // On redessine tout proprement
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'Point': 2, 'TextLabel': 2 };
                const toDraw = this.entities.slice().sort((a, b) => (zIndex[a.constructor.name] || 0) - (zIndex[b.constructor.name] || 0));

                toDraw.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    e.draw(ctx, { isHovered: false, isSelected: false });
                });

                // 5. Envoi au presse-papier
                tempCanvas.toBlob(blob => {
                    try {
                        // Cr√©ation de l'objet presse-papier
                        const item = new ClipboardItem({ 'image/png': blob });

                        navigator.clipboard.write([item]).then(() => {
                            // Petit feedback visuel : Le bouton change bri√®vement
                            const btn = document.getElementById('btnCopy');
                            if (btn) {
                                const originalHTML = btn.innerHTML;
                                // On met une coche verte
                                btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="#27ae60" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                                // On remet l'ic√¥ne normale apr√®s 1.5 seconde
                                setTimeout(() => btn.innerHTML = originalHTML, 1500);
                                this.showToast("‚úÖ Image copi√©e dans le presse-papier !");
                            }
                        });
                    } catch (err) {
                        console.error("Erreur copie : ", err);
                        alert("Erreur lors de la copie (Navigateur non support√© ?)");
                    }
                });

            }

            toggleHelp() {
                const modal = document.getElementById('helpModal');
                // On bascule l'affichage
                if (modal.style.display === 'flex') {
                    modal.style.display = 'none';
                    this.isLocked = false; // On d√©verrouille l'interface derri√®re
                } else {
                    modal.style.display = 'flex';
                    this.isLocked = true; // On emp√™che de dessiner par erreur en cliquant √† travers
                }
            }

            getSafeFilename(extension) {
                let name = this.projectTitle || "figure_geosoft";
                // On remplace les espaces par des underscores et on enl√®ve les caract√®res bizarres
                name = name.trim().replace(/ /g, "_").replace(/[^a-zA-Z0-9_\u00C0-\u00FF-]/g, "");
                if (name === "") name = "sans_titre";
                return `${name}.${extension}`;
            }

            getSceneBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let hasObjects = false;

                // Fonction interne pour √©tendre les limites
                const extend = (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    hasObjects = true;
                };

                this.entities.forEach(e => {
                    if (!e.visible && e instanceof Point) return; // Ignore les points cach√©s

                    if (e instanceof Point || e instanceof TextLabel) {
                        extend(e.x, e.y);
                    }
                    else if (e instanceof Segment || e instanceof Line || e instanceof Ray || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        const c = MathUtils.getLineCoords(e);
                        if (c.p1 && c.p2) {
                            extend(c.p1.x, c.p1.y);
                            extend(c.p2.x, c.p2.y);
                        }
                    }
                    else if (e instanceof Circle || e instanceof CompassCircle) {
                        const p1 = e.p1 || e.center;
                        const r = (e.getRadius) ? e.getRadius() : MathUtils.dist(e.p1.x, e.p1.y, e.p2.x, e.p2.y);
                        if (p1 && r > 0) {
                            extend(p1.x - r, p1.y - r);
                            extend(p1.x + r, p1.y + r);
                        }
                    }
                    else if (e instanceof Arc || e instanceof CompassArc) {
                        // Simplification : on prend la boite englobante du cercle complet pour √™tre s√ªr
                        if (e.center) {
                            extend(e.center.x - e.radius, e.center.y - e.radius);
                            extend(e.center.x + e.radius, e.center.y + e.radius);
                        }
                    }
                    else if (e instanceof Polygon) {
                        e.points.forEach(p => extend(p.x, p.y));
                    }
                });

                if (!hasObjects) return null; // Rien √† dessiner

                return { minX, minY, maxX, maxY };
            }
            /* --- DANS LA CLASSE GeometrieApp --- */

            exportImage(format) {
                // 1. Calculer la zone utile
                const bounds = this.getSceneBounds();

                if (!bounds) {
                    alert("La feuille est vide !");
                    return;
                }

                // 2. Ajouter une marge confortable (padding)
                const padding = 40; // 40px de marge autour
                const width = bounds.maxX - bounds.minX + (padding * 2);
                const height = bounds.maxY - bounds.minY + (padding * 2);

                // 3. Cr√©er un Canvas temporaire (invisible)
                const tempCanvas = document.createElement('canvas');
                // On multiplie par dpr pour la qualit√© HD, comme l'√©cran
                tempCanvas.width = width * this.dpr;
                tempCanvas.height = height * this.dpr;
                const ctx = tempCanvas.getContext('2d');

                // 4. Configurer le contexte (Zoom et Translation)
                // On simule une cam√©ra qui regarde pile sur la zone utile
                ctx.scale(this.dpr, this.dpr);

                // Si JPG, on remplit le fond en BLANC (sinon transparent devient noir)
                if (format === 'jpg') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, width, height);
                }

                // On d√©place l'origine (0,0) pour que le dessin commence apr√®s la marge
                // Astuce : On soustrait le minX pour "ramener" le dessin vers 0
                ctx.translate(-bounds.minX + padding, -bounds.minY + padding);

                // 5. DESSINER !
                // On utilise la m√©thode draw() de chaque objet sur ce NOUVEAU contexte
                // On trie par Z-index pour respecter l'ordre (Polygone dessous, Point dessus)
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'Point': 2, 'TextLabel': 2 };
                const toDraw = this.entities.slice().sort((a, b) => (zIndex[a.constructor.name] || 0) - (zIndex[b.constructor.name] || 0));

                toDraw.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    // On dessine l'objet sur le canvas temporaire
                    // On passe { isHovered: false } pour ne pas avoir les surbrillances
                    e.draw(ctx, { isHovered: false, isSelected: false });
                });

                // 6. T√©l√©charger
                const mimeType = format === 'jpg' ? 'image/jpeg' : 'image/png';
                const dataURL = tempCanvas.toDataURL(mimeType, 0.95); // Qualit√© Max

                const link = document.createElement('a');
                link.download = this.getSafeFilename(format);
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                this.showToast("üñºÔ∏è Image export√©e !");
            }

            initShortcuts() {
                window.addEventListener('keydown', (e) => {
                    // Si on est en train d'√©crire du texte, on ne veut pas que "Suppr" supprime un objet g√©om√©trique !
                    // On v√©rifie si le focus est dans l'input de texte
                    if (document.activeElement === this.editorInput) return;

                    // 1. ECHAP : Annuler l'action en cours ou d√©s√©lectionner
                    if (e.key === 'Escape') {
                        if (this.isDraggingCreation) {
                            // Annuler la cr√©ation en cours (Ligne qui suit la souris)
                            this.creationStartPoint = null;
                            this.isDraggingCreation = false;
                            this.polygonPoints = []; // Reset polygone en cours
                            this.anglePoints = [];   // Reset angle en cours
                            this.render();
                        } else if (this.selectedObject) {
                            // D√©s√©lectionner
                            this.selectedObject = null;
                            document.getElementById('contextMenu').style.display = 'none';
                            this.render();
                        } else {
                            // Revenir √† l'outil par d√©faut (Move)
                            this.setTool('move');
                        }
                    }

                    // 2. SUPPR / BACKSPACE : Supprimer la s√©lection
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.selectedObject) {
                            // On utilise la logique de suppression du menu
                            const list = this.getNetworkToDelete(this.selectedObject);
                            this.entities = this.entities.filter(ent => !list.includes(ent));
                            this.selectedObject = null;
                            this.hoveredEntities = []; // S√©curit√© visuelle
                            document.getElementById('contextMenu').style.display = 'none';

                            this.saveState();
                            this.render();
                        }
                    }

                    // 3. CTRL+Z (Annuler) et CTRL+Y (R√©tablir)
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                        e.preventDefault(); // Emp√™che le navigateur de faire son propre undo
                        this.undo();
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
                        e.preventDefault();
                        this.redo();
                    }

                    // 4. FL√àCHES DIRECTIONNELLES (D√©placement pr√©cis pixel par pixel)
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        if (this.selectedObject && (this.selectedObject instanceof Point || this.selectedObject instanceof TextLabel)) {
                            e.preventDefault();
                            const speed = e.shiftKey ? 10 : 1; // Shift = aller plus vite

                            if (e.key === 'ArrowUp') this.selectedObject.y -= speed;
                            if (e.key === 'ArrowDown') this.selectedObject.y += speed;
                            if (e.key === 'ArrowLeft') this.selectedObject.x -= speed;
                            if (e.key === 'ArrowRight') this.selectedObject.x += speed;

                            // Si c'est un point, mettre √† jour ses parents/enfants
                            if (this.selectedObject.update) this.selectedObject.update();
                            this.updateDependents();

                            this.render();
                            // Note : Pour les fl√®ches, on ne sauvegarde pas l'√©tat √† chaque pixel pour ne pas saturer l'historique
                        }
                    }
                });
            }
            /* --- DANS GeometrieApp --- */

            // Cr√©ation automatique de la sym√©trie d'un objet
            createSymmetry(targetObj, referenceObj, type) {
                const subType = (type === 'central') ? 'symmetry_central' : 'symmetry_axial';

                // CAS 1 : Sym√©trique d'un POINT
                if (targetObj instanceof Point) {
                    // On cr√©e le nouveau point qui d√©pend de (Original + R√©f√©rence)
                    const newLabel = targetObj.label + "'";
                    const newPt = new Point(0, 0, newLabel, [targetObj, referenceObj], null, subType);
                    newPt.pointStyle = targetObj.pointStyle;
                    newPt.color = targetObj.color;
                    newPt.update(); // Calcul initial
                    this.addEntity(newPt);
                }

                // CAS 2 : Sym√©trique d'un SEGMENT (On cr√©e 2 points sym√©triques + 1 segment)
                else if (targetObj instanceof Segment) {
                    this.createSymmetry(targetObj.p1, referenceObj, type);
                    this.createSymmetry(targetObj.p2, referenceObj, type);

                    const p2_prime = this.entities[this.entities.length - 1];
                    const p1_prime = this.entities[this.entities.length - 2];

                    const newSeg = new Segment(p1_prime, p2_prime);
                    newSeg.color = targetObj.color;
                    newSeg.dash = targetObj.dash;
                    this.addEntity(newSeg);
                }

                // CAS 3 : Sym√©trique d'un CERCLE
                else if (targetObj instanceof Circle) {
                    this.createSymmetry(targetObj.center || targetObj.p1, referenceObj, type);
                    const newCenter = this.entities[this.entities.length - 1];

                    if (targetObj.p2) {
                        this.createSymmetry(targetObj.p2, referenceObj, type);
                        const newP2 = this.entities[this.entities.length - 1];
                        const newCircle = new Circle(null, null);
                        newCircle.p1 = newCenter;
                        newCircle.p2 = newP2;
                        newCircle.color = targetObj.color;
                        this.addEntity(newCircle);
                    }
                }

                // CAS 4 : POLYGONE (R√©cursion sur tous les points)
                else if (targetObj instanceof Polygon) {
                    const newPoints = [];
                    targetObj.points.forEach(p => {
                        this.createSymmetry(p, referenceObj, type);
                        newPoints.push(this.entities[this.entities.length - 1]);
                    });
                    const newPoly = new Polygon(newPoints);
                    newPoly.color = targetObj.color;
                    newPoly.fillMode = targetObj.fillMode;
                    this.addEntity(newPoly);
                }

                this.saveState();
                this.render();
            }
            getClosestPointOnEntity(mx, my, entity) {
                // 1. CAS DU SEGMENT
                if (entity instanceof Segment) {
                    const A = entity.p1;
                    const B = entity.p2;
                    const AtocX = mx - A.x;
                    const AtocY = my - A.y;
                    const AtoBX = B.x - A.x;
                    const AtoBY = B.y - A.y;
                    const len2 = AtoBX * AtoBX + AtoBY * AtoBY;
                    let t = (AtocX * AtoBX + AtocY * AtoBY) / len2;

                    t = Math.max(0, Math.min(1, t));

                    return {
                        x: A.x + t * AtoBX,
                        y: A.y + t * AtoBY
                    };
                }
                if (entity instanceof Circle) {
                    const angle = Math.atan2(my - entity.center.y, mx - entity.center.x);
                    const radius = MathUtils.dist(entity.center.x, entity.center.y, entity.p2.x, entity.p2.y);

                    return {
                        x: entity.center.x + radius * Math.cos(angle),
                        y: entity.center.y + radius * Math.sin(angle)
                    };
                }

                if (entity instanceof Arc) {
                    const radius = MathUtils.dist(entity.center.x, entity.center.y, entity.p2.x, entity.p2.y);
                    let angle = Math.atan2(my - entity.center.y, mx - entity.center.x);

                    const projX = entity.center.x + radius * Math.cos(angle);
                    const projY = entity.center.y + radius * Math.sin(angle);

                    const aStart = Math.atan2(entity.p1.y - entity.center.y, entity.p1.x - entity.center.x);
                    const aEnd = Math.atan2(entity.p2.y - entity.center.y, entity.p2.x - entity.center.x);

                    const dProj = MathUtils.dist(mx, my, projX, projY);
                    const dEnd1 = MathUtils.dist(mx, my, entity.p1.x, entity.p1.y);
                    const dEnd2 = MathUtils.dist(mx, my, entity.p2.x, entity.p2.y);

                    let start = aStart;
                    let end = aEnd;
                    let curr = angle;

                    if (entity.isCounterClockwise) {
                        if (end < start) end += 2 * Math.PI;
                        if (curr < start) curr += 2 * Math.PI;
                    } else {
                        if (start < end) start += 2 * Math.PI;
                        if (curr < end) curr += 2 * Math.PI;
                    }

                    const isInside = entity.isCounterClockwise ? (curr >= start && curr <= end) : (curr >= end && curr <= start);

                    if (isInside) {
                        return { x: projX, y: projY };
                    } else {
                        return (dEnd1 < dEnd2) ? { x: entity.p1.x, y: entity.p1.y } : { x: entity.p2.x, y: entity.p2.y };
                    }
                }

                return { x: mx, y: my };
            }

            setGlobalPointStyle(style) {
                this.defaultPointStyle = style;

                ['cross', 'dot', 'pixel'].forEach(s => {
                    const btn = document.getElementById('btnPt' + s.charAt(0).toUpperCase() + s.slice(1));
                    if (btn) {
                        if (s === style) {
                            btn.style.background = "#e3f2fd";
                            btn.style.color = "#1976d2";
                        } else {
                            btn.style.background = "transparent";
                            btn.style.color = "#555";
                        }
                    }
                });
            }

            togglePanMode() {
                const btn = document.getElementById('btnPan');

                if (this.currentTool === 'pan') {
                    this.setTool('move');
                    btn.classList.remove('active');
                } else {
                    this.setTool('pan');
                    btn.classList.add('active');
                }
            }
            // --- AUTO CODAGE (Baguette Magique) ---
            autoCodeSegments() {
                const segments = this.entities.filter(e => e instanceof Segment);
                if (segments.length < 2) return;

                segments.forEach(s => s.coding = null);

                const groups = {};
                segments.forEach(seg => {
                    const len = MathUtils.dist(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                    const key = Math.round(len * 10) / 10;

                    if (!groups[key]) groups[key] = [];
                    groups[key].push(seg);
                });

                const marks = ['mark-1', 'mark-2', 'mark-3', 'mark-o', 'mark-oo', 'mark-x', 'mark-xx'];
                let markIndex = 0;

                for (const key in groups) {
                    const group = groups[key];
                    if (group.length > 1) {
                        const currentMark = marks[markIndex % marks.length];
                        group.forEach(seg => seg.coding = currentMark);
                        markIndex++;
                    }
                }

                this.saveState();
                this.render();
            }

            showModal(message, onConfirm) {
                const modal = document.getElementById('customModal');
                const txt = document.getElementById('modalMessage');
                const btn = document.getElementById('btnModalConfirm');

                txt.innerText = message;
                modal.style.display = 'flex';

                btn.onclick = () => {
                    onConfirm(); // On lance l'action
                    this.closeModal(); // On ferme
                };

                btn.focus();
            }

            closeModal() {
                document.getElementById('customModal').style.display = 'none';
            }

            toggleGlobalLabels() {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                const hasHidden = points.some(p => p.showLabel === false);
                const newState = hasHidden ? true : false;

                points.forEach(p => p.showLabel = newState);

                this.saveState();
                this.render();
            }

            // 2. Changer la taille globale (+2 ou -2)
            offsetGlobalTextSize(delta) {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                points.forEach(p => {
                    let newSize = (p.fontSize || 14) + delta;
                    if (newSize < 8) newSize = 8;
                    if (newSize > 32) newSize = 32;
                    p.fontSize = newSize;
                });

                if (points.length > 0) this.defaultFontSize = points[0].fontSize;

                this.saveState();
                this.render();
            }

            // 3. Uniformiser (Reset standard)
            resetGlobalText() {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                this.showModal("Remettre tous les textes √† la taille standard (14px) et visibles ?", () => {
                    points.forEach(p => {
                        p.fontSize = 14;
                        p.showLabel = true;
                    });
                    this.defaultFontSize = 14;

                    this.saveState();
                    this.render();
                });
            }
            cyclePointName(direction) {
                if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                const currentLabel = this.selectedObject.label;
                const baseChar = currentLabel.replace(/['‚Äô]/g, "");
                const primes = currentLabel.substring(baseChar.length);

                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                let currentIndex = alphabet.indexOf(baseChar);
                if (currentIndex === -1) currentIndex = 0;

                const usedNames = this.entities
                    .filter(e => e instanceof Point && e !== this.selectedObject)
                    .map(e => e.label);

                let newChar = baseChar;
                let loops = 0;

                do {
                    currentIndex += direction;
                    if (currentIndex >= alphabet.length) currentIndex = 0;
                    if (currentIndex < 0) currentIndex = alphabet.length - 1;

                    newChar = alphabet[currentIndex];
                    loops++;
                    if (loops > 26) break;

                } while (usedNames.includes(newChar + primes));

                this.selectedObject.label = newChar + primes;

                const display = document.getElementById('renamerDisplay');
                if (display) display.innerText = this.selectedObject.label;

                this.saveState();
                this.render();
            }

            addPrime() {
                if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                let label = this.selectedObject.label;

                if (label.endsWith("'''")) {
                    label = label.substring(0, label.length - 3);
                } else {
                    label += "'";
                }

                this.selectedObject.label = label;
                document.getElementById('renamerDisplay').innerText = label;
                this.saveState();
                this.render();
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.dpr = window.devicePixelRatio || 1;

                this.canvas.width = Math.round(rect.width * this.dpr);
                this.canvas.height = Math.round(rect.height * this.dpr);

                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                this.render();
            }

            rewindState() {
                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const ent = this.entities[i];

                    if (ent instanceof ToolAnimation && (ent.widgetType === 'pointMove' || ent.widgetType === 'textMove')) {
                        const target = this.entities.find(e => e.id === ent.targetId);

                        if (target) {
                            target.x = ent.startState.x;
                            target.y = ent.startState.y;
                            if (target.update) target.update();
                        }
                    }
                }
                this.updateDependents();
            }


            // --- GESTION GRILLE & AIMANT ---
            toggleMagnet() {
                this.isMagnetActive = !this.isMagnetActive;
                const btn = document.getElementById('btnMagnet');
                if (this.isMagnetActive) {
                    btn.classList.add('active');
                    btn.style.background = '#e67e22';
                } else {
                    btn.classList.remove('active');
                    btn.style.background = '';
                }
            }

            toggleGrid() {
                this.gridMode = (this.gridMode + 1) % 4;
                const labels = ["‚ñ¶ Grille", "‚Åô Points", "‚ñ≥ Iso", "‚ñ° Blanc"];
                document.getElementById('btnGrid').innerText = labels[this.gridMode];
                this.render();
            }

            getSmartCoords(evt) {
                const raw = this.getMousePos(evt);
                if (!this.isMagnetActive || this.gridMode === 3) {
                    this.activeSnapPoint = null;
                    return raw;
                }

                const x = raw.x;
                const y = raw.y;
                let nx = x,
                    ny = y;

                if (this.gridMode === 0 || this.gridMode === 1) {
                    nx = Math.round(x / UNIT) * UNIT;
                    ny = Math.round(y / UNIT) * UNIT;
                }

                else if (this.gridMode === 2) {
                    const isoH = UNIT * Math.sqrt(3) / 2;
                    const row = Math.round(y / isoH);
                    ny = row * isoH;
                    const offset = (row % 2 !== 0) ? (UNIT / 2) : 0;
                    nx = Math.round((x - offset) / UNIT) * UNIT + offset;
                }

                const dist = Math.sqrt((x - nx) ** 2 + (y - ny) ** 2);

                if (dist < 10) {
                    this.activeSnapPoint = {
                        x: nx,
                        y: ny
                    };
                    return {
                        x: nx,
                        y: ny,
                        snapped: true
                    };
                }

                this.activeSnapPoint = null;
                return raw;
            }

            initVirtualKeyboard() {
                this.vkContainer = document.getElementById('virtualKeyboard');
                this.renderKeyboard();

                const handle = document.getElementById('vkHandle');
                let isDraggingVK = false;
                let startX, startY, initLeft, initTop;

                this.vkContainer.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.vk-drag-handle')) {
                        isDraggingVK = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        const rect = this.vkContainer.getBoundingClientRect();
                        initLeft = rect.left;
                        initTop = rect.top;
                        e.preventDefault();
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDraggingVK) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    this.vkContainer.style.left = (initLeft + dx) + 'px';
                    this.vkContainer.style.top = (initTop + dy) + 'px';
                    this.vkContainer.style.transform = 'none';
                });

                window.addEventListener('mouseup', () => { isDraggingVK = false; });
            }

            renderKeyboard() {
                this.vkContainer.innerHTML = '';

                const handle = document.createElement('div');
                handle.className = 'vk-drag-handle';
                handle.id = 'vkHandle';
                this.vkContainer.appendChild(handle);

                const row0 = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"];
                const row1_low = ["a", "z", "e", "r", "t", "y", "u", "i", "o", "p"];
                const row1_up = ["A", "Z", "E", "R", "T", "Y", "U", "I", "O", "P"];
                const row2_low = ["q", "s", "d", "f", "g", "h", "j", "k", "l", "m"];
                const row2_up = ["Q", "S", "D", "F", "G", "H", "J", "K", "L", "M"];
                const row3_low = ["w", "x", "c", "v", "b", "n", ".", ",", "?", "!"];
                const row3_up = ["W", "X", "C", "V", "B", "N", ".", ":", ";", "/"];
                const row4_low = ["√©", "√®", "√†", "√π", "√ß", "'", "-", "(", ")", "="];
                const row4_up = ["√â", "√à", "√Ä", "√ô", "√á", '"', "+", "[", "]", "*"];

                const currentR1 = this.isShift ? row1_up : row1_low;
                const currentR2 = this.isShift ? row2_up : row2_low;
                const currentR3 = this.isShift ? row3_up : row3_low;
                const currentR4 = this.isShift ? row4_up : row4_low;

                this.createRow(row0, 'num');
                this.createRow(currentR1);
                this.createRow(currentR2);

                const div3 = document.createElement('div');
                div3.className = 'vk-row';

                const btnShift = document.createElement('button');
                btnShift.className = 'vk-btn special' + (this.isShift ? ' active-shift' : '');
                btnShift.innerHTML = '‚áß';
                btnShift.onmousedown = (e) => {
                    e.preventDefault();
                    this.toggleShift();
                };
                div3.appendChild(btnShift);

                currentR3.forEach(char => {
                    const btn = document.createElement('button');
                    btn.className = 'vk-btn';
                    btn.innerText = char;
                    btn.onmousedown = (e) => {
                        e.preventDefault();
                        this.typeChar(char);
                    };
                    div3.appendChild(btn);
                });

                const btnBack = document.createElement('button');
                btnBack.className = 'vk-btn special';
                btnBack.innerHTML = '‚å´';
                btnBack.onmousedown = (e) => {
                    e.preventDefault();
                    this.backspace();
                };
                div3.appendChild(btnBack);

                this.vkContainer.appendChild(div3);

                this.createRow(currentR4);

                const divSpace = document.createElement('div');
                divSpace.className = 'vk-row';
                const btnSpace = document.createElement('button');
                btnSpace.className = 'vk-btn space';
                btnSpace.innerText = 'Espace';
                btnSpace.onmousedown = (e) => {
                    e.preventDefault();
                    this.typeChar(' ');
                };
                divSpace.appendChild(btnSpace);
                this.vkContainer.appendChild(divSpace);
            }

            createRow(chars, extraClass = '') {
                const div = document.createElement('div');
                div.className = 'vk-row';
                chars.forEach(char => {
                    const btn = document.createElement('button');
                    btn.className = `vk-btn ${extraClass}`;
                    btn.innerText = char;
                    btn.onmousedown = (e) => {
                        e.preventDefault();
                        this.typeChar(char);
                    };
                    div.appendChild(btn);
                });
                this.vkContainer.appendChild(div);
            }

            toggleShift() {
                this.isShift = !this.isShift;
                this.renderKeyboard();
            }

            typeChar(char) {
                if (this.editorInput) {
                    const start = this.editorInput.selectionStart;
                    const end = this.editorInput.selectionEnd;
                    const text = this.editorInput.value;
                    const before = text.substring(0, start);
                    const after = text.substring(end, text.length);

                    this.editorInput.value = before + char + after;
                    this.editorInput.selectionStart = this.editorInput.selectionEnd = start + 1;
                    this.editorInput.focus();
                }
            }

            backspace() {
                if (this.editorInput) {
                    const start = this.editorInput.selectionStart;
                    const end = this.editorInput.selectionEnd;
                    const text = this.editorInput.value;

                    if (start === end) {
                        if (start > 0) {
                            this.editorInput.value = text.substring(0, start - 1) + text.substring(end);
                            this.editorInput.selectionStart = this.editorInput.selectionEnd = start - 1;
                        }
                    } else {
                        this.editorInput.value = text.substring(0, start) + text.substring(end);
                        this.editorInput.selectionStart = this.editorInput.selectionEnd = start;
                    }
                    this.editorInput.focus();
                }
            }

            applyTextEdit() {
                const val = this.editorInput.value.trim();
                if (this.editingEntity) {
                    if (this.editingEntity instanceof Point) {
                        this.editingEntity.label = val;
                    } else if (this.editingEntity instanceof TextLabel) {
                        if (val === "") {
                            this.entities = this.entities.filter(e => e !== this.editingEntity);
                        } else {
                            this.editingEntity.text = val;
                        }
                    } else if (this.editingEntity.type === 'new' && val !== "") {
                        this.addEntity(new TextLabel(this.editingEntity.x, this.editingEntity.y, val));
                    }
                    this.saveState();
                }
                this.cancelTextEdit();
                this.render();
            }

            cancelTextEdit() {
                this.editorDiv.style.display = 'none';
                this.editingEntity = null;
                this.editorInput.value = "";
                this.canvas.focus();
                document.getElementById('virtualKeyboard').classList.remove('visible');
            }


            constructor(canvasId) {
                this.view = { x: 0, y: 0, zoom: 1 };
                this.projectTitle = "Nom";

                const titleInput = document.getElementById('docTitleInput');
                if (titleInput) {
                    titleInput.oninput = (e) => {
                        this.projectTitle = e.target.value;
                        document.title = "G√©oSoft - " + this.projectTitle;
                    };
                }

                this.widgetZOrder = ['ruler', 'setsquare', 'protractor', 'compass'];
                this.isPanning = false;
                this.lastMouseScreen = { x: 0, y: 0 };
                this.initAnimationState();

                this.isShift = false;
                this.initVirtualKeyboard();
                this.editingEntity = null;
                this.editorDiv = document.getElementById('textEditor');
                this.editorInput = document.getElementById('textInput');

                document.getElementById('btnTextSave').onclick = () => this.applyTextEdit();
                document.getElementById('btnTextCancel').onclick = () => this.cancelTextEdit();
                this.editorInput.onkeydown = (e) => {
                    if (e.key === 'Enter') this.applyTextEdit();
                    if (e.key === 'Escape') this.cancelTextEdit();
                    e.stopPropagation();
                };
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.entities = [];
                this.currentTool = 'move';
                this.draggedPoint = null;
                this.creationStartPoint = null;
                this.isDraggingCreation = false;
                this.referenceObject = null;
                this.showTools = true;
                this.mousePos = { x: 0, y: 0 };
                this.hoveredEntities = [];
                this.ghostIntersection = null;
                this.toDeletePreview = [];
                this.polygonPoints = [];
                this.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                this.anglePoints = [];

                this.draggedPoint = null;
                this.draggedText = null;

                this.replayIndex = null;
                this.isPlaying = false;
                this.playInterval = null;
                this.isToolAnimating = false;
                this.toolAnimStartTime = 0;
                this.lastStepTime = 0;

                this.compassWidget = null;
                this.protractorWidget = null;
                this.setSquareWidget = null;
                this.rulerWidget = null;
                this.activeWidgets = {
                    compass: false,
                    protractor: false,
                    setsquare: false,
                    ruler: false
                };

                this.draggedWidget = null;
                this.draggedWidgetMode = null;
                this.widgetOffset = {
                    x: 0,
                    y: 0
                };
                this.widgetRotationOffset = 0;
                this.dragStartMouse = {
                    x: 0,
                    y: 0
                };
                this.dragStartWidget = {
                    x: 0,
                    y: 0
                };

                this.widgetStartState = null;
                this.draggedWidgetType = null;
                this.historyPast = [];
                this.historyFuture = [];
                this.contextMenu = document.getElementById('contextMenu');
                this.selectedObject = null;
                this.initEventListeners();
                this.initShortcuts();
                this.render();

            }


            getWidgetState(widget) {
                if (!widget) return null;
                return {
                    x: widget.x,
                    y: widget.y,
                    angle: widget.angle,
                    radius: widget.radius || 0
                };
            }

            applyInterpolation(anim, t) {
                const ease = t;

                const s = anim.startState;
                const e = anim.endState;

                const lerp = (a, b, t) => a + (b - a) * t;

                const lerpAngle = (a, b, t) => {
                    let diff = b - a;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    return a + diff * t;
                };

                if (anim.widgetType === 'pointMove' || anim.widgetType === 'textMove') {
                    const targetObj = this.entities.find(ent => ent.id === anim.targetId);
                    if (targetObj) {
                        targetObj.x = lerp(s.x, e.x, ease);
                        targetObj.y = lerp(s.y, e.y, ease);
                        if (targetObj.update) targetObj.update();
                        this.updateDependents();
                    }
                    return;
                }

                if (anim.widgetType.endsWith('Hide')) {
                    const realType = anim.widgetType.replace('Hide', '');
                    this.activeWidgets[realType] = false;
                    const btn = document.getElementById('btn-' + realType);
                    if (btn) btn.classList.remove('widget-active');
                    return;
                }

                this.activeWidgets[anim.widgetType] = true;
                const btn = document.getElementById('btn-' + anim.widgetType);
                if (btn) btn.classList.add('widget-active');

                let w = null;
                if (anim.widgetType === 'ruler') {
                    if (!this.rulerWidget) this.rulerWidget = new RulerWidget(0, 0);
                    w = this.rulerWidget;
                } else if (anim.widgetType === 'compass') {
                    if (!this.compassWidget) this.compassWidget = new CompassWidget(0, 0);
                    w = this.compassWidget;
                } else if (anim.widgetType === 'setsquare') {
                    if (!this.setSquareWidget) this.setSquareWidget = new SetSquareWidget(0, 0);
                    w = this.setSquareWidget;
                } else if (anim.widgetType === 'protractor') {
                    if (!this.protractorWidget) this.protractorWidget = new ProtractorWidget(0, 0);
                    w = this.protractorWidget;
                }

                if (w) {
                    w.x = lerp(s.x, e.x, ease);
                    w.y = lerp(s.y, e.y, ease);

                    if (anim.widgetType === 'compass' && this.ArcTracing) {
                        w.angle = lerp(s.angle, e.angle, ease);
                    }
                    else {
                        w.angle = lerpAngle(s.angle, e.angle, ease);
                    }

                    if (w.radius !== undefined && s.radius !== undefined) {
                        w.radius = lerp(s.radius, e.radius, ease);
                    }
                }
            }
            toggleTools() {
                this.showTools = !this.showTools;
                document.getElementById('btnTools').classList.toggle('active');
                this.render();
            }

            clearAll() {
                this.showModal("Voulez-vous vraiment tout effacer ?", () => {
                    this.entities = [];
                    this.historyPast = [];
                    this.historyFuture = [];
                    this.replayIndex = 0;
                    this.resetInteraction();
                    this.saveState();
                    this.render();
                });
            }

            addEntity(entity) {
                this.entities.push(entity);
                this.replayIndex = this.entities.length;
            }

            saveFile() {
                const content = document.getElementById('instrContent').innerHTML;
                const isVisible = document.getElementById('instructionBox').style.display !== 'none';
                const saveData = {
                    title: this.projectTitle,
                    data: this.serialize(),
                    instructions: {
                        html: content,
                        visible: isVisible
                    }
                };

                const json = JSON.stringify(saveData, null, 2);
                const blob = new Blob([json], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                a.download = this.getSafeFilename('geo');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                this.showToast("üíæ Projet sauvegard√© avec succ√®s !");
            }
            loadFile(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = JSON.parse(e.target.result);

                        if (content.title && content.data) {
                            this.projectTitle = content.title;
                            if (content.instructions) {
                                const box = document.getElementById('instructionBox');
                                const div = document.getElementById('instrContent');

                                div.innerHTML = content.instructions.html;

                                if (content.instructions.visible) {
                                    box.style.display = 'flex';
                                    this.initInstructionDrag();
                                } else {
                                    box.style.display = 'none';
                                }
                            } else {
                                document.getElementById('instrContent').innerHTML = '<h3>Exercice :</h3><p>...</p>';
                                document.getElementById('instructionBox').style.display = 'none';
                            }
                            document.getElementById('docTitleInput').value = content.title;
                            document.title = "G√©oSoft - " + content.title;

                            this.entities = this.deserialize(content.data);
                        }
                        else {
                            this.entities = this.deserialize(e.target.result);
                        }

                        this.historyPast = [];
                        this.saveState();
                        this.render();
                    } catch (err) {
                        console.error(err);
                        alert("Erreur chargement fichier");
                    }
                };
                reader.readAsText(file);
                input.value = '';
            }

            initAnimationState() {
                this.defaultPointStyle = 'cross';
                this.globalStyle = {
                    color: '#000000',
                    width: 2,
                    dash: []
                };
                this.ArcTracing = false;
                this.isPaintMode = false;
                this.defaultFontSize = 14;
                this.gridMode = 0;
                this.isMagnetActive = false;
                this.playbackSpeed = 500;
                this.loopDelay = 1000;
                this.isLooping = false;
                this.isLocked = false;
                this.waitEndTime = 0;
                this.view = { x: 0, y: 0, zoom: 1 };
                this.isPanning = false;
                this.lastMouseScreen = { x: 0, y: 0 };
                this.dpr = window.devicePixelRatio || 1;
            }

            setGlobalColor(val) {
                const colorMap = { 'black': '#202124', 'blue': '#1a73e8', 'red': '#d93025', 'green': '#1e8e3e', 'orange': '#e37400' };
                const hex = colorMap[val] || val;
                this.globalStyle.color = hex;

                document.querySelectorAll('.header-dot').forEach(dot => dot.classList.remove('active'));
                const customDot = document.getElementById('colorPreview');
                customDot.classList.add('active');
                customDot.style.background = hex;

                const picker = document.getElementById('globalColorPicker');
                if (picker) picker.value = hex;
            }

            setGlobalWidth(val) {
                const w = parseInt(val);
                this.globalStyle.width = w;

                const icon = document.getElementById('headerStrokeIcon');
                if (icon) {
                    icon.setAttribute('stroke-width', Math.min(w, 6));
                }
            }

            toggleGlobalDash() {
                const btn = document.getElementById('btnGlobalDash');
                if (this.globalStyle.dash.length === 0) {
                    this.globalStyle.dash = [5, 5];
                    btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="2" y1="12" x2="22" y2="12" stroke-width="2" stroke-dasharray="4,2"/></svg>';
                    btn.classList.add('active');
                } else {
                    this.globalStyle.dash = [];
                    btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="2" y1="12" x2="22" y2="12" stroke-width="2"/></svg>';
                    btn.classList.remove('active');
                }
            }

            resetView() {
                this.view = { x: 0, y: 0, zoom: 1 };
                this.render();
            }

            setSpeed(val) {
                const min = 50;
                const max = 1500;
                this.playbackSpeed = max - ((val - 1) * (max - min) / 9);
            }

            setLoopDelay(val) {
                this.loopDelay = parseInt(val);
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                const btn = document.getElementById('btnLoop');
                if (this.isLooping) {
                    btn.classList.add('active');
                    btn.title = "Boucle (ON)";
                } else {
                    btn.classList.remove('active');
                    btn.title = "Boucle (OFF)";
                }
            }

            playFromStart() {
                this.saveState();
                if (this.isPlaying) return;

                this.activeWidgets = { compass: false, protractor: false, setsquare: false, ruler: false };
                ['compass', 'protractor', 'setsquare', 'ruler'].forEach(t => {
                    const btn = document.getElementById('btn-' + t);
                    if (btn) btn.classList.remove('widget-active');
                });
                if (this.historyPast.length > 0) {
                    this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                }

                this.rewindState();

                this.replayIndex = 0;
                this.lockInterface(true);
                this.isPlaying = true;
                this.isToolAnimating = false;
                this.lastStepTime = performance.now();

                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚è∏";
                btn.onclick = () => this.pauseAnimation();

                this.render();
                this.animateLoop();
            }

            pauseAnimation() {
                this.isPlaying = false;
                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚ñ∂";
                btn.onclick = () => this.resumeAnimation();
            }

            resumeAnimation() {
                this.isPlaying = true;
                this.lastStepTime = performance.now();
                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚è∏";
                btn.onclick = () => this.pauseAnimation();
                this.animateLoop();
            }

            stopAnimation() {
                this.isPlaying = false;
                this.isToolAnimating = false;
                this.waitEndTime = 0;

                this.replayIndex = this.entities.length;

                if (this.historyPast.length > 0) {
                    this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                }

                this.lockInterface(false);
                this.render();

                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚ñ∂";
                btn.onclick = () => this.playFromStart();
            }

            lockInterface(locked) {
                this.isLocked = locked;
                if (locked) {
                    document.body.classList.add('interface-locked');
                    document.getElementById('contextMenu').style.display = 'none';
                    document.getElementById('textEditor').style.display = 'none';
                } else {
                    document.body.classList.remove('interface-locked');
                }
            }

            animateLoop() {
                if (!this.isPlaying) return;

                const now = performance.now();
                const max = this.entities.length;

                if (this.waitEndTime > 0) {
                    if (now > this.waitEndTime) {
                        this.waitEndTime = 0;
                        this.replayIndex = 0;

                        if (this.historyPast.length > 0) {
                            this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                        }
                        this.rewindState();

                        this.lastStepTime = now;
                    }
                    this.render();
                    requestAnimationFrame(() => this.animateLoop());
                    return;
                }

                if (this.isToolAnimating) {
                    const elapsed = now - this.toolAnimStartTime;
                    const anim = this.entities[this.replayIndex];
                    let duration = this.playbackSpeed;

                    if (anim && anim.startState && anim.endState &&
                        typeof anim.startState.angle === 'number' &&
                        typeof anim.endState.angle === 'number') {

                        const startA = anim.startState.angle;
                        const endA = anim.endState.angle;
                        const delta = Math.abs(endA - startA);

                        if (delta > 0.01) {
                            duration = delta * (this.playbackSpeed * 0.5);
                        }
                    }

                    if (duration < 150) duration = 150;

                    let t = elapsed / duration;
                    if (t > 1) t = 1;

                    if (anim) this.applyInterpolation(anim, t);

                    if (t === 1) {
                        this.isToolAnimating = false;
                        this.replayIndex++;

                        if (this.replayIndex < this.entities.length) {
                            const nextObj = this.entities[this.replayIndex];
                            if (nextObj instanceof CompassArc ||
                                nextObj instanceof Segment ||
                                nextObj instanceof Circle ||
                                nextObj instanceof Line ||
                                nextObj instanceof Ray ||
                                nextObj instanceof Angle ||
                                nextObj instanceof Point) {
                                this.replayIndex++;
                            }
                        }

                        this.lastStepTime = now;
                    }

                    this.render();
                    requestAnimationFrame(() => this.animateLoop());
                    return;
                }

                if (now - this.lastStepTime > this.playbackSpeed) {

                    if (this.replayIndex >= max) {
                        if (this.isLooping) {
                            this.waitEndTime = now + this.loopDelay;
                        } else {
                            this.stopAnimation();
                            return;
                        }
                    } else {
                        const nextEnt = this.entities[this.replayIndex];

                        if (nextEnt instanceof ToolAnimation) {
                            this.isToolAnimating = true;
                            this.toolAnimStartTime = now;
                        } else {
                            this.replayIndex++;
                            this.lastStepTime = now;
                        }
                    }
                }
                this.render();
                requestAnimationFrame(() => this.animateLoop());
            }
            drawRuler(ctx, start, end) {
                if (this.activeWidgets.ruler) return;
                const dist = MathUtils.dist(start.x, start.y, end.x, end.y);
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const length = 600;
                ctx.save();
                ctx.translate(start.x, start.y);
                ctx.rotate(angle);
                ctx.fillStyle = "rgba(240, 248, 255, 0.7)";
                ctx.fillRect(0, 0, 600 + 20, 60);
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, 600 + 20, 60);
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.font = "10px Arial";
                for (let i = 0; i <= 600; i += 5) {
                    const h = (i % 50 === 0) ? 25 : ((i % 50 === 25) ? 20 : 15);
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, h);
                    ctx.stroke();
                    if (i % 50 === 0 && i != 0) ctx.fillText(i / 50, i, 40);
                }
                ctx.restore();
            }
            drawPerpendicularHint(ctx, refObj, mouse) {
                const P = MathUtils.getProjectedPoint(mouse.x, mouse.y, refObj);
                const c = MathUtils.getLineCoords(refObj);
                const angle = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);
                ctx.save();
                ctx.translate(P.x, P.y);
                ctx.rotate(angle);
                const dx = mouse.x - P.x;
                const dy = mouse.y - P.y;
                const localY = -dx * Math.sin(angle) + dy * Math.cos(angle);
                ctx.scale(1, localY > 0 ? -1 : 1);
                ctx.fillStyle = "rgba(200, 235, 255, 0.8)";
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -300);
                ctx.lineTo(-180, 0);
                ctx.lineTo(0, 0);
                ctx.fill();
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.beginPath();
                ctx.moveTo(-30, -30);
                ctx.lineTo(-30, -120);
                ctx.lineTo(-90, -30);
                ctx.fill();
                ctx.restore();
            }

            styleObject(action) {
                this.saveState();
                if (!this.selectedObject) return;
                if (action.startsWith('fill-')) {
                    if (this.selectedObject instanceof Polygon) {
                        this.selectedObject.fillMode = action.replace('fill-', '');
                    }
                }

                const colorMap = {
                    'black': '#333',
                    'blue': '#2980b9',
                    'red': '#c0392b',
                    'green': '#27ae60',
                    'orange': '#e67e22',
                    'purple': '#8e44ad',
                    'gray': '#7f8c8d',
                    'pink': '#e91e63',
                    'yellow': '#f1c40f',
                    'cyan': '#1abc9c'
                };
                if (colorMap[action]) {
                    if (this.selectedObject instanceof Polygon) this.selectedObject.color = colorMap[action].replace(')', ',0.2)'); // Astuce rgba rapide
                    else this.selectedObject.color = colorMap[action];
                }

                else if (action === 'solid') this.selectedObject.dash = [];
                else if (action === 'dashed') this.selectedObject.dash = [5, 5];

                else if (this.selectedObject instanceof Segment) {
                    if (action === 'toggleLength-off') {
                        this.selectedObject.showLength = false;
                    } else if (action === 'measureUp') {
                        this.selectedObject.showLength = true;
                        this.selectedObject.measureOffset = -15;
                    } else if (action === 'measureDown') {
                        this.selectedObject.showLength = true;
                        this.selectedObject.measureOffset = 20;
                    }
                    else if (action.startsWith('mark-')) {
                        this.selectedObject.coding = action;
                    }
                }

                else if (this.selectedObject instanceof Angle) {
                    if (action === 'flipAngle') this.selectedObject.isCounterClockwise = !this.selectedObject.isCounterClockwise;
                    else if (action === 'toggleAngleVal') this.selectedObject.showValue = !this.selectedObject.showValue;
                    else if (action === 'toggleAngleFill') this.selectedObject.isFilled = !this.selectedObject.isFilled;
                } else if (action === 'toggleLabel') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.showLabel = !this.selectedObject.showLabel;
                    }
                } else if (action === 'textSize-inc') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.fontSize = (this.selectedObject.fontSize || 14) + 2;
                        if (this.selectedObject.fontSize > 32) this.selectedObject.fontSize = 32;
                        this.defaultFontSize = this.selectedObject.fontSize;
                    }
                } else if (action === 'textSize-dec') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.fontSize = (this.selectedObject.fontSize || 14) - 2;
                        if (this.selectedObject.fontSize < 8) this.selectedObject.fontSize = 8;
                        this.defaultFontSize = this.selectedObject.fontSize;
                    }
                }
                else if (action.startsWith('pointStyle-')) {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.pointStyle = action.split('-')[1];
                    }
                }

                this.updateContextMenuUI();
                this.render();
            }

            updateContextMenuUI() {
                if (!this.selectedObject) return;

                document.querySelectorAll('.icon-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.switch-btn').forEach(b => b.classList.remove('active'));

                if (this.selectedObject instanceof Segment) {
                    if (!this.selectedObject.showLength) {
                        document.getElementById('btnMesNone').classList.add('active');
                    } else if (this.selectedObject.measureOffset < 0) {
                        document.getElementById('btnMesUp').classList.add('active');
                    } else {
                        document.getElementById('btnMesDown').classList.add('active');
                    }
                }

                const rowFill = document.getElementById('rowFill');
                const sepFill = document.getElementById('sepFill');


                if (this.selectedObject instanceof Polygon) {
                    rowFill.style.display = 'flex';
                    sepFill.style.display = 'block';

                    const mode = this.selectedObject.fillMode || 'solid';
                    const btn = rowFill.querySelector(`.icon-btn[onclick="app.styleObject('fill-${mode}')"]`);
                    if (btn) btn.classList.add('active');

                    if (document.getElementById('rowAngle')) document.getElementById('rowAngle').style.display = 'none';
                    if (document.getElementById('rowMeasure')) document.getElementById('rowMeasure').style.display = 'none';
                    if (document.getElementById('rowCoding')) document.getElementById('rowCoding').style.display = 'none';

                }
                else {
                    rowFill.style.display = 'none';
                    sepFill.style.display = 'none';
                }

                if (this.selectedObject instanceof Angle) {
                    if (this.selectedObject.showValue) document.getElementById('btnToggleAngleVal').classList.add('active');
                    if (this.selectedObject.isFilled) document.getElementById('btnToggleAngleFill').classList.add('active');
                }
            }
            previewLineWidth(val) {
                if (this.selectedObject) {
                    this.selectedObject.lineWidth = parseInt(val);
                    this.render();
                }
            }
            setLineWidth(val) {
                if (this.selectedObject) {
                    this.selectedObject.lineWidth = parseInt(val);
                    this.saveState();
                }
            }
            deleteFromMenu() {
                this.saveState();
                if (this.selectedObject) {
                    const list = this.getNetworkToDelete(this.selectedObject);
                    this.entities = this.entities.filter(e => !list.includes(e));
                }
                this.contextMenu.style.display = 'none';
                this.render();
            }


            serialize() {
                const state = this.entities.map(e => {
                    if (e instanceof ToolAnimation) {
                        return {
                            type: 'ToolAnimation',
                            id: e.id,
                            widgetType: e.widgetType,
                            startState: e.startState,
                            endState: e.endState,
                            targetId: e.targetId
                        };
                    }
                    const data = {
                        type: e.constructor.name,
                        id: e.id,
                        color: e.color,
                        dash: e.dash,
                        lineWidth: e.lineWidth,
                        showLength: e.showLength,
                        measureOffset: e.measureOffset
                    };
                    if (e instanceof Point) {
                        data.x = e.x;
                        data.y = e.y;
                        data.subType = e.subType;
                        data.pointStyle = e.pointStyle;
                        data.color = e.color;
                        data.label = e.label;
                        data.showLabel = e.showLabel;
                        data.labelAngle = e.labelAngle;
                        data.fontSize = e.fontSize;
                        data.showLabel = e.showLabel;
                        data.visible = e.visible;
                        data.parentIds = e.parents.map(p => {
                            if (Array.isArray(p)) return [p[0].id, p[1].id];
                            return p.id;
                        });
                    } else if (e instanceof Segment) {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                        if (e.coding) data.coding = e.coding;
                    } else if (e instanceof Angle) {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                        data.p3Id = e.p3.id;
                        data.isCCW = e.isCounterClockwise;
                        data.showVal = e.showValue;
                        data.isFilled = e.isFilled;
                    } else if (e instanceof Polygon) {
                        data.fillMode = e.fillMode;
                        data.pointIds = e.points.map(p => p.id);
                    } else if (e instanceof CompassArc) {
                        if (e.center instanceof Point) {
                            data.centerId = e.center.id;
                        } else {
                            data.cx = e.center.x;
                            data.cy = e.center.y;
                        }
                        data.radius = e.radius;
                        data.startA = e.startAngle;
                        data.endA = e.endAngle;
                        data.counterClockwise = e.counterClockwise
                    } else if (e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        data.p1Id = e.p1.id;
                        data.refLineId = e.refLine.id;
                    } else if (e instanceof Arc) {
                        data.centerId = e.center.id;
                        data.radius = e.radius;
                        data.startA = e.startAngle;
                        data.endA = e.endAngle;
                    } else if (e instanceof TextLabel) {
                        data.x = e.x;
                        data.y = e.y;
                        data.text = e.text;
                        data.fontSize = e.fontSize;
                        data.fontFamily = e.fontFamily;
                    } else {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                    }
                    return data;
                });
                return JSON.stringify(state);
            }

            deserialize(jsonString) {
                const state = JSON.parse(jsonString);
                const idMap = new Map();
                const newEntities = [];
                state.forEach(data => {
                    let obj;
                    if (data.type === 'ToolAnimation') {
                        obj = new ToolAnimation(data.widgetType, data.startState, data.endState, data.id);
                        obj.targetId = data.targetId;
                    } else if (data.type === 'Point') {
                        obj = new Point(data.x, data.y, data.label, [], data.id, data.subType);
                        if (data.pointStyle !== undefined) obj.pointStyle = data.pointStyle;
                        if (data.showLabel !== undefined) obj.showLabel = data.showLabel;
                        if (data.labelAngle !== undefined) obj.labelAngle = data.labelAngle;
                        if (data.fontSize !== undefined) obj.fontSize = data.fontSize;
                        if (data.visible !== undefined) obj.visible = data.visible;
                        if (data.showLabel !== undefined) obj.showLabel = data.showLabel;
                    } else if (data.type === 'Segment') obj = new Segment(null, null, data.id);
                    else if (data.type === 'Ray') obj = new Ray(null, null, data.id);
                    else if (data.type === 'Line') obj = new Line(null, null, data.id);
                    else if (data.type === 'Circle') obj = new Circle(null, null, data.id);
                    else if (data.type === 'CompassArc') obj = new CompassArc(null, data.radius, data.startA, data.endA, data.counterClockwise, data.id);
                    else if (data.type === 'Angle') obj = new Angle(null, null, null, data.id);
                    else if (data.type === 'ParallelLine') obj = new ParallelLine(null, null, data.id);
                    else if (data.type === 'PerpendicularLine') obj = new PerpendicularLine(null, null, data.id);
                    else if (data.type === 'Polygon') obj = new Polygon([], data.id);
                    else if (data.type === 'Arc') obj = new Arc(null, data.radius, data.startA, data.endA, data.id);
                    else if (data.type === 'TextLabel') {
                        obj = new TextLabel(data.x, data.y, data.text, data.id);
                        if (data.fontSize) obj.fontSize = data.fontSize;
                        if (data.fontFamily) obj.fontFamily = data.fontFamily;
                    }
                    else if (data.type === 'Polygon') {
                        obj = new Polygon([], data.id);
                        obj.points = data.pointIds.map(pid => idMap.get(pid)).filter(p => p);
                        if (data.fillMode) obj.fillMode = data.fillMode;
                    }
                    if (obj) {
                        if (obj instanceof GeometryObject) {
                            obj.color = data.color;
                            obj.dash = data.dash || [];
                            obj.lineWidth = data.lineWidth || 2;
                            if (obj instanceof Segment) {
                                obj.showLength = data.showLength || false;
                                obj.measureOffset = data.measureOffset || -15;
                                obj.coding = data.coding || null;
                            }
                            if (obj instanceof Angle) {
                                obj.isCounterClockwise = data.isCCW;
                                obj.showValue = (data.showVal !== undefined) ? data.showVal : true;
                                obj.isFilled = data.isFilled || false;
                            }
                        }
                        idMap.set(data.id, obj);
                        newEntities.push(obj);
                    }
                });
                state.forEach((data, index) => {
                    const obj = newEntities[index];
                    if (data.type === 'Point') {
                        obj.parents = data.parentIds.map(pid => {
                            if (Array.isArray(pid)) return [idMap.get(pid[0]), idMap.get(pid[1])];
                            return idMap.get(pid);
                        }).filter(p => p);
                        obj.update();
                    } else if (data.type === 'Angle') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.p2 = idMap.get(data.p2Id);
                        obj.p3 = idMap.get(data.p3Id);
                    } else if (data.type === 'CompassArc') {
                        if (data.centerId) obj.center = idMap.get(data.centerId);
                        else obj.center = {
                            x: data.cx,
                            y: data.cy
                        };
                    } else if (data.type === 'Arc') {
                        obj.center = idMap.get(data.centerId);
                    } else if (data.type === 'Polygon') {
                        obj.points = data.pointIds.map(pid => idMap.get(pid)).filter(p => p);
                    } else if (data.type === 'ParallelLine' || data.type === 'PerpendicularLine') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.refLine = idMap.get(data.refLineId);
                    } else if (data.type !== 'ToolAnimation') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.p2 = idMap.get(data.p2Id);
                    }
                });
                return newEntities;
            }
            saveState() {
                // 1. On g√©n√®re la cha√Æne de sauvegarde une seule fois
                const currentState = this.serialize();

                if (this.historyPast.length > 0) {
                    const lastState = this.historyPast[this.historyPast.length - 1];
                    if (lastState === currentState) {
                        this.replayIndex = this.entities.length;
                        return;
                    }
                }

                // 3. Gestion de la limite de l'historique (50 √©tapes)
                if (this.historyPast.length > 50) this.historyPast.shift();

                // 4. Ajout du nouvel √©tat
                this.historyPast.push(currentState);

                // 5. On vide le futur (car on vient de cr√©er une nouvelle branche temporelle)
                this.historyFuture = [];

                // 6. Mise √† jour variables et UI
                this.replayIndex = this.entities.length;
                this.updateButtons();
            }

            undo() {
                if (this.historyPast.length <= 1) return;
                this.historyFuture.push(this.serialize());
                this.historyPast.pop();
                this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                this.resetInteraction();
                this.replayIndex = this.entities.length;
                this.render();
                this.updateButtons();
            }

            redo() {
                if (this.historyFuture.length === 0) return;
                const next = this.historyFuture.pop();
                this.historyPast.push(next);
                this.entities = this.deserialize(next);
                this.replayIndex = this.entities.length;
                this.render();
                this.updateButtons();
            }
            updateButtons() {
                document.getElementById('btnUndo').disabled = (this.historyPast.length <= 1);
                document.getElementById('btnRedo').disabled = (this.historyFuture.length === 0);
            }
            resetInteraction() {
                this.hoveredEntities = [];
                this.toDeletePreview = [];
                this.creationStartPoint = null;
                this.isDraggingCreation = false;
                this.referenceObject = null;
                this.polygonPoints = [];
                this.anglePoints = [];
                this.draggedWidgetMode = null;
            }

            toggleWidget(type) {
                const wasActive = this.activeWidgets[type];
                this.activeWidgets[type] = !wasActive;
                const btn = document.getElementById(`btn-${type}`);

                if (this.activeWidgets[type]) {
                    if (btn) btn.classList.add('widget-active');

                    const container = this.canvas.parentElement;
                    const visibleWidth = container.clientWidth;
                    const visibleHeight = container.clientHeight;
                    const screenCenterX = visibleWidth / 2;
                    const screenCenterY = visibleHeight / 2;
                    const viewX = this.view ? this.view.x : 0;
                    const viewY = this.view ? this.view.y : 0;
                    const viewZ = this.view ? this.view.zoom : 1;
                    const worldX = (screenCenterX - viewX) / viewZ;
                    const worldY = (screenCenterY - viewY) / viewZ;

                    if (type === 'compass') {
                        if (!this.compassWidget) this.compassWidget = new CompassWidget(worldX, worldY);
                        else { this.compassWidget.x = worldX; this.compassWidget.y = worldY; }
                    }
                    else if (type === 'protractor') {
                        if (!this.protractorWidget) this.protractorWidget = new ProtractorWidget(worldX, worldY);
                        else { this.protractorWidget.x = worldX; this.protractorWidget.y = worldY; }
                    }
                    else if (type === 'ruler') {
                        const rx = worldX - 300;
                        const ry = worldY - 30;
                        if (!this.rulerWidget) this.rulerWidget = new RulerWidget(rx, ry);
                        else { this.rulerWidget.x = rx; this.rulerWidget.y = ry; }
                    }
                    else if (type === 'setsquare') {
                        const sx = worldX - 140;
                        const sy = worldY - 100;
                        if (!this.setSquareWidget) this.setSquareWidget = new SetSquareWidget(sx, sy);
                        else { this.setSquareWidget.x = sx; this.setSquareWidget.y = sy; }
                    }

                } else {
                    if (btn) btn.classList.remove('widget-active');
                    const anim = new ToolAnimation(type + 'Hide', {}, {});
                    this.addEntity(anim);
                    this.saveState();
                }
                this.render();
            }

            setTool(toolName) {
                if (this.isPaintMode && toolName !== 'move' && toolName !== 'pan') {
                    this.isPaintMode = false;
                    const btnPaint = document.getElementById('btnPaint');
                    if (btnPaint) btnPaint.classList.remove('active');
                    this.canvas.style.cursor = 'default';
                }

                this.currentTool = toolName;
                this.resetInteraction();

                const btnPan = document.getElementById('btnPan');
                if (btnPan) {
                    if (toolName === 'pan') btnPan.classList.add('active');
                    else btnPan.classList.remove('active');
                }

                document.querySelectorAll('.tool-btn:not([id^="btn-"])').forEach(btn => btn.classList.remove('active'));

                if (toolName !== 'pan') {
                    const btn = document.querySelector(`.tool-btn[onclick="app.setTool('${toolName}')"]`);
                    if (btn) btn.classList.add('active');
                }

                this.render();
            }

            togglePaintMode() {
                this.isPaintMode = !this.isPaintMode;
                const btn = document.getElementById('btnPaint');

                if (this.isPaintMode) {
                    btn.classList.add('active');

                    if (this.currentTool === 'pan') {
                        this.isPanning = false;
                        const btnPan = document.getElementById('btnPan');
                        if (btnPan) btnPan.classList.remove('active');
                    }

                    this.currentTool = 'move';
                    this.resetInteraction();

                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    const btnMove = document.querySelector(`.tool-btn[onclick="app.setTool('move')"]`);
                    if (btnMove) btnMove.classList.add('active');

                    this.canvas.style.cursor = 'crosshair';
                } else {
                    btn.classList.remove('active');
                    this.canvas.style.cursor = 'default';
                }
            }

            getMousePos(evt) {
                const rect = this.canvas.getBoundingClientRect();

                // 1. Position brute sur l'√©cran (Pixels)
                const cssX = evt.clientX - rect.left;
                const cssY = evt.clientY - rect.top;

                // 2. Conversion vers le Monde G√©om√©trique (Cam√©ra)
                return {
                    x: (cssX - this.view.x) / this.view.zoom,
                    y: (cssY - this.view.y) / this.view.zoom,
                    screenX: cssX,
                    screenY: cssY
                };
            }

            drawGrid() {
                const width = this.canvas.width / this.dpr / this.view.zoom;
                const height = this.canvas.height / this.dpr / this.view.zoom;

                const left = -this.view.x / this.view.zoom;
                const top = -this.view.y / this.view.zoom;

                if (this.gridMode === 3) {
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(left, top, width, height);
                    return;
                }
                const pad = 2;

                const startX = Math.floor((-this.view.x) / this.view.zoom / UNIT) * UNIT - UNIT * pad;
                const startY = Math.floor((-this.view.y) / this.view.zoom / UNIT) * UNIT - UNIT * pad;

                const endX = Math.ceil((this.canvas.width / this.dpr - this.view.x) / this.view.zoom / UNIT) * UNIT + UNIT * pad;
                const endY = Math.ceil((this.canvas.height / this.dpr - this.view.y) / this.view.zoom / UNIT) * UNIT + UNIT * pad;

                this.ctx.beginPath();

                this.ctx.lineWidth = 1 / this.view.zoom;

                // --- MODE 0 : CARR√âS ---
                if (this.gridMode === 0) {
                    this.ctx.strokeStyle = "#e0e0e0";
                    for (let x = startX; x <= endX; x += UNIT) { this.ctx.moveTo(x, startY); this.ctx.lineTo(x, endY); }
                    for (let y = startY; y <= endY; y += UNIT) { this.ctx.moveTo(startX, y); this.ctx.lineTo(endX, y); }
                    this.ctx.stroke();
                }

                // --- MODE 1 : POINTS ---
                else if (this.gridMode === 1) {
                    this.ctx.fillStyle = "#bdc3c7";
                    for (let x = startX; x <= endX; x += UNIT) {
                        for (let y = startY; y <= endY; y += UNIT) {
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 2 / this.view.zoom, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }

                // --- MODE 2 : ISOM√âTRIQUE ---
                else if (this.gridMode === 2) {
                    this.ctx.strokeStyle = "#dcdcdc";

                    const isoH = UNIT * Math.sqrt(3) / 2;

                    const rowStart = Math.floor(startY / isoH) - 1;
                    const rowEnd = Math.ceil(endY / isoH) + 1;
                    const colStart = Math.floor(startX / UNIT) - 2;
                    const colEnd = Math.ceil(endX / UNIT) + 2;

                    for (let r = rowStart; r < rowEnd; r++) {
                        const y = r * isoH;
                        const offset = (Math.abs(r) % 2 === 1) ? (UNIT / 2) : 0;

                        // 1. Ligne Horizontale
                        this.ctx.moveTo(startX, y);
                        this.ctx.lineTo(endX, y);

                        // 2. Diagonales
                        for (let c = colStart; c < colEnd; c++) {
                            const x = c * UNIT + offset;
                            // Diagonale Bas-Droite
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + UNIT / 2, y + isoH);
                            // Diagonale Bas-Gauche
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x - UNIT / 2, y + isoH);
                        }
                    }
                    this.ctx.stroke();
                }
            }

            getNextLabel() {
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const existingLabels = this.entities
                    .filter(e => e instanceof Point && e.label)
                    .map(e => e.label);

                for (let char of alphabet) {
                    if (!existingLabels.includes(char)) return char;
                }

                for (let char of alphabet) {
                    if (!existingLabels.includes(char + "'")) return char + "'";
                }

                for (let char of alphabet) {
                    if (!existingLabels.includes(char + "''")) return char + "''";
                }

                return "";
            }

            findIntersectionAtMouse(x, y) {
                const geom = this.entities.filter(e => e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine || e instanceof Circle || e instanceof CompassArc || e instanceof Arc); // ALL
                for (let i = 0; i < geom.length; i++) {
                    for (let j = i + 1; j < geom.length; j++) {
                        const pts = MathUtils.getIntersections(geom[i], geom[j]);
                        for (let pt of pts) {
                            if (Math.sqrt((pt.x - x) ** 2 + (pt.y - y) ** 2) < 10) return {
                                x: pt.x,
                                y: pt.y,
                                parents: [geom[i], geom[j]]
                            };
                        }
                    }
                }
                return null;
            }
            updateDependents() {
                this.entities.forEach(entity => {
                    if (entity instanceof Point && entity.parents.length > 0) entity.update();
                });
            }
            getNetworkToDelete(target) {
                let toDelete = [target];
                let changed = true;
                while (changed) {
                    changed = false;
                    this.entities.forEach(e => {
                        if (toDelete.includes(e)) return;
                        let isAttached = false;
                        if (e instanceof ParallelLine || e instanceof PerpendicularLine) {
                            isAttached = (toDelete.includes(e.p1) || toDelete.includes(e.refLine));
                        } else if (e instanceof CompassArc) {
                            isAttached = toDelete.includes(e.center);
                        } else if (e instanceof Angle) {
                            isAttached = toDelete.includes(e.p1) || toDelete.includes(e.p2) || toDelete.includes(e.p3);
                        } else if (e instanceof Arc) {
                            isAttached = toDelete.includes(e.center);
                        } else if (e instanceof GeometryObject) {
                            isAttached = (toDelete.includes(e.p1) || toDelete.includes(e.p2));
                        } else if (e instanceof Polygon) {
                            isAttached = e.points.includes(target);
                        }
                        const isChildIntersection = (e instanceof Point && e.parents.some(p => toDelete.includes(p)));
                        if (isAttached || isChildIntersection) {
                            toDelete.push(e);
                            changed = true;
                        }
                    });
                }
                if (target instanceof Point) {
                    this.entities.forEach(e => {
                        if (e instanceof Polygon && e.points.includes(target)) {
                            const idx = toDelete.indexOf(e);
                            if (idx > -1) toDelete.splice(idx, 1);
                        }
                    });
                }
                return toDelete;
            }
            createPointAt(x, y) {
                const existing = this.hoveredEntities.filter(e => e instanceof Point).pop();
                if (existing) return existing;

                const label = this.getNextLabel();
                let newPoint;

                if (this.ghostIntersection) {
                    newPoint = new Point(this.ghostIntersection.x, this.ghostIntersection.y, label, this.ghostIntersection.parents);
                }
                else {
                    const poly = this.entities.filter(e => e instanceof Polygon).find(p => p.isNear(x, y) === false && p.getClosestSegment(x, y).dist < 8);

                    const support = this.hoveredEntities.slice().reverse().find(e =>
                        e instanceof LinearObject ||
                        e instanceof ParallelLine ||
                        e instanceof PerpendicularLine ||
                        e instanceof Circle ||
                        e instanceof Arc ||
                        e instanceof CompassArc ||
                        e instanceof CompassCircle
                    );

                    if (poly) {
                        const edge = poly.getClosestSegment(x, y);
                        const segObj = { constructor: { name: 'Segment' }, p1: edge.seg[0], p2: edge.seg[1] };
                        const proj = MathUtils.getProjectedPoint(x, y, segObj);
                        newPoint = new Point(proj.x, proj.y, label, [edge.seg]);
                    }
                    else if (support) {
                        const proj = MathUtils.getProjectedPoint(x, y, support);

                        if (proj) {
                            newPoint = new Point(proj.x, proj.y, label, [support]);
                        } else {
                            newPoint = new Point(x, y, label);
                        }
                    }
                    else {
                        newPoint = new Point(x, y, label);
                    }
                }

                if (newPoint) {
                    newPoint.fontSize = this.defaultFontSize;
                    newPoint.showLabel = true;
                    newPoint.color = this.globalStyle.color;
                    newPoint.pointStyle = this.defaultPointStyle;
                    this.addEntity(newPoint);
                }

                return newPoint;
            }

            startTextEditor(x, y, entity = null) {
                this.editingEntity = entity;

                const rect = this.canvas.getBoundingClientRect();
                const editorX = x + rect.left;
                const editorY = y + rect.top;

                this.editorDiv.style.left = editorX + 'px';
                this.editorDiv.style.top = editorY + 'px';
                this.editorDiv.style.display = 'flex';

                const fontInput = document.getElementById('fontFamilyInput');
                const sizeInput = document.getElementById('fontSizeInput');
                const textInput = document.getElementById('textInput');

                if (entity instanceof TextLabel) {
                    textInput.value = entity.text;
                    fontInput.value = entity.fontFamily || "'Segoe UI', sans-serif";
                    sizeInput.value = entity.fontSize || 16;
                } else {
                    textInput.value = "";
                    fontInput.value = "'Segoe UI', sans-serif";
                    sizeInput.value = 16;
                    this.editingEntity = { x: x, y: y, type: 'new' };
                }

                setTimeout(() => textInput.focus(), 50);

                const vk = document.getElementById('virtualKeyboard');
                if (vk) {
                    vk.classList.add('visible');

                    requestAnimationFrame(() => {
                        const inputRect = this.editorDiv.getBoundingClientRect();
                        const vkRect = vk.getBoundingClientRect();

                        let top = inputRect.bottom + 10;
                        let left = inputRect.left + (inputRect.width / 2) - (vkRect.width / 2);

                        const winW = window.innerWidth;
                        const winH = window.innerHeight;

                        if (left < 10) left = 10;
                        if (left + vkRect.width > winW) left = winW - vkRect.width - 10;
                        if (top + vkRect.height > winH) top = inputRect.top - vkRect.height - 10;

                        vk.style.left = left + 'px';
                        vk.style.top = top + 'px';
                        vk.style.transform = 'none';
                    });
                }
            }



            initEventListeners() {
                // --- GESTION TACTILE (TABLETTES) ---
                const touchHandler = (e, type) => {
                    if (e.touches.length > 1) return; // Ignore le zoom √† 2 doigts
                    e.preventDefault(); // Emp√™che le scroll

                    const touch = e.changedTouches[0];
                    const mouseEvent = new MouseEvent(type, {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0,
                        bubbles: true
                    });

                    this.canvas.dispatchEvent(mouseEvent);
                };

                let longPressTimer;
                const LONG_PRESS_DELAY = 600; // Temps en ms avant d√©clenchement (0.6s)
                let touchStartCoords = { x: 0, y: 0 };

                this.canvas.addEventListener('touchstart', (e) => {
                    // On ne g√®re que le doigt unique
                    if (e.touches.length !== 1) return;

                    const touch = e.touches[0];
                    touchStartCoords = { x: touch.clientX, y: touch.clientY };

                    // On lance le chronom√®tre
                    longPressTimer = setTimeout(() => {
                        // Le temps est √©coul√© : C'est un appui long !

                        // 1. On cr√©e un faux √©v√©nement "Clic Droit"
                        const contextMenuEvent = new MouseEvent('contextmenu', {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            button: 2, // 2 = Clic droit
                            buttons: 2,
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });

                        // 2. On l'envoie au canvas (votre √©couteur existant va r√©agir)
                        this.canvas.dispatchEvent(contextMenuEvent);

                        // Optionnel : petite vibration haptique (Android uniquement)
                        if (navigator.vibrate) navigator.vibrate(50);

                    }, LONG_PRESS_DELAY);
                }, { passive: false });

                // Si on bouge le doigt ou qu'on rel√¢che, on annule le chronom√®tre
                const cancelLongPress = (e) => {
                    // Si on bouge un tout petit peu, √ßa va, mais si on glisse vraiment, on annule
                    if (e.type === 'touchmove') {
                        const touch = e.touches[0];
                        const dist = Math.sqrt(
                            (touch.clientX - touchStartCoords.x) ** 2 +
                            (touch.clientY - touchStartCoords.y) ** 2
                        );
                        if (dist < 10) return; // Mouvement n√©gligeable (< 10px), on continue le timer
                    }
                    clearTimeout(longPressTimer);
                };

                this.canvas.addEventListener('touchmove', cancelLongPress, { passive: false });
                this.canvas.addEventListener('touchend', cancelLongPress, { passive: false });
                this.canvas.addEventListener('touchcancel', cancelLongPress, { passive: false });
                // --- ZOOM (Molette) ---
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const zoomIntensity = 0.1;
                    const direction = e.deltaY < 0 ? 1 : -1;
                    const factor = (direction > 0) ? (1 + zoomIntensity) : (1 / (1 + zoomIntensity));

                    const mouse = this.getMousePos(e);

                    this.view.zoom *= factor;

                    this.view.x = mouse.screenX - (mouse.x * this.view.zoom);
                    this.view.y = mouse.screenY - (mouse.y * this.view.zoom);

                    this.render();
                }, { passive: false });

                const menu = document.getElementById('contextMenu');
                const handle = document.getElementById('menuDragHandle');

                let isDraggingMenu = false;
                let startX, startY, initialLeft, initialTop;

                handle.addEventListener('mousedown', (e) => {
                    isDraggingMenu = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = menu.getBoundingClientRect();
                    initialLeft = rect.left;
                    initialTop = rect.top;
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDraggingMenu) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    menu.style.left = `${initialLeft + dx}px`;
                    menu.style.top = `${initialTop + dy}px`;
                });

                window.addEventListener('mouseup', () => {
                    isDraggingMenu = false;
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const {
                        x,
                        y
                    } = this.getMousePos(e);

                    const targets = this.entities.filter(ent => ent.isNear(x, y));

                    targets.sort((a, b) => {
                        if (a instanceof Point) return 1;
                        if (b instanceof Point) return -1;
                        if (a instanceof Angle) return 1;
                        if (b instanceof Angle) return -1;
                        if (a instanceof Polygon) return 1;
                        if (b instanceof Polygon) return -1;
                        return 0;
                    });

                    if (targets.length > 0) {
                        this.selectedObject = targets.pop();
                        this.updateContextMenuUI();

                        const rowMeasure = document.getElementById('rowMeasure');
                        const rowCoding = document.getElementById('rowCoding');
                        const rowAngle = document.getElementById('rowAngle');
                        const rowStyle = document.getElementById('rowStyle');
                        const sep1 = document.getElementById('sep1');
                        const slider = document.getElementById('widthRange');

                        if (this.selectedObject instanceof Segment) {
                            rowMeasure.style.display = 'block';
                            rowCoding.style.cssText = "display: grid !important; grid-template-columns: repeat(4, 1fr); gap: 4px;";
                            this.updateContextMenuUI();
                        } else {
                            rowMeasure.style.display = 'none';
                            rowCoding.style.cssText = "display: none !important;";
                        }

                        const isPoint = this.selectedObject instanceof Point;
                        const rowPointStyle = document.getElementById('rowPointStyle')
                        const rowLabelPos = document.getElementById('rowLabelPos');
                        const rowRenamer = document.getElementById('rowRenamer');

                        if (isPoint) {
                            rowLabelPos.style.display = 'block';
                            rowRenamer.style.display = 'block';
                            rowPointStyle.style.display = 'flex';
                            rowTextProps.style.display = 'flex';
                            const btnEye = document.getElementById('btnToggleLabel');
                            if (this.selectedObject.showLabel) btnEye.classList.add('active');
                            else btnEye.classList.remove('active');
                            document.getElementById('renamerDisplay').innerText = this.selectedObject.label;

                            const angle = this.selectedObject.labelAngle || -Math.PI / 4;
                            const knob = document.getElementById('labelPosKnob');
                            const r = 24;
                            knob.style.left = (30 + Math.cos(angle) * r) + 'px';
                            knob.style.top = (30 + Math.sin(angle) * r) + 'px';

                            rowStyle.style.display = 'none';
                            sep1.style.display = 'none';
                        } else {
                            rowLabelPos.style.display = 'none';
                            rowTextProps.style.display = 'none';
                            rowRenamer.style.display = 'none';

                            rowStyle.style.display = 'flex';
                            sep1.style.display = 'block';
                            slider.value = this.selectedObject.lineWidth || 2;
                        }

                        if (this.selectedObject instanceof Angle) {
                            rowAngle.style.cssText = "display: flex !important; flex-direction: row; justify-content: center; gap: 8px;";
                            this.updateContextMenuUI();
                        } else {
                            rowAngle.style.cssText = "display: none !important;";
                        }

                        const menu = document.getElementById('contextMenu');
                        menu.style.left = e.clientX + 'px';
                        menu.style.top = e.clientY + 'px';
                        menu.style.display = 'flex';
                    }

                });
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#contextMenu')) document.getElementById('contextMenu').style.display = 'none';
                });




                this.canvas.onmousedown = (e) => {

                    // =========================================================================
                    // 1. S√âCURIT√âS & GESTION PANNING (D√âPLACEMENT DE LA VUE)
                    // =========================================================================

                    if (e.button === 1 || (this.currentTool === 'pan' && e.button === 0)) {
                        this.isPanning = true;
                        this.lastMouseScreen = { x: e.clientX, y: e.clientY };
                        this.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                        return;
                    }

                    if (this.isLocked) return;

                    const menu = document.getElementById('contextMenu');
                    if (menu.style.display && menu.style.display !== 'none') {
                        menu.style.display = 'none';
                        return;
                    }

                    if (e.button !== 0 && e.button !== 2) return;


                    // =========================================================================
                    // 2. CALCUL DES COORDONN√âES INTELLIGENTES (LE "SNAP")
                    // =========================================================================

                    // A. Coordonn√©es brutes et Grid
                    const mousePos = this.getMousePos(e);
                    this.hoveredEntities = this.entities.filter(ent => ent.isNear(mousePos.x, mousePos.y));

                    let smart;
                    if (this.getSmartCoords) {
                        smart = this.getSmartCoords(e); // Grille ou point existant
                    } else {
                        smart = { x: mousePos.x, y: mousePos.y };
                    }

                    let finalX = smart.x;
                    let finalY = smart.y;

                    // B. Aimantation aux Outils (R√®gle, √âquerre, etc.)
                    // Seulement si on est en train de tracer quelque chose
                    const drawingTools = ['segment', 'line', 'ray', 'point', 'circle', 'polygon'];

                    if (drawingTools.includes(this.currentTool)) {
                        const rawM = this.getMousePos(e);
                        let toolSnap = null;
                        const snapDist = 15; // Distance d'aimantation

                        // 1. √âQUERRE
                        if (this.activeWidgets.setsquare && this.setSquareWidget) {
                            const w = this.setSquareWidget;
                            const l = w.toLocal(rawM.x, rawM.y);
                            // Coin ou Bords
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                            else if (l.x > 0 && l.x < w.width && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(l.x, 0);
                            else if (l.y > 0 && l.y < w.height && Math.abs(l.x) < snapDist) toolSnap = w.toGlobal(0, l.y);
                        }

                        // 2. R√àGLE (Priorit√© si pas encore trouv√©)
                        if (!toolSnap && this.activeWidgets.ruler && this.rulerWidget) {
                            const w = this.rulerWidget;
                            const l = w.toLocal(rawM.x, rawM.y);
                            // Z√©ro ou Bord
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                            else if (Math.abs(l.y) < snapDist && l.x > -50 && l.x < 500) toolSnap = w.toGlobal(l.x, 0);
                        }

                        // 3. RAPPORTEUR
                        if (!toolSnap && this.activeWidgets.protractor && this.protractorWidget) {
                            const w = this.protractorWidget;
                            const l = w.toLocal(rawM.x, rawM.y);
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                        }

                        // 4. COMPAS
                        if (!toolSnap && this.activeWidgets.compass && this.compassWidget) {
                            const w = this.compassWidget;
                            const l = w.toLocal(rawM.x, rawM.y);
                            if (Math.abs(l.x) < 5 && Math.abs(l.y) < 5) toolSnap = w.toGlobal(0, 0);
                        }

                        // Appliquer le snap outil si trouv√©
                        if (toolSnap) {
                            finalX = toolSnap.x;
                            finalY = toolSnap.y;
                        }
                    }

                    // C. Intersections (Ghost) - Priorit√© Absolue
                    // Si on d√©tecte une intersection entre deux objets, elle √©crase tout le reste
                    const ghost = this.findIntersectionAtMouse(finalX, finalY);
                    if (ghost) {
                        finalX = ghost.x;
                        finalY = ghost.y;
                        this.ghostIntersection = ghost;
                    }

                    // Coordonn√©es finales √† utiliser pour tout le reste
                    const x = finalX;
                    const y = finalY;


                    // =========================================================================
                    // 3. OUTIL "POT DE PEINTURE" (STYLE)
                    // =========================================================================
                    if (this.isPaintMode && e.button === 0) {
                        const target = [...this.entities].reverse().find(ent => ent.isNear(x, y));
                        if (target) {
                            target.color = this.globalStyle.color;
                            target.lineWidth = this.globalStyle.width;
                            target.dash = [...this.globalStyle.dash];
                            if (target instanceof Point) target.lineWidth = 2;
                            this.saveState();
                            this.render();
                        }
                        return;
                    }


                    // =========================================================================
                    // 4. GESTION DES WIDGETS (D√âPLACEMENT / ROTATION)
                    // =========================================================================
                    // On v√©rifie d'abord si on clique SUR un outil pour le bouger.
                    // Si oui, on arr√™te tout, on ne dessine pas de g√©om√©trie.

                    let targetWidget = null;
                    let wType = '';

                    const widgetMap = {
                        'ruler': this.rulerWidget,
                        'setsquare': this.setSquareWidget,
                        'protractor': this.protractorWidget,
                        'compass': this.compassWidget
                    };

                    // Parcours Z-Order invers√© (du dessus vers le dessous)
                    for (let i = this.widgetZOrder.length - 1; i >= 0; i--) {
                        const type = this.widgetZOrder[i];
                        if (!this.activeWidgets[type]) continue;

                        const widget = widgetMap[type];
                        // On utilise les vraies coordonn√©es souris pour le hit test du widget, pas le snap
                        if (widget && widget.getHitZone(mousePos.x, mousePos.y)) {
                            targetWidget = widget;
                            wType = type;
                            // Bring to front
                            this.widgetZOrder.splice(i, 1);
                            this.widgetZOrder.push(type);
                            break;
                        }
                    }

                    if (targetWidget) {
                        const zone = targetWidget.getHitZone(mousePos.x, mousePos.y);
                        if (zone) {
                            // Actions imm√©diates (Toggle)
                            if (zone === 'toggleSwap' && targetWidget instanceof ProtractorWidget) {
                                targetWidget.isReversed = !targetWidget.isReversed;
                            }
                            else if (zone === 'toggleLock' && targetWidget instanceof ProtractorWidget) {
                                targetWidget.isLocked = !targetWidget.isLocked;
                            }
                            else if (zone === 'toggleSlide' && targetWidget instanceof SetSquareWidget) {
                                targetWidget.slideMode = !targetWidget.slideMode;
                            }
                            // Actions de Drag (Move, Rotate, Slide)
                            else {
                                this.draggedWidget = targetWidget;
                                this.draggedWidgetMode = zone;
                                this.widgetStartState = this.getWidgetState(targetWidget);
                                this.draggedWidgetType = wType;

                                // Calcul de l'offset pour rotation
                                if (zone === 'rotate') {
                                    this.widgetRotationOffset = Math.atan2(mousePos.y - targetWidget.y, mousePos.x - targetWidget.x) - targetWidget.angle;
                                }
                                // Initialisation pour Slide X/Y
                                if (zone === 'slideX' || zone === 'slideY') {
                                    this.dragStartMouse = { x: mousePos.x, y: mousePos.y };
                                    this.dragStartWidget = { x: targetWidget.x, y: targetWidget.y };
                                }
                                // Initialisation Compas Trace
                                if (targetWidget instanceof CompassWidget && zone === 'trace') {
                                    targetWidget.isTracing = true;
                                    // On utilise snapX/Y ici pour que le trac√© commence bien sur le point aimant√© si besoin
                                    const startAngle = Math.atan2(y - targetWidget.y, x - targetWidget.x);
                                    targetWidget.startAngle = startAngle;
                                    this.widgetStartState.angle = startAngle;
                                    targetWidget.angle = startAngle;
                                    targetWidget.lastMouseAngle = startAngle;
                                    targetWidget.totalRotation = 0;
                                    this.currentTracingArc = null;
                                }
                                // Initialisation Move
                                if (zone === 'move') {
                                    this.widgetOffset.x = mousePos.x - targetWidget.x;
                                    this.widgetOffset.y = mousePos.y - targetWidget.y;
                                }
                            }
                            this.render();
                            return; // IMPORTANT : On s'arr√™te l√†, on ne cr√©e pas de point si on bouge un outil
                        }
                    }


                    // =========================================================================
                    // 5. PR√âPARATION OBJETS SOUS SOURIS (POUR √âDITION/SUPPRESSION)
                    // =========================================================================
                    const entities = this.hoveredEntities || [];
                    const clickedPoint = entities.filter(ent => ent instanceof Point).pop();
                    const clickedText = entities.find(ent => ent instanceof TextLabel);
                    const clickedLinear = entities.filter(ent =>
                        ent instanceof LinearObject || ent instanceof ParallelLine ||
                        ent instanceof PerpendicularLine || ent instanceof Circle ||
                        ent instanceof Arc || ent instanceof Segment
                    ).pop();


                    // =========================================================================
                    // 6. √âDITEUR DE TEXTE
                    // =========================================================================
                    if (this.currentTool === 'text') {
                        if (this.editorDiv && this.editorDiv.style.display !== 'none') {
                            this.applyTextEdit();
                            return;
                        }
                        // On utilise les coordonn√©es snapp√©es (x,y) pour placer le texte proprement
                        if (clickedPoint) this.startTextEditor(clickedPoint.x, clickedPoint.y, clickedPoint);
                        else if (clickedText) this.startTextEditor(clickedText.x, clickedText.y, clickedText);
                        else this.startTextEditor(x, y, null);

                        this.render();
                        return;
                    }


                    // =========================================================================
                    // 7. OUTILS DE DESSIN G√âOM√âTRIQUE (CLIC GAUCHE)
                    // =========================================================================
                    if (e.button !== 0) return;

                    // Reset du Replay si on dessine
                    if (this.replayIndex !== null && this.replayIndex < this.entities.length) {
                        this.replayIndex = this.entities.length;
                    }

                    // Sauvegarde de l'√©tat (Undo/Redo)
                    const toolsModifying = ['point', 'segment', 'line', 'ray', 'circle', 'midpoint', 'parallel', 'perpendicular', 'delete', 'polygon', 'angle', 'compass'];
                    if (toolsModifying.includes(this.currentTool) || (this.currentTool === 'move' && (clickedPoint || clickedText))) {
                        this.saveState();
                    }

                    // --- A. Outil MOVE (D√©placer des points/textes) ---
                    if (this.currentTool === 'move') {
                        if (clickedPoint && clickedPoint.parents.length !== 2) {
                            this.draggedPoint = clickedPoint;
                            this.dragStartPos = { x: clickedPoint.x, y: clickedPoint.y };
                        } else if (clickedText) {
                            this.draggedText = clickedText;
                            this.dragStartPos = { x: clickedText.x, y: clickedText.y };
                            this.dragOffset = { x: x - clickedText.x, y: y - clickedText.y };
                        }
                    }

                    // --- B. Outil POINT ---
                    else if (this.currentTool === 'point') {
                        this.createPointAt(x, y); // Utilise x,y snapp√©s
                    }

                    // --- C. Outils de TRAC√â (Segment, Droite...) ---
                    else if (['segment', 'ray', 'line', 'circle'].includes(this.currentTool)) {
                        // Premier point cr√©√© aux coordonn√©es snapp√©es
                        this.creationStartPoint = this.createPointAt(x, y);
                        this.isDraggingCreation = true;
                    }

                    // --- D. Outil ANGLE ---
                    else if (this.currentTool === 'angle') {
                        const pt = this.createPointAt(x, y);
                        this.anglePoints.push(pt);
                        if (this.anglePoints.length === 3) {
                            const ang = new Angle(this.anglePoints[0], this.anglePoints[1], this.anglePoints[2]);
                            ang.color = this.globalStyle.color;
                            ang.lineWidth = this.globalStyle.width;
                            this.addEntity(ang);
                            this.anglePoints = [];
                            this.saveState();
                        }
                    }

                    // --- E. Outil POLYGONE ---
                    else if (this.currentTool === 'polygon') {
                        // Fermeture du polygone ?
                        if (clickedPoint && this.polygonPoints.length > 2 && clickedPoint === this.polygonPoints[0]) {
                            const poly = new Polygon([...this.polygonPoints]);
                            this.addEntity(poly);

                            // Cr√©ation des segments finaux
                            for (let i = 0; i < this.polygonPoints.length; i++) {
                                const p1 = this.polygonPoints[i];
                                const p2 = this.polygonPoints[(i + 1) % this.polygonPoints.length];
                                const seg = new Segment(p1, p2);
                                seg.color = this.globalStyle.color;
                                seg.lineWidth = this.globalStyle.width;
                                seg.dash = [...this.globalStyle.dash];
                                this.addEntity(seg);
                            }
                            this.polygonPoints = [];
                            this.saveState();
                        } else {
                            this.polygonPoints.push(this.createPointAt(x, y));
                        }
                    }

                    // --- F. Outil MILIEU ---
                    else if (this.currentTool === 'midpoint') {
                        if (clickedLinear instanceof Segment) {
                            // Milieu d'un segment existant
                            const mid = new Point(0, 0, this.getNextLabel(), [clickedLinear.p1, clickedLinear.p2]);
                            mid.update();
                            this.addEntity(mid);
                        } else if (clickedPoint) {
                            // Milieu entre deux points
                            if (this.creationStartPoint && this.creationStartPoint !== clickedPoint) {
                                const mid = new Point(0, 0, this.getNextLabel(), [this.creationStartPoint, clickedPoint]);
                                mid.update();
                                this.addEntity(mid);
                                this.creationStartPoint = null;
                            } else {
                                this.creationStartPoint = clickedPoint;
                            }
                        }
                    }

                    // --- G. Outils PARALLELE / PERPENDICULAIRE ---
                    else if (['parallel', 'perpendicular'].includes(this.currentTool)) {
                        if (clickedLinear) {
                            this.referenceObject = clickedLinear;
                            this.isDraggingCreation = true;
                        }
                    }

                    // --- H. Outils SYM√âTRIE ---
                    else if (['sym_central', 'sym_axial'].includes(this.currentTool)) {
                        let target = clickedPoint || clickedText || clickedLinear || this.hoveredEntities.filter(e => e instanceof Polygon).pop();

                        if (target) {
                            if (!this.transformationSource) {
                                this.transformationSource = target;
                                this.canvas.style.cursor = "copy";
                            } else {
                                let ref = target;
                                const mode = (this.currentTool === 'sym_central') ? 'central' : 'axial';
                                let valid = false;

                                if (mode === 'central' && ref instanceof Point) valid = true;
                                if (mode === 'axial' && (ref instanceof LinearObject || ref instanceof Segment || ref instanceof Line || ref instanceof Ray)) valid = true;

                                if (valid) {
                                    this.createSymmetry(this.transformationSource, ref, mode);
                                    this.transformationSource = null;
                                    this.canvas.style.cursor = "default";
                                }
                            }
                        }
                    }

                    // --- I. Outil SUPPRIMER (Gomme) ---
                    else if (this.currentTool === 'delete') {
                        let target = clickedPoint || clickedText;
                        if (!target) target = this.entities.slice().reverse().find(e => e.isNear && e.isNear(x, y));

                        if (target) {
                            let listToDelete = this.getNetworkToDelete(target);

                            // Gestion sp√©ciale pour ne pas casser les polygones
                            if (target instanceof Point) {
                                this.entities.forEach(poly => {
                                    if (poly instanceof Polygon) {
                                        const idx = poly.points.indexOf(target);
                                        if (idx !== -1) {
                                            const len = poly.points.length;
                                            const prevPoint = poly.points[(idx - 1 + len) % len];
                                            const nextPoint = poly.points[(idx + 1) % len];

                                            poly.points.splice(idx, 1);

                                            if (poly.points.length >= 3) {
                                                listToDelete = listToDelete.filter(item => item !== poly);
                                                // On recr√©e le segment manquant
                                                const segmentExists = this.entities.some(e =>
                                                    e instanceof Segment &&
                                                    ((e.p1 === prevPoint && e.p2 === nextPoint) || (e.p1 === nextPoint && e.p2 === prevPoint))
                                                );
                                                if (!segmentExists) {
                                                    const newSeg = new Segment(prevPoint, nextPoint);
                                                    this.entities.push(newSeg);
                                                }
                                            }
                                        }
                                    }
                                });
                            }

                            this.entities = this.entities.filter(e => !listToDelete.includes(e));
                            this.toDeletePreview = [];
                            this.selectedObject = null;
                            this.saveState();
                            this.render();
                        }
                    }

                    this.render();
                }; this.canvas.onmousemove = (e) => {

                    // =========================================================================
                    // 1. GESTION DU PANNING (D√âPLACEMENT DE LA VUE)
                    // =========================================================================
                    if (this.isPanning) {
                        const dx = e.clientX - this.lastMouseScreen.x;
                        const dy = e.clientY - this.lastMouseScreen.y;
                        this.view.x += dx;
                        this.view.y += dy;
                        this.lastMouseScreen = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // =========================================================================
                    // 2. CALCUL DES COORDONN√âES & MAGN√âTISME (SNAP INTELLIGENT)
                    // =========================================================================

                    // A. Base : Grille ou Position Libre
                    let smartPos;
                    if (this.getSmartCoords) smartPos = this.getSmartCoords(e);
                    else {
                        const mp = this.getMousePos(e);
                        smartPos = { x: mp.x, y: mp.y };
                    }

                    // On stocke la position brute pour certains calculs (d√©placement widget)
                    const rawMouse = this.getMousePos(e);

                    // B. Aimantation aux Outils (Le cercle rouge qui suit)
                    // On calcule 'snappedPos' qui sera la position officielle du curseur g√©om√©trique
                    let snappedPos = { x: smartPos.x, y: smartPos.y, snapped: false };

                    // On active l'aimantation outil seulement si on dessine ou si on survole
                    const drawingTools = ['segment', 'line', 'ray', 'point', 'circle', 'polygon'];
                    const isDrawingOrHovering = drawingTools.includes(this.currentTool) || this.currentTool === 'move';

                    if (isDrawingOrHovering && !this.draggedWidget) {
                        let toolSnap = null;
                        const snapDist = 15;

                        // 1. √âQUERRE
                        if (this.activeWidgets.setsquare && this.setSquareWidget) {
                            const w = this.setSquareWidget;
                            const l = w.toLocal(rawMouse.x, rawMouse.y);
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                            else if (l.x > 0 && l.x < w.width && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(l.x, 0);
                            else if (l.y > 0 && l.y < w.height && Math.abs(l.x) < snapDist) toolSnap = w.toGlobal(0, l.y);
                        }
                        // 2. R√àGLE
                        if (!toolSnap && this.activeWidgets.ruler && this.rulerWidget) {
                            const w = this.rulerWidget;
                            const l = w.toLocal(rawMouse.x, rawMouse.y);
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                            else if (Math.abs(l.y) < snapDist && l.x > -50 && l.x < 500) toolSnap = w.toGlobal(l.x, 0);
                        }
                        // 3. RAPPORTEUR
                        if (!toolSnap && this.activeWidgets.protractor && this.protractorWidget) {
                            const w = this.protractorWidget;
                            const l = w.toLocal(rawMouse.x, rawMouse.y);
                            if (Math.abs(l.x) < snapDist && Math.abs(l.y) < snapDist) toolSnap = w.toGlobal(0, 0);
                        }
                        // 4. COMPAS
                        if (!toolSnap && this.activeWidgets.compass && this.compassWidget) {
                            const w = this.compassWidget;
                            const l = w.toLocal(rawMouse.x, rawMouse.y);
                            if (Math.abs(l.x) < 5 && Math.abs(l.y) < 5) toolSnap = w.toGlobal(0, 0);
                        }

                        if (toolSnap) {
                            snappedPos = { x: toolSnap.x, y: toolSnap.y, snapped: true };
                        }
                    }

                    // C. Aimantation aux Intersections (Ghost) - Priorit√© Absolue
                    const ghost = this.findIntersectionAtMouse(snappedPos.x, snappedPos.y);
                    if (ghost) {
                        snappedPos = { x: ghost.x, y: ghost.y, snapped: true };
                        this.ghostIntersection = ghost;
                    } else {
                        this.ghostIntersection = null;
                    }

                    // Mise √† jour finale de la position globale de la souris
                    this.mousePos = snappedPos;
                    const { x, y } = this.mousePos; // x, y sont maintenant "aimant√©s" si besoin

                    let resizeCursor = '';
                    // =========================================================================
                    // 3. LOGIQUE DE DRAG & DROP DES WIDGETS (D√âPLACEMENT OUTILS)
                    // =========================================================================
                    if (this.draggedWidget) {
                        const w = this.draggedWidget;
                        const mode = this.draggedWidgetMode;

                        // Pour le d√©placement fluide, on utilise rawMouse, pas le snap g√©om√©trique
                        const rx = rawMouse.x;
                        const ry = rawMouse.y;

                        // A. D√âPLACEMENT DE L'OUTIL (MOVE)
                        if (mode === 'move') {
                            let targetX = rx - this.widgetOffset.x;
                            let targetY = ry - this.widgetOffset.y;

                            // Petit snap magn√©tique vers les points existants
                            const snapPoint = this.entities.find(ent => ent instanceof Point && MathUtils.dist(targetX, targetY, ent.x, ent.y) < 15);
                            if (snapPoint) {
                                w.x = snapPoint.x;
                                w.y = snapPoint.y;
                            } else {
                                w.x = targetX;
                                w.y = targetY;
                            }
                        }
                        // B. GLISSEMENT SUR AXES (EQUERRE/R√àGLE)
                        else if (mode === 'slideX' || mode === 'slideY') {
                            const dx = rx - this.dragStartMouse.x;
                            const dy = ry - this.dragStartMouse.y;
                            let axisAngle = w.angle;
                            if (mode === 'slideY') axisAngle += Math.PI / 2;

                            const dot = dx * Math.cos(axisAngle) + dy * Math.sin(axisAngle);
                            w.x = this.dragStartWidget.x + dot * Math.cos(axisAngle);
                            w.y = this.dragStartWidget.y + dot * Math.sin(axisAngle);
                        }
                        // C. ROTATION
                        else if (mode === 'rotate') {
                            const angleMouse = Math.atan2(ry - w.y, rx - w.x);
                            let newAngle = angleMouse - this.widgetRotationOffset;

                            // Snap angulaire intelligent vers les points
                            let snappedAngle = null;
                            let bestDist = 25;
                            for (let ent of this.entities) {
                                if (ent instanceof Point) {
                                    const distMousePoint = MathUtils.dist(rx, ry, ent.x, ent.y);
                                    if (distMousePoint < bestDist) {
                                        const angleToPoint = Math.atan2(ent.y - w.y, ent.x - w.x);
                                        // Normalisation et comparaison d'angles...
                                        // (Je garde ta logique existante ici, elle est bonne)
                                        const norm = (a) => (a + Math.PI * 4) % (Math.PI * 2);
                                        const targetA = norm(angleToPoint);
                                        const targetB = norm(angleToPoint + Math.PI);
                                        const current = norm(newAngle);
                                        const distA = Math.min(Math.abs(current - targetA), 2 * Math.PI - Math.abs(current - targetA));
                                        const distB = Math.min(Math.abs(current - targetB), 2 * Math.PI - Math.abs(current - targetB));

                                        if (distA < distB) snappedAngle = angleToPoint;
                                        else snappedAngle = angleToPoint + Math.PI;
                                        bestDist = distMousePoint;
                                    }
                                }
                            }
                            w.angle = (snappedAngle !== null) ? snappedAngle : newAngle;
                        }
                        // D. COMPAS (RESIZE & TRACE)
                        else if (mode === 'trace' && w instanceof CompassWidget) {
                            const currentAngle = Math.atan2(y - w.y, x - w.x);
                            let diff = currentAngle - w.lastMouseAngle;

                            while (diff > Math.PI) diff -= 2 * Math.PI;
                            while (diff < -Math.PI) diff += 2 * Math.PI;

                            let nextTotal = w.totalRotation + diff;
                            const TWO_PI = Math.PI * 2;

                            if (nextTotal > TWO_PI) nextTotal = TWO_PI - 0.001;
                            if (nextTotal < -TWO_PI) nextTotal = -TWO_PI + 0.001;

                            w.totalRotation = nextTotal;
                            w.lastMouseAngle = currentAngle;
                            w.angle = w.startAngle + w.totalRotation;

                            const isCCW = (w.totalRotation < 0);

                            if (this.currentTracingArc) {
                                const idx = this.entities.indexOf(this.currentTracingArc);
                                if (idx !== -1) this.entities.splice(idx, 1);
                                this.currentTracingArc = null;
                            }

                            if (Math.abs(w.totalRotation) > 0.01) {
                                const center = { x: w.x, y: w.y };
                                const centerPoint = this.entities.filter(ent => ent instanceof Point && MathUtils.dist(ent.x, ent.y, center.x, center.y) < 5).pop();

                                this.currentTracingArc = new CompassArc(
                                    centerPoint || center,
                                    w.radius,
                                    w.startAngle,
                                    w.startAngle + w.totalRotation,
                                    isCCW
                                );
                                this.currentTracingArc.color = app.globalStyle.color;
                                this.currentTracingArc.lineWidth = this.globalStyle.width;
                                this.addEntity(this.currentTracingArc);
                            }
                        }
                        else if (mode === 'resize' && w instanceof CompassWidget) {
                            let newRadius = MathUtils.dist(x, y, w.x, w.y);
                            const snap = this.entities.filter(ent => ent instanceof Point).find(p => MathUtils.dist(x, y, p.x, p.y) < 15);
                            if (snap) {
                                newRadius = MathUtils.dist(w.x, w.y, snap.x, snap.y);
                                w.angle = Math.atan2(snap.y - w.y, snap.x - w.x);
                            } else {
                                w.angle = Math.atan2(y - w.y, x - w.x);
                            }
                            w.radius = newRadius;
                            this.render();
                            return; // On s'arr√™te ici si on bouge un outil
                        }
                    }


                    // =========================================================================
                    // 4. MISE √Ä JOUR DE LA CR√âATION EN COURS (LE TRAIT QUI SUIT)
                    // =========================================================================
                    if (this.isDraggingCreation && this.creationStartPoint) {
                        // C'est ici que la magie op√®re : on utilise x,y (snapped) pour mettre √† jour
                        // le point final temporaire. Le trait va donc "suivre" l'aimantation.

                        // Note: On ne modifie pas directement creationStartPoint, mais l'objet temporaire
                        // que tu g√®res probablement dans render() ou via un objet temporaire.
                        // Si tu n'as pas d'objet temporaire, tu stockes juste la pos souris pour le render.
                        this.currentMousePosForPreview = { x: x, y: y };
                    }


                    // =========================================================================
                    // 5. D√âPLACEMENT DE POINTS (MOVE)
                    // =========================================================================
                    if (this.currentTool === 'move') {
                        if (this.draggedPoint) {
                            // Point contraint (sur segment/cercle)
                            if (this.draggedPoint.parents.length === 1) {
                                const pObj = this.draggedPoint.parents[0];
                                const p = Array.isArray(pObj) ? { constructor: { name: 'Segment' }, p1: pObj[0], p2: pObj[1] } : pObj;
                                const proj = MathUtils.getProjectedPoint(rawMouse.x, rawMouse.y, p); // On utilise rawMouse pour la projection fluide
                                this.draggedPoint.x = proj.x;
                                this.draggedPoint.y = proj.y;
                            }
                            // Point libre
                            else {
                                // Ici on utilise x,y (snapped) pour que le point suive la grille/aimantation
                                this.draggedPoint.x = x;
                                this.draggedPoint.y = y;
                            }
                            this.updateDependents();
                            this.render();
                        }
                        else if (this.draggedText) {
                            this.draggedText.x = rawMouse.x - this.dragOffset.x;
                            this.draggedText.y = rawMouse.y - this.dragOffset.y;
                            this.render();
                        }
                    }


                    // =========================================================================
                    // 6. GESTION DES CURSEURS
                    // =========================================================================
                    this.hoveredEntities = this.entities.filter(ent => ent.isNear(rawMouse.x, rawMouse.y));

                    let cursor = 'default';
                    let hoveredWidget = null;

                    // On teste les zones avec rawMouse.x / rawMouse.y
                    if (this.activeWidgets.compass && this.compassWidget.getHitZone(rawMouse.x, rawMouse.y)) hoveredWidget = this.compassWidget;
                    else if (this.activeWidgets.ruler && this.rulerWidget.getHitZone(rawMouse.x, rawMouse.y)) hoveredWidget = this.rulerWidget;
                    else if (this.activeWidgets.setsquare && this.setSquareWidget.getHitZone(rawMouse.x, rawMouse.y)) hoveredWidget = this.setSquareWidget;
                    else if (this.activeWidgets.protractor && this.protractorWidget.getHitZone(rawMouse.x, rawMouse.y)) hoveredWidget = this.protractorWidget;

                    if (hoveredWidget) {
                        const zone = hoveredWidget.getHitZone(rawMouse.x, rawMouse.y);

                        const cursors = {
                            'move': 'move',
                            'resize': 'ew-resize',
                            'slideY': 'col-resize',
                            'slideX': 'row-resize',
                            'rotate': "url('data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2232%22 height=%2232%22 viewBox=%220 0 24 24%22 fill=%22none%22%3E%3Cpath d=%22M8.22673 13.3292C8.51492 14.1471 9.06116 14.8493 9.78313 15.3298C10.5051 15.8103 11.3637 16.0432 12.2296 15.9934C13.0954 15.9436 13.9216 15.6137 14.5837 15.0535C15.2458 14.4933 15.7078 13.7332 15.9003 12.8876C16.0927 12.042 16.0051 11.1567 15.6507 10.3652C15.2962 9.57374 14.6941 8.91887 13.9351 8.4993C13.176 8.07974 12.3012 7.91819 11.4424 8.03902C10.0777 8.23101 9.0827 9.23345 8 10M8 10V7M8 10H11%22 stroke=%22white%22 stroke-width=%224%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22/%3E%3Cpath d=%22M8.22673 13.3292C8.51492 14.1471 9.06116 14.8493 9.78313 15.3298C10.5051 15.8103 11.3637 16.0432 12.2296 15.9934C13.0954 15.9436 13.9216 15.6137 14.5837 15.0535C15.2458 14.4933 15.7078 13.7332 15.9003 12.8876C16.0927 12.042 16.0051 11.1567 15.6507 10.3652C15.2962 9.57374 14.6941 8.91887 13.9351 8.4993C13.176 8.07974 12.3012 7.91819 11.4424 8.03902C10.0777 8.23101 9.0827 9.23345 8 10M8 10V7M8 10H11%22 stroke=%22black%22 stroke-width=%221.5%22 stroke-linecap=%22round%22 stroke-linejoin=%22round%22/%3E%3C/svg%3E') 16 16, auto",
                            'trace': "url('data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2220%22 height=%2220%22 viewBox=%220 0 512 512%22%3E%3Cpath fill=%22black%22 stroke=%22black%22 stroke-width=%2235%22 d=%22M500.1 71.1l-59.2-59.2c-15.9-15.8-41.5-15.9-57.4 0l-38.4 38.4L57.3 338.2c-7.8 7.8-13.7 17.2-17.4 27.5L1.8 471.5c-4 11-1.2 23.4 7.1 31.7 8.3 8.3 20.6 11 31.7 7.1l105.8-38c10.3-3.7 19.7-9.7 27.5-17.4l277.9-277.9.1.1 10-10 38.4-38.4C515.9 112.6 516 86.9 500.1 71.1z M136.7 445.5l-67.4 24.2-27-27 24.2-67.4c.2-.5.4-1 .6-1.4l71 71c-.3.4-.8.6-1.4.6z M153.8 434.7c-1 1-2 1.8-3 2.7L74.6 361.3c.9-1 1.7-2.1 2.7-3L363.8 71.7l76.4 76.4L153.8 434.7z M480 108.4L451.7 136.7l-1.4 1.4-76.4-76.4 29.8-29.8c4.8-4.7 12.5-4.7 17.2 0l59.2 59.2c4.7 4.7 4.7 12.4-.1 17.3z%22/%3E%3C/svg%3E') 0 20, auto",
                            'traceAngle': 'crosshair',
                            'toggleLock': 'pointer',
                            'toggleSwap': 'pointer',
                            'toggleSlide': 'pointer'
                        };

                        if (cursors[zone]) cursor = cursors[zone];
                        else cursor = 'pointer'; // Fallback
                    }
                    else if (this.currentTool === 'pan') {
                        cursor = this.isPanning ? 'grabbing' : 'grab';
                    }
                    else if (['segment', 'line', 'point'].includes(this.currentTool)) {
                        cursor = 'crosshair';
                    }
                    else if (['parallel', 'perpendicular'].includes(this.currentTool)) {
                        // Pour les outils qui n√©cessitent de cliquer sur une ligne
                        const clickedLinear = this.hoveredEntities.filter(e => e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine).pop();
                        if (clickedLinear) cursor = 'pointer';
                    }
                    else if (this.currentTool === 'move' && this.hoveredEntities.length > 0) {
                        cursor = 'pointer';
                    }

                    this.canvas.style.cursor = cursor;
                    this.render();
                };
                // =============================================================================
                // GESTIONNAIRE D'√âV√âNEMENT GLOBAL : MOUSEUP (FIN D'ACTION)
                // =============================================================================
                window.addEventListener('mouseup', () => {

                    // 1. GESTION DU PANNING (D√©placement de vue)
                    if (this.isPanning) {
                        this.isPanning = false;
                        return;
                    }

                    // 2. FIN D√âPLACEMENT D'UN POINT (Animation + Sauvegarde)
                    if (this.draggedPoint) {
                        const dx = this.draggedPoint.x - this.dragStartPos.x;
                        const dy = this.draggedPoint.y - this.dragStartPos.y;

                        if (Math.sqrt(dx * dx + dy * dy) > 1) {
                            const anim = new ToolAnimation('pointMove', this.dragStartPos, {
                                x: this.draggedPoint.x,
                                y: this.draggedPoint.y
                            });
                            anim.targetId = this.draggedPoint.id;
                            this.addEntity(anim);
                        }

                        this.saveState();
                        this.draggedPoint = null;
                    }

                    // 3. GESTION SP√âCIALE : TRAC√â RAPPORTEUR (Protractor)
                    if (this.draggedWidget instanceof ProtractorWidget && this.draggedWidgetMode === 'traceAngle') {
                        const w = this.draggedWidget;

                        // 1. CENTRE (p1)
                        // On cherche un point existant pr√®s du centre du rapporteur
                        let p1 = this.entities.find(e => e instanceof Point && MathUtils.dist(e.x, e.y, w.x, w.y) < 10);
                        if (!p1) {
                            p1 = new Point(w.x, w.y, this.getNextLabel());
                            this.addEntity(p1);
                        }

                        // 2. DIRECTION (p2)
                        // On regarde si l'utilisateur vise un point existant
                        let p2 = this.entities.find(e => e instanceof Point && MathUtils.dist(e.x, e.y, this.mousePos.x, this.mousePos.y) < 10);

                        if (!p2) {
                            // CAS : Clic dans le vide -> On cr√©e un point INVISIBLE
                            p2 = new Point(this.mousePos.x, this.mousePos.y, ""); // Pas de label
                            p2.visible = false; // <--- MAGIE : Le point existe mais ne se dessine pas
                            this.addEntity(p2);
                        }

                        // 3. Cr√©ation de la demi-droite
                        const ray = new Ray(p1, p2);
                        ray.color = this.globalStyle.color;
                        ray.lineWidth = this.globalStyle.width;
                        this.addEntity(ray);

                        this.saveState();
                        this.draggedWidget = null;
                        this.draggedWidgetMode = null;
                        this.render();
                        return;
                    }

                    // 4. GESTION G√âN√âRALE DES WIDGETS (R√®gle, Equerre, Compas)
                    if (this.draggedWidget) {
                        const w = this.draggedWidget;

                        const endState = this.getWidgetState(w);
                        let anim = null;

                        if (this.widgetStartState) {
                            const s = this.widgetStartState;
                            const e = endState;
                            const moved = (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1 || Math.abs(s.angle - e.angle) > 0.001 || Math.abs(s.radius - e.radius) > 0.1);

                            if (moved) {
                                anim = new ToolAnimation(this.draggedWidgetType, s, e);
                            }
                        }

                        if (w instanceof CompassWidget && this.draggedWidgetMode === 'trace') {

                            const rawEndAngle = w.startAngle + w.totalRotation;
                            const isCCW = (w.totalRotation < 0);

                            if (anim) {
                                anim.endState.angle = rawEndAngle;
                                anim.counterClockwise = isCCW;

                                // On v√©rifie si l'arc existe pour savoir o√π ins√©rer l'anim
                                const arcIndex = this.currentTracingArc ? this.entities.indexOf(this.currentTracingArc) : -1;

                                if (arcIndex !== -1) this.entities.splice(arcIndex, 0, anim);
                                else this.entities.push(anim);
                            }

                            // --- CORRECTION : ON V√âRIFIE QUE L'ARC EXISTE ---
                            if (this.currentTracingArc) {
                                this.currentTracingArc.endAngle = rawEndAngle;
                                this.currentTracingArc.counterClockwise = isCCW;
                                this.saveState(); // On sauvegarde uniquement si on a trac√© quelque chose
                            }

                            // Nettoyage standard (toujours ex√©cut√©)
                            this.currentTracingArc = null;
                            w.isTracing = false;
                            w.totalRotation = 0;
                            w.lastMouseAngle = null;

                        } else {
                            if (anim) {
                                this.addEntity(anim);
                                this.saveState();
                            }
                        }

                        this.draggedWidget = null;
                        this.draggedWidgetMode = null;
                    }

                    // 5. GESTION CR√âATION DE FORMES (Segment, Ligne, Cercle...)
                    if (['segment', 'ray', 'line', 'circle'].includes(this.currentTool) && this.isDraggingCreation && this.creationStartPoint) {
                        const dist = Math.sqrt((this.mousePos.x - this.creationStartPoint.x) ** 2 + (this.mousePos.y - this.creationStartPoint.y) ** 2);

                        if (dist > 10) {
                            const endPoint = this.createPointAt(this.mousePos.x, this.mousePos.y);
                            let newObj;
                            if (this.currentTool === 'segment') newObj = new Segment(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'line') newObj = new Line(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'ray') newObj = new Ray(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'circle') newObj = new Circle(this.creationStartPoint, endPoint);

                            if (newObj) {
                                newObj.color = this.globalStyle.color;
                                newObj.lineWidth = this.globalStyle.width;
                                newObj.dash = [...this.globalStyle.dash];
                                this.addEntity(newObj);
                                this.updateDependents();
                                this.saveState();
                            }
                        }
                        this.creationStartPoint = null;
                        this.isDraggingCreation = false;
                        this.render();
                    }

                    // 6. GESTION PARALL√àLE / PERPENDICULAIRE
                    if (['parallel', 'perpendicular'].includes(this.currentTool) && this.isDraggingCreation && this.referenceObject) {
                        const p1 = this.createPointAt(this.mousePos.x, this.mousePos.y);
                        let newObj;
                        if (this.currentTool === 'parallel') newObj = new ParallelLine(p1, this.referenceObject);
                        else newObj = new PerpendicularLine(p1, this.referenceObject);

                        newObj.color = this.globalStyle.color;
                        newObj.lineWidth = this.globalStyle.width;
                        newObj.dash = [...this.globalStyle.dash];

                        this.addEntity(newObj);
                        this.updateDependents();
                        this.saveState();
                        this.referenceObject = null;
                        this.isDraggingCreation = false;
                        this.render();
                    }

                    // 7. GESTION D√âPLACEMENT TEXTE (Animation)
                    if (this.draggedText) {
                        const dx = this.draggedText.x - this.dragStartPos.x;
                        const dy = this.draggedText.y - this.dragStartPos.y;

                        if (Math.sqrt(dx * dx + dy * dy) > 1) {
                            const anim = new ToolAnimation('textMove', this.dragStartPos, {
                                x: this.draggedText.x,
                                y: this.draggedText.y
                            });
                            anim.targetId = this.draggedText.id;
                            this.addEntity(anim);
                        }

                        this.saveState();
                        this.draggedText = null;
                    }

                    // 8. RESET LABEL ANGLE
                    if (typeof isDraggingLabel !== 'undefined' && isDraggingLabel) {
                        isDraggingLabel = false;
                    }
                });

                const box = document.getElementById('labelPosBox');
                const knob = document.getElementById('labelPosKnob');

                const updateLabelAngle = (e) => {
                    if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                    const rect = box.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);

                    this.selectedObject.labelAngle = angle;

                    const r = 24;
                    knob.style.left = (30 + Math.cos(angle) * r) + 'px';
                    knob.style.top = (30 + Math.sin(angle) * r) + 'px';

                    this.render();
                };

                let isDraggingLabel = false;

                box.addEventListener('mousedown', (e) => {
                    isDraggingLabel = true;
                    updateLabelAngle(e);
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (isDraggingLabel) updateLabelAngle(e);
                });

                window.addEventListener('mouseup', () => {
                    if (isDraggingLabel) {
                        isDraggingLabel = false;
                        this.saveState();
                    }
                });

                const renamerDisplay = document.getElementById('renamerDisplay');

                renamerDisplay.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const direction = e.deltaY > 0 ? 1 : -1;
                    this.cyclePointName(direction);

                }, { passive: false });
            }

            drawCreationGhost() {


                if (this.creationStartPoint && this.isDraggingCreation && !['compass', 'protractor', 'setsquare', 'ruler'].includes(this.currentTool)) {
                    const start = this.creationStartPoint;
                    const end = this.mousePos;
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#555";
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    if (this.currentTool === 'segment') {
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                    } else if (this.currentTool === 'ray') {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(start.x + dx * 100, start.y + dy * 100);
                    } else if (this.currentTool === 'line') {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        this.ctx.moveTo(start.x - dx * 100, start.y - dy * 100);
                        this.ctx.lineTo(start.x + dx * 100, start.y + dy * 100);
                    } else if (this.currentTool === 'circle') {
                        const r = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                        this.ctx.arc(start.x, start.y, r, 0, Math.PI * 2);
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    // NEW: Add Length for Segment
                    if (this.currentTool === 'segment') {
                        const dist = MathUtils.dist(start.x, start.y, end.x, end.y);
                        const val = (dist / UNIT).toFixed(1);
                        const mx = (start.x + end.x) / 2;
                        const my = (start.y + end.y) / 2;
                        let angle = Math.atan2(end.y - start.y, end.x - start.x);
                        if (angle > Math.PI / 2 || angle < -Math.PI / 2) angle += Math.PI;
                        this.ctx.save();
                        this.ctx.translate(mx, my);
                        this.ctx.rotate(angle);
                        const text = val;
                        const w = this.ctx.measureText(text).width + 8;
                        this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                        this.ctx.fillRect(-w / 2, -20, w, 16);
                        this.ctx.fillStyle = "#333";
                        this.ctx.font = "14px Segoe UI";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText(text, 0, -8);
                        this.ctx.restore();
                    }
                }

                // Angle Ghost
                if (this.currentTool === 'angle' && this.anglePoints.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#999";
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.moveTo(this.anglePoints[0].x, this.anglePoints[0].y);
                    if (this.anglePoints.length === 2) this.ctx.lineTo(this.anglePoints[1].x, this.anglePoints[1].y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.anglePoints.forEach(pt => {
                        this.ctx.beginPath();
                        this.ctx.fillStyle = "#333";
                        this.ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                }

                if (this.showTools && ['segment', 'ray', 'line'].includes(this.currentTool) && this.isDraggingCreation && this.creationStartPoint) {
                    this.drawRuler(this.ctx, this.creationStartPoint, this.mousePos);
                }
                if (!this.activeWidgets.setsquare && this.showTools && this.currentTool === 'perpendicular' && this.referenceObject && this.isDraggingCreation) {
                    this.drawPerpendicularHint(this.ctx, this.referenceObject, this.mousePos);
                }

                if (this.referenceObject && this.isDraggingCreation) {
                    const mouse = this.mousePos;
                    const ref = this.referenceObject;
                    const c = MathUtils.getLineCoords(ref);
                    const p1 = c.p1;
                    const p2 = c.p2;
                    if (p1 && p2) {
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        let color = "#444";
                        let width = 2;
                        if (this.currentTool === 'parallel') MathUtils.drawInfiniteLineFromVector(this.ctx, mouse.x, mouse.y, dx, dy, color, width, [5, 5]);
                        else MathUtils.drawInfiniteLineFromVector(this.ctx, mouse.x, mouse.y, -dy, dx, color, width, [5, 5]);
                        this.ctx.setLineDash([]);
                    }
                }

                if (this.activeWidgets.protractor && this.protractorWidget) this.protractorWidget.draw(this.ctx);
                if (this.activeWidgets.setsquare && this.setSquareWidget) this.setSquareWidget.draw(this.ctx);
                if (this.activeWidgets.ruler && this.rulerWidget) {
                    this.rulerWidget.draw(this.ctx);
                    // Draw Magnet Indicator only if hovering zero and active and NOT DRAGGING RULER
                    const l = this.rulerWidget.toLocal(this.mousePos.x, this.mousePos.y);
                    const startX = -20;

                    // Check if snapping for drawing (mouse is at 0) OR if just hovering near zero
                    if (['segment', 'line', 'ray'].includes(this.currentTool) && Math.abs(l.x) < 10 && Math.abs(l.y) < 10) {
                        const ang = this.rulerWidget.angle;
                        const zx = this.rulerWidget.x; //+ (-20) * Math.cos(ang);
                        const zy = this.rulerWidget.y; // + (-20) * Math.sin(ang);
                        this.ctx.beginPath();
                        this.ctx.moveTo(zx - 5, zy);
                        this.ctx.lineTo(zx + 5, zy);
                        this.ctx.moveTo(zx, zy - 5);
                        this.ctx.lineTo(zx, zy + 5);
                        this.ctx.strokeStyle = "red";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }

                // Visual indicators for SetSquare and Protractor Snapping to Points
                if (this.activeWidgets.setsquare && this.setSquareWidget) {
                    this.setSquareWidget.draw(this.ctx);
                    // If drawing near snap
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.setSquareWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 5 && Math.abs(l.y) < 5) {
                            const ang = this.setSquareWidget.angle;
                            const zx = this.setSquareWidget.x;
                            const zy = this.setSquareWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
                if (this.activeWidgets.protractor && this.protractorWidget) {
                    this.protractorWidget.draw(this.ctx);
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.protractorWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 5 && Math.abs(l.y) < 5) {
                            const zx = this.protractorWidget.x;
                            const zy = this.protractorWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
                // Compass snap
                if (this.activeWidgets.compass && this.compassWidget) {
                    // Check needle tip
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.compassWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 2 && Math.abs(l.y) < 2) {
                            const zx = this.compassWidget.x;
                            const zy = this.compassWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }

                    // Show snap indicator for resize if dragging knob
                    if (this.draggedWidget === this.compassWidget && this.draggedWidgetMode === 'resize') {
                        const snap = this.entities.filter(ent => ent instanceof Point).find(p => MathUtils.dist(this.mousePos.x, this.mousePos.y, p.x, p.y) < 15);
                        if (snap) {
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(snap.x, snap.y, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }

                // --- TRAC√â ASSIST√â DU RAPPORTEUR ---
                if (this.draggedWidget instanceof ProtractorWidget && this.draggedWidgetMode === 'traceAngle') {
                    const w = this.draggedWidget;
                    const start = {
                        x: w.x,
                        y: w.y
                    };
                    const end = this.mousePos;

                    const rawAngle = Math.atan2(end.y - start.y, end.x - start.x);

                    // 1. Ligne Rouge (On isole le style ici aussi par s√©curit√©)
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#e74c3c";
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(start.x + Math.cos(rawAngle) * 2000, start.y + Math.sin(rawAngle) * 2000);
                    this.ctx.stroke();
                    this.ctx.restore();

                    // 2. Calculs
                    let deg = (rawAngle - w.angle) * 180 / Math.PI;
                    while (deg < 0) deg += 360;
                    while (deg >= 360) deg -= 360;
                    if (deg > 180) deg = 360 - deg;

                    const val1 = Math.round(deg);
                    const val2 = 180 - val1;
                    let txt = ``;
                    if (w.isReversed) { txt = `${val1}¬∞ / ${val2}¬∞`; } else { txt = `${val2}¬∞ / ${val1}¬∞`; }
                    this.ctx.save();
                    this.ctx.font = "bold 14px Segoe UI";
                    this.ctx.textBaseline = "middle";
                    this.ctx.textAlign = "center";

                    const tw = this.ctx.measureText(txt).width;
                    const padding = 8;
                    const textDist = w.radius + 45;
                    const labelX = start.x + Math.cos(rawAngle) * textDist;
                    const labelY = start.y + Math.sin(rawAngle) * textDist;

                    // Fond blanc
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                    this.ctx.strokeStyle = "#e74c3c";
                    this.ctx.lineWidth = 1;
                    this.ctx.rect(labelX - tw / 2 - padding, labelY - 12, tw + padding * 2, 24);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Texte
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.fillText(txt, labelX, labelY);

                    // Centre
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.arc(start.x, start.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.restore(); // <--- ON REMET TOUT PROPRE
                }

            }

            render() {
                //  if (this.compassWidget) this.compassWidget.replayTrace = null;
                // 1. Reset de la matrice (pour effacer tout l'√©cran proprement)
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 2. Application de la Cam√©ra (Zoom/Pan)
                this.ctx.setTransform(this.view.zoom, 0, 0, this.view.zoom, this.view.x, this.view.y);

                // 3. Dessin de la grille (Adapt√©e √† la vue)
                this.drawGrid();
                if (this.isMagnetActive && this.activeSnapPoint) {
                    const snap = this.activeSnapPoint;
                    this.ctx.save();
                    // Halo orange
                    this.ctx.beginPath();
                    this.ctx.arc(snap.x, snap.y, 1, 0, Math.PI * 2);
                    this.ctx.fillStyle = "rgba(230, 126, 34, 0.4)";
                    this.ctx.fill();
                    this.ctx.strokeStyle = "#e67e22";
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();

                    // Point central rouge pr√©cis
                    this.ctx.beginPath();
                    this.ctx.arc(snap.x, snap.y, 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.fill();

                    this.ctx.restore();
                }
                const limit = (this.replayIndex !== null && this.replayIndex < this.entities.length) ? this.replayIndex : this.entities.length;

                const zIndex = {
                    'Polygon': 0,
                    'Angle': 0,
                    'CompassArc': 1,
                    'Arc': 1,
                    'Circle': 1,
                    'Line': 1,
                    'Ray': 1,
                    'Segment': 1,
                    'ParallelLine': 1,
                    'PerpendicularLine': 1,
                    'Point': 2
                };

                const toDraw = this.entities.slice(0, limit);
                toDraw.sort((a, b) => {
                    const zA = zIndex[a.constructor.name] || 0;
                    const zB = zIndex[b.constructor.name] || 0;
                    return zA - zB;
                });

                for (const entity of toDraw) {
                    if (entity instanceof ToolAnimation) continue;
                    if (entity.visible === false) continue;
                    if (this.isPlaying) {
                        const entityBeingCreated = this.entities[this.replayIndex + 1];

                        //     if (entity === entityBeingCreated && entity instanceof CompassArc) {
                        //         continue;
                        //    }
                    }
                    const isSelected = (entity === this.creationStartPoint) || (entity === this.referenceObject) || (entity === this.compassP1) || this.anglePoints.includes(entity);
                    const isHovered = this.hoveredEntities.includes(entity);
                    const isToDelete = this.toDeletePreview.includes(entity);
                    entity.draw(this.ctx, {
                        isSelected,
                        isHovered,
                        isToDelete
                    });
                }

                // Animation Encre
                if (this.isPlaying && this.isToolAnimating) {
                    const anim = this.entities[this.replayIndex];
                    //  console.log(this.entities[this.replayIndex]);
                    const nextIndex = this.replayIndex + 1;
                    if (nextIndex < this.entities.length) {
                        const nextEnt = this.entities[nextIndex];
                        const isTracing = nextEnt instanceof CompassArc;
                        if (anim instanceof ToolAnimation && anim.widgetType === 'compass' && isTracing && this.compassWidget) {
                            const w = this.compassWidget;
                            const sAngle = anim.startState.angle;
                            let drawEnd = w.angle;

                            // 2. On r√©cup√®re la VRAIE intention (le sens enregistr√©)
                            // C'est la seule v√©rit√© absolue.
                            const sens = nextEnt.counterClockwise;
                            if (this.ArcTracing) {

                                this.ctx.beginPath();

                                // 4. On dessine avec l'angle corrig√© "drawEnd"

                                this.ctx.arc(w.x, w.y, w.radius, sAngle, drawEnd, sens)
                                this.ctx.strokeStyle = "black"; // A CHANGER
                                this.ctx.lineWidth = 2;
                                this.ctx.stroke();
                            }
                            this.ArcTracing = true;
                        }
                        else { this.ArcTracing = false; }
                    }
                }

                this.drawCreationGhost();


                if (this.currentTool === 'polygon' && this.polygonPoints.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.polygonPoints[0].x, this.polygonPoints[0].y);
                    for (let i = 1; i < this.polygonPoints.length; i++) this.ctx.lineTo(this.polygonPoints[i].x, this.polygonPoints[i].y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.strokeStyle = "#00bcd4";
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.polygonPoints.forEach(p => p.draw(this.ctx, {}));
                }
                if (this.currentTool === 'angle') {
                    this.anglePoints.forEach(p => p.draw(this.ctx, {
                        isSelected: true
                    }));
                }

                if (this.ghostIntersection) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.ghostIntersection.x, this.ghostIntersection.y, 6, 0, Math.PI * 2);
                    this.ctx.fillStyle = "rgba(100, 100, 100, 0.5)";
                    this.ctx.fill();
                    this.ctx.strokeStyle = "#fff";
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
                const widgetMap = {
                    'ruler': this.rulerWidget,
                    'setsquare': this.setSquareWidget,
                    'protractor': this.protractorWidget,
                    'compass': this.compassWidget
                };

                // On dessine dans l'ordre de la liste (du bas vers le haut)
                this.widgetZOrder.forEach(type => {
                    if (this.activeWidgets[type] && widgetMap[type]) {
                        widgetMap[type].draw(this.ctx); // Ou ta m√©thode de dessin sp√©cifique
                    }
                });
            }

            exportSVG() {
                const getHex = (c) => (!c ? '#000000' : c);

                // 1. Pr√©-analyse : On collecte les motifs n√©cessaires par couleur
                // On utilise un Map pour ne pas cr√©er 50 fois le motif "Rouge"
                const definitions = new Map();

                this.entities.forEach(e => {
                    if (e instanceof Polygon && (e.fillMode === 'hatch' || e.fillMode === 'dots')) {
                        const color = getHex(e.color || '#000000');
                        const cleanColor = color.replace('#', ''); // ex: 2980b9

                        // ID unique par type et couleur (ex: hatch-2980b9)
                        const id = `${e.fillMode}-${cleanColor}`;

                        if (!definitions.has(id)) {
                            let patternDef = '';
                            if (e.fillMode === 'hatch') {
                                patternDef = `<pattern id="${id}" width="10" height="10" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                        <line x1="0" y1="0" x2="0" y2="10" stroke="${color}" stroke-width="1" />
                    </pattern>`;
                            } else if (e.fillMode === 'dots') {
                                patternDef = `<pattern id="${id}" width="6" height="6" patternUnits="userSpaceOnUse">
                        <circle cx="3" cy="3" r="1" fill="${color}" />
                    </pattern>`;
                            }
                            definitions.set(id, patternDef);
                        }
                    }
                });

                // 2. Construction des <defs>
                const defsContent = Array.from(definitions.values()).join('\n');

                // 3. En-t√™te SVG
                let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.canvas.width}" height="${this.canvas.height}" viewBox="0 0 ${this.canvas.width} ${this.canvas.height}" style="background:white">
    <defs>
        ${defsContent}
    </defs>`;

                // 4. Tri Z-Index
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'ParallelLine': 1, 'PerpendicularLine': 1, 'Point': 2, 'TextLabel': 2 };

                const toExport = this.entities.slice().sort((a, b) => {
                    const zA = zIndex[a.constructor.name] || 0;
                    const zB = zIndex[b.constructor.name] || 0;
                    return zA - zB;
                });

                toExport.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    if (!e.visible && e instanceof Point) return;

                    const color = getHex(e.color || 'black');
                    const width = e.lineWidth || 2;
                    const dash = e.dash && e.dash.length > 0 ? `stroke-dasharray="${e.dash.join(',')}"` : "";

                    // --- POLYGONES ---
                    if (e instanceof Polygon) {
                        const pts = e.points.map(p => `${p.x},${p.y}`).join(' ');
                        let fillAttr = `fill="${color}" fill-opacity="0.2"`; // D√©faut Solid

                        if (e.fillMode === 'none') {
                            fillAttr = 'fill="none"';
                        }
                        else if (e.fillMode === 'hatch' || e.fillMode === 'dots') {
                            const cleanColor = color.replace('#', '');
                            const id = `${e.fillMode}-${cleanColor}`;
                            // On appelle l'ID unique g√©n√©r√© plus haut
                            fillAttr = `fill="url(#${id})"`;
                        }

                        svgContent += `<polygon points="${pts}" ${fillAttr} stroke="${color}" stroke-width="1" ${dash} />`;
                    }

                    // --- POINTS ---
                    else if (e instanceof Point) {
                        const style = e.pointStyle || 'cross';
                        if (style === 'dot') svgContent += `<circle cx="${e.x}" cy="${e.y}" r="4" fill="${color}" stroke="${color}" stroke-width="1" />`;
                        else if (style === 'pixel') svgContent += `<rect x="${e.x - 2.5}" y="${e.y - 2.5}" width="5" height="5" fill="${color}" stroke="${color}" stroke-width="1" />`;
                        else svgContent += `<path d="M${e.x - 3} ${e.y - 3} L${e.x + 3} ${e.y + 3} M${e.x + 3} ${e.y - 3} L${e.x - 3} ${e.y + 3}" stroke="${color}" stroke-width="${width > 2 ? width : 2}" stroke-linecap="round"/>`;

                        if (e.label && e.showLabel) {
                            const fs = e.fontSize || 14;
                            const angle = (e.labelAngle !== undefined) ? e.labelAngle : -Math.PI / 4;
                            const dist = 12 + fs / 2;
                            const lx = e.x + Math.cos(angle) * dist;
                            const ly = e.y + Math.sin(angle) * dist;
                            svgContent += `<text x="${lx}" y="${ly}" font-family="Arial" font-weight="bold" font-size="${fs}" fill="black" text-anchor="middle" dominant-baseline="middle">${e.label}</text>`;
                        }
                    }

                    // --- TEXTE ---
                    else if (e instanceof TextLabel) {
                        const safeText = e.text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        // On utilise les vraies valeurs
                        const fs = e.fontSize || 16;
                        // Nettoyage sommaire de la font family pour le SVG (enlever les ' superflus parfois)
                        const ff = (e.fontFamily || 'Segoe UI').replace(/'/g, "");

                        svgContent += `<text x="${e.x}" y="${e.y}" font-family="${ff}" font-size="${fs}" fill="${color}" text-anchor="middle" dominant-baseline="middle">${safeText}</text>`;
                    }

                    // --- LIGNES ---
                    else if (e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        const c = MathUtils.getLineCoords(e);
                        if (c.p1 && c.p2) {
                            let x1 = c.p1.x, y1 = c.p1.y, x2 = c.p2.x, y2 = c.p2.y;
                            if (e instanceof Line || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                                const dx = x2 - x1, dy = y2 - y1;
                                x1 -= dx * 100; y1 -= dy * 100; x2 += dx * 100; y2 += dy * 100;
                            } else if (e instanceof Ray) {
                                const dx = x2 - x1, dy = y2 - y1;
                                x2 += dx * 100; y2 += dy * 100;
                            }
                            svgContent += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${color}" stroke-width="${width}" ${dash} stroke-linecap="round" />`;

                            if (e instanceof Segment) {
                                const mx = (c.p1.x + c.p2.x) / 2;
                                const my = (c.p1.y + c.p2.y) / 2;
                                const angleDeg = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x) * 180 / Math.PI;

                                if (e.coding && e.coding !== 'mark-none') {
                                    let pathData = "";
                                    const h = 6;
                                    if (e.coding === 'mark-1') pathData = `M 0 -${h} L 0 ${h}`;
                                    else if (e.coding === 'mark-2') pathData = `M -2 -${h} L -2 ${h} M 2 -${h} L 2 ${h}`;
                                    else if (e.coding === 'mark-3') pathData = `M -4 -${h} L -4 ${h} M 0 -${h} L 0 ${h} M 4 -${h} L 4 ${h}`;
                                    else if (e.coding === 'mark-x') pathData = `M -4 -4 L 4 4 M -4 4 L 4 -4`;
                                    else if (e.coding === 'mark-xx') pathData = `M -8 -3 L -2 3 M -8 3 L -2 -3 M 2 -3 L 8 3 M 2 3 L 8 -3`;

                                    if (pathData) svgContent += `<path d="${pathData}" stroke="${color}" stroke-width="2" fill="none" transform="translate(${mx},${my}) rotate(${angleDeg})" />`;

                                    if (e.coding === 'mark-o') svgContent += `<circle cx="0" cy="0" r="4" stroke="${color}" stroke-width="2" fill="none" transform="translate(${mx},${my})" />`;
                                    else if (e.coding === 'mark-oo') svgContent += `<g transform="translate(${mx},${my}) rotate(${angleDeg})"><circle cx="-5" cy="0" r="3" stroke="${color}" stroke-width="2" fill="none"/><circle cx="5" cy="0" r="3" stroke="${color}" stroke-width="2" fill="none"/></g>`;
                                }

                                if (e.showLength) {
                                    const dist = MathUtils.dist(c.p1.x, c.p1.y, c.p2.x, c.p2.y);
                                    const val = (dist / UNIT).toFixed(1);
                                    let angleRad = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);
                                    let off = e.measureOffset;
                                    if (Math.abs(angleRad) > Math.PI / 2) { angleRad += Math.PI; off = -off; }
                                    const txtAngle = angleRad * 180 / Math.PI;
                                    svgContent += `<rect x="-15" y="${off - 10}" width="30" height="16" fill="white" fill-opacity="0.8" transform="translate(${mx},${my}) rotate(${txtAngle})" />`;
                                    svgContent += `<text x="0" y="${off}" font-family="Segoe UI" font-size="14" fill="${color}" text-anchor="middle" dominant-baseline="middle" transform="translate(${mx},${my}) rotate(${txtAngle})">${val}</text>`;
                                }
                            }
                        }
                    }

                    // --- CERCLES & ARCS ---
                    else if (e instanceof Circle || e instanceof CompassCircle) {
                        const p1 = e.p1 || e.center;
                        const radius = (e.getRadius) ? e.getRadius() : MathUtils.dist(e.p1.x, e.p1.y, e.p2.x, e.p2.y);
                        if (p1) svgContent += `<circle cx="${p1.x}" cy="${p1.y}" r="${radius}" stroke="${color}" stroke-width="${width}" ${dash} fill="none" />`;
                    }
                    else if (e instanceof Arc || e instanceof CompassArc) {
                        if (e.center) {
                            const startX = e.center.x + e.radius * Math.cos(e.startAngle);
                            const startY = e.center.y + e.radius * Math.sin(e.startAngle);
                            const endX = e.center.x + e.radius * Math.cos(e.endAngle);
                            const endY = e.center.y + e.radius * Math.sin(e.endAngle);
                            let diff = e.endAngle - e.startAngle;
                            if (e.counterClockwise) { if (diff > 0) diff -= 2 * Math.PI; }
                            else { if (diff < 0) diff += 2 * Math.PI; }
                            const largeArc = Math.abs(diff) > Math.PI ? 1 : 0;
                            const sweep = e.counterClockwise ? 0 : 1;
                            svgContent += `<path d="M ${startX} ${startY} A ${e.radius} ${e.radius} 0 ${largeArc} ${sweep} ${endX} ${endY}" stroke="${color}" stroke-width="${width}" ${dash} fill="none" />`;
                        }
                    }

                    // --- ANGLES ---
                    else if (e instanceof Angle && e.p1 && e.p2 && e.p3) {
                        const val = e.getAngleValue();
                        const isRight = Math.abs(val - 90) < 0.5;
                        const radius = 25;
                        const a1 = Math.atan2(e.p1.y - e.p2.y, e.p1.x - e.p2.x);
                        const a2 = Math.atan2(e.p3.y - e.p2.y, e.p3.x - e.p2.x);

                        let fillAttr = 'fill="none"';
                        if (e.isFilled) fillAttr = `fill="${e.color ? e.color : 'green'}" fill-opacity="0.3"`;

                        if (isRight) {
                            const size = 16;
                            const d1 = MathUtils.dist(e.p2.x, e.p2.y, e.p1.x, e.p1.y);
                            const d2 = MathUtils.dist(e.p2.x, e.p2.y, e.p3.x, e.p3.y);
                            const ux = (e.p1.x - e.p2.x) / d1 * size, uy = (e.p1.y - e.p2.y) / d1 * size;
                            const vx = (e.p3.x - e.p2.x) / d2 * size, vy = (e.p3.y - e.p2.y) / d2 * size;
                            svgContent += `<path d="M ${e.p2.x + ux} ${e.p2.y + uy} L ${e.p2.x + ux + vx} ${e.p2.y + uy + vy} L ${e.p2.x + vx} ${e.p2.y + vy} L ${e.p2.x} ${e.p2.y} Z" stroke="${color}" stroke-width="${width}" ${fillAttr} />`;
                        } else {
                            const startX = e.p2.x + radius * Math.cos(a1);
                            const startY = e.p2.y + radius * Math.sin(a1);
                            const endX = e.p2.x + radius * Math.cos(a2);
                            const endY = e.p2.y + radius * Math.sin(a2);
                            let diff = a2 - a1;
                            if (e.isCounterClockwise) { if (diff < 0) diff += 2 * Math.PI; }
                            else { if (diff > 0) diff -= 2 * Math.PI; }
                            const largeArc = Math.abs(diff) > Math.PI ? 1 : 0;
                            const sweep = e.isCounterClockwise ? 1 : 0;
                            svgContent += `<path d="M ${e.p2.x} ${e.p2.y} L ${startX} ${startY} A ${radius} ${radius} 0 ${largeArc} ${sweep} ${endX} ${endY} Z" stroke="${color}" stroke-width="${width}" ${fillAttr} />`;
                        }
                        if (e.showValue && !isRight) {
                            let diff = a2 - a1;
                            if (e.isCounterClockwise) { if (diff < 0) diff += 2 * Math.PI; }
                            else { if (diff > 0) diff -= 2 * Math.PI; }
                            const midA = a1 + diff / 2;
                            const txtX = e.p2.x + (radius + 20) * Math.cos(midA);
                            const txtY = e.p2.y + (radius + 20) * Math.sin(midA);
                            const txtVal = Math.round(val) + "¬∞";
                            svgContent += `<rect x="${txtX - 15}" y="${txtY - 8}" width="30" height="16" fill="white" fill-opacity="0.7" rx="2" />`;
                            svgContent += `<text x="${txtX}" y="${txtY}" font-family="Segoe UI" font-size="12" font-weight="bold" fill="${color}" text-anchor="middle" dominant-baseline="middle">${txtVal}</text>`;
                        }
                    }
                });

                svgContent += `</svg>`;
                const blob = new Blob([svgContent], { type: "image/svg+xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // Remplace : a.download = "figure_geosoft.svg";
                // Par :
                a.download = this.getSafeFilename('svg');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                this.showToast("‚úíÔ∏è Fichier SVG export√© !");
            }
        }
        const app = new GeometrieApp("geoCanvas");
        window.app = app;

    </script>
</body>

</html>
