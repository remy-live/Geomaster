<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©oMaster</title>
    <style>
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #333;
            margin-top: -6px;
        }

        input[type="range"]::-moz-range-thumb {
            border: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #333;
        }

        input[type="range"]:focus {
            outline: none;
        }

        .editor-toolbar {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
            width: 100%;
        }

        #fontFamilyInput {
            flex: 2;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px;
            font-size: 12px;
            outline: none;
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
        }

        #fontSizeInput {
            flex: 1;
            width: 50px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 12px;
            outline: none;
            background: rgba(255, 255, 255, 0.95);
        }

        #textEditor {
            background: transparent;
            padding: 6px;
            border-radius: 8px;
            position: absolute;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            transform: translate(-50%, -50%);
            border: none;
            box-shadow: none;
        }

        #textInput {
            border: 1px dashed #2980b9;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            padding: 4px 8px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 16px;
            text-align: center;
            outline: none;
            width: 140px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #textInput:focus {
            border-color: #1976d2;
            border-style: solid;
        }

        .editor-buttons {
            display: flex;
            gap: 4px;
            background: white;
            padding: 3px;
            border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        .editor-buttons button {
            border: none;
            background: #f0f2f5;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
        }

        .editor-buttons button:hover {
            transform: scale(1.1);
        }

        #btnTextSave {
            color: white;
            background: #27ae60;
        }

        #btnTextCancel {
            color: #c0392b;
            background: #fff;
            border: 1px solid #eee;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #eef2f5;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        header {
            background-color: #ffffff;
            height: 50px;
            padding: 0 15px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-dropdown {
            position: relative;
            display: flex;
            align-items: center;
            height: 100%;
        }

        .header-dropdown-content {
            display: none;
            position: absolute;
            top: 90%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 5000;
            flex-direction: column;
            gap: 4px;
            min-width: 40px;
            align-items: center;
        }

        .header-dropdown:hover .header-dropdown-content {
            display: flex;
            animation: fadeIn 0.2s;
        }

        .header-dropdown .top-btn::after {
            content: '‚ñæ';
            font-size: 10px;
            margin-left: 2px;
            color: #999;
            position: absolute;
            bottom: 2px;
            right: 2px;
        }

        .logo {
            font-weight: 800;
            font-size: 18px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            margin-right: 4px;
            background: linear-gradient(45deg, #51728e, #51115c);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .top-toolbar {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding-right: 8px;
            margin-right: 8px;
            border-right: 1px solid #eee;
        }

        .toolbar-group:last-child {
            border: none;
            padding-right: 0;
            margin-right: 0;
        }

        .top-btn {
            width: 34px;
            height: 34px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .top-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2px;
        }

        .top-btn:hover {
            background: #f0f0f0;
            color: #000;
            border-color: #e0e0e0;
        }

        .top-btn:active {
            transform: scale(0.95);
        }

        .top-btn.active {
            background: #222;
            color: #fff;
            border-color: #222;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .top-btn.danger:hover {
            background: #fff0f0;
            color: #d32f2f;
            border-color: #ffcdd2;
        }

        .top-btn:disabled {
            opacity: 0.2;
            cursor: default;
        }

        .top-btn span.icon {
            font-size: 16px;
        }

        #fileInput {
            display: none;
        }

        .main-container {
            display: flex;
            flex: 1;
            height: calc(100% - 50px);
            position: relative;
        }

        .toolbar {
            width: 90px;
            min-width: 90px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 8px;
            align-content: start;
            padding: 12px 8px;

            z-index: 10;
            overflow-y: auto;
            overflow: visible !important;
            gap: 4px;
            padding-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .group-label {
            grid-column: span 2;
            font-size: 9px;
            color: #8898aa;
            margin-top: 12px;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-weight: 700;
            width: 100%;
            text-align: center;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 4px;
            display: none
        }

        .tool-sep {
            grid-column: span 2;
            height: 1px;
            background-color: #f0f0f0;
            margin: 4px 0;
        }

        .tool-btn {
            position: relative;
            width: 100%;
            height: 42px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #546e7a;
            transition: all 0.2s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .tool-btn svg {
            width: 22px;
            height: 22px;
        }

        .tool-btn:hover {
            background: #f8f9fa;
            color: #2c3e50;
            border-color: #cfd8dc;
            transform: translateY(-1px);
            z-index: 1000;
        }

        .tool-btn.active {
            background-color: #e3f2fd;
            color: #1976d2;
            border-color: #90caf9;
        }

        .tool-btn.widget-active {
            background-color: #fff3e0;
            color: #e67e22;
            border-color: #ffe0b2;
            box-shadow: inset 0 0 0 2px #ffe0b2;
        }

        .tool-btn.delete-btn {
            color: #e74c3c;
        }

        .tool-btn.delete-btn:hover {
            background: #ffebee;
            border-color: #ffcdd2;
            color: #c0392b;
        }

        .tool-btn.delete-btn.active {
            background-color: #ffebee;
            color: #d32f2f;
            border-color: #ffcdd2;
        }

        .tool-btn:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 10px;
            background: #2c3e50;
            color: white;
            padding: 5px 10px;
            font-size: 11px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .justify-center {
            justify-content: center;
        }

        .canvas-container {
            flex-grow: 1;
            width: 0;
            background-color: #f5f7fa;
            display: block;
            position: relative;
            overflow: hidden;
            height: 100%;
        }

        .tool-btn.export-btn {
            flex-direction: column;
            gap: 0px;
            padding: 2px;
            height: 42px;
        }

        .tool-btn.export-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 1.5;
        }

        .tool-btn.export-btn span {
            font-size: 9px;
            font-weight: 800;
            line-height: 1;
            color: #555;
            text-transform: uppercase;
        }

        .tool-btn.simple-icon {
            border: none;
            background: transparent;
            padding: 4px;
        }

        .tool-btn.simple-icon:hover {
            background-color: transparent;
            color: #2980b9;
        }

        .tool-btn.export-btn:hover span {
            color: #2980b9;
        }

        canvas {
            display: block;
            background-color: #ffffff;
            box-shadow: none;
            border-radius: 0;
        }

        #replayBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding: 8px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s;
        }

        .replay-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            border-right: 1px solid #ddd;
            padding-right: 15px;
        }

        .replay-control-group:last-child {
            border-right: none;
            padding-right: 0;
        }

        .replay-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: #555;
            padding: 5px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }

        .replay-btn:hover {
            background: #eee;
            color: #222;
            transform: scale(1.1);
        }

        .replay-btn.active {
            color: #2980b9;
            background: #e3f2fd;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .slider-container input {
            width: 80px;
            margin: 0;
            cursor: pointer;
        }

        .slider-icon {
            font-size: 8px;
            position: relative;
            top: -5px;
            color: #888;
            text-transform: uppercase;
            font-weight: bold;
        }

        body.interface-locked .toolbar,
        body.interface-locked .top-toolbar,
        body.interface-locked #contextMenu,
        body.interface-locked #textEditor {
            pointer-events: none;
            opacity: 0.5;
            filter: grayscale(0.8);
        }

        body.interface-locked canvas {
            cursor: not-allowed !important;
        }

        #contextMenu {
            display: none;
            position: fixed;
            z-index: 3000;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            padding: 10px;
            width: 190px;
            flex-direction: column;
            gap: 8px;
            animation: popIn 0.15s ease-out;
        }

        .menu-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 2px;
            flex-wrap: wrap;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            flex: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #444;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: #fff;
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-color: #bdc3c7;
        }

        .icon-btn.active {
            background: #2980b9;
            color: white;
            border-color: #2980b9;
        }

        .icon-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .icon-btn.trash {
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.2);
            background: rgba(231, 76, 60, 0.05);
            width: 100%;
        }

        .icon-btn.trash:hover {
            background: #ffebee;
            color: white;
        }

        .compact-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            appearance: none;
            background: #ddd;
            outline: none;
            max-width: 80px;
        }

        .compact-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #555;
            cursor: pointer;
        }

        .coding-grid {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr) !important;
            gap: 6px !important;
            width: 100%;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }

        .mark-btn {
            width: 100%;
            height: 32px;
            border-radius: 4px;
            background: #fff;
            border: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
        }

        .mark-btn:hover {
            background: #e3f2fd;
            border-color: #90caf9;
        }

        .mark-btn svg {
            width: 20px;
            height: 20px;
            stroke-width: 2.5px;
            stroke-linecap: round;
        }

        #rowAngle.menu-row {
            display: flex !important;
            flex-direction: row !important;
            justify-content: center !important;
            flex-wrap: nowrap !important;
        }

        .switch-container {
            display: flex;
            background-color: #eef2f5;
            padding: 4px;
            border-radius: 8px;
            gap: 2px;
            margin-bottom: 6px;
            border: 1px solid #e0e0e0;
        }

        .switch-btn {
            flex: 1;
            height: 28px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .switch-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            color: #555;
        }

        .switch-btn.active {
            background-color: #fff;
            color: #2980b9;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }

        .switch-btn svg {
            width: 18px;
            height: 18px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .btn-trash {
            width: 100%;
            margin-top: 4px;
            background: #fff0f0;
            color: #d32f2f;
            border: 1px solid #ffcdd2;
        }

        .btn-trash:hover {
            background: #ffebee;
            border-color: #e57373;
        }

        .label-positioner {
            width: 60px;
            height: 60px;
            margin: 0 auto;
            position: relative;
            border-radius: 50%;
            background: #f8f9fa;
            border: 1px solid #ddd;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
            cursor: crosshair;
        }

        .label-cross {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .label-cross::before {
            content: '';
            position: absolute;
            background: #ccc;
            width: 100%;
            height: 2px;
            top: 4px;
            left: 0;
        }

        .label-cross::after {
            content: '';
            position: absolute;
            background: #ccc;
            width: 2px;
            height: 100%;
            top: 0;
            left: 4px;
        }

        .label-knob {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #2980b9;
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: grab;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .label-knob:active {
            cursor: grabbing;
            background: #e67e22;
        }

        .label-preview {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 10px;
            color: #999;
            font-weight: bold;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .color-dot {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .color-dot:hover {
            transform: scale(1.2);
            z-index: 2;
        }

        .sep-h {
            width: 100%;
            height: 1px;
            background: rgba(0, 0, 0, 0.08);
            margin: 4px 0;
        }

        .vis-line {
            width: 18px;
            background: #444;
            border-radius: 1px;
        }

        .s-solid {
            height: 2px;
        }

        .s-dashed {
            height: 2px;
            border-bottom: 2px dashed #444;
            background: transparent;
        }

        .w-thin {
            height: 1px;
        }

        .w-med {
            height: 3px;
        }

        .w-thick {
            height: 5px;
        }

        .toggle-btn {
            background: #fff;
            border: 1px solid #ddd;
            padding: 6px;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            box-sizing: border-box;
        }

        .toggle-btn:hover {
            background: #f9f9f9;
            border-color: #ccc;
        }

        .toggle-btn.active {
            background: #e3f2fd;
            color: #1976d2;
            border-color: #2196f3;
        }

        .cursor-move {
            cursor: move;
        }

        .cursor-grab {
            cursor: grab;
        }

        .cursor-grabbing {
            cursor: grabbing;
        }

        .cursor-ew {
            cursor: ew-resize;
        }

        .v-keyboard {
            display: none;
            position: absolute;
            z-index: 3000;
            width: 420px;
            background: rgba(230, 235, 240, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            flex-direction: column;
            gap: 4px;
            user-select: none;
        }

        .v-keyboard.visible {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .vk-drag-handle {
            width: 100%;
            height: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            margin-bottom: 2px;
        }

        .vk-drag-handle:active {
            cursor: grabbing;
        }

        .vk-drag-handle::after {
            content: '';
            width: 40px;
            height: 4px;
            background-color: #cbd5e1;
            border-radius: 2px;
        }

        .vk-row {
            display: flex;
            justify-content: center;
            gap: 3px;
        }

        .vk-btn {
            height: 28px;
            flex: 1;
            min-width: 24px;
            background: #fff;
            border: 1px solid #dae1e7;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.05);
        }

        .vk-btn:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .vk-btn:active {
            transform: translateY(1px);
            background: #e2e8f0;
        }

        .vk-btn.special {
            background: #cbd5e1;
            color: #334155;
            font-size: 11px;
            max-width: 40px;
        }

        .vk-btn.space {
            flex: 4;
        }

        .vk-btn.active-shift {
            background: #3b82f6;
            color: white;
            border-color: #2563eb;
        }

        .drag-handle {
            width: 100%;
            height: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            margin-bottom: 4px;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle::after {
            content: '';
            width: 40px;
            height: 4px;
            background-color: rgba(0, 0, 0, 0.15);
            border-radius: 2px;
        }

        .renamer-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 2px;
            margin-bottom: 6px;
        }

        .renamer-display {
            flex: 1;
            text-align: center;
            font-weight: 800;
            font-size: 16px;
            color: #2c3e50;
            cursor: ns-resize;
            user-select: none;
            height: 28px;
            line-height: 28px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .renamer-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .renamer-btn:hover {
            background: #e3f2fd;
            color: #1976d2;
        }

        .renamer-btn:active {
            transform: scale(0.95);
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 5000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s;
        }

        .modal-box {
            background: white;
            padding: 20px 25px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            transform: scale(0.95);
            animation: popIn 0.2s forwards;
        }

        .modal-text {
            font-size: 16px;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            border: none;
            font-family: inherit;
            transition: transform 0.1s;
        }

        .modal-btn:active {
            transform: scale(0.95);
        }

        .modal-cancel {
            background: #f0f2f5;
            color: #555;
        }

        .modal-cancel:hover {
            background: #e4e6eb;
        }

        .modal-confirm {
            background: #3498db;
            color: white;
        }

        .modal-confirm:hover {
            background: #2980b9;
        }

        .modal-confirm.danger {
            background: #e74c3c;
        }

        .modal-confirm.danger:hover {
            background: #c0392b;
        }

        .header-color-row {
            display: flex;
            gap: 2px;
            margin-right: 8px;
            background: #f5f5f5;
            padding: 2px;
            border-radius: 12px;
            border: 1px solid #eee;
        }

        .header-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: transform 0.1s;
        }

        .header-dot:hover {
            transform: scale(1.2);
            z-index: 2;
        }

        .header-dot.active {
            border: 2px solid #000;
        }

        #docTitleInput {
            width: 100px;
            padding: 6px 6px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            outline: none;
        }

        #docTitleInput:hover {
            background: #fff;
            border-color: #b0bec5;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        #docTitleInput:focus {
            background: #fff;
            border-color: #2196f3;
            color: #000;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
            width: 160px;
        }

        .help-box {
            width: 500px;
            max-width: 95%;
            text-align: left;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: 85vh;
        }

        .help-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .help-header h2 {
            margin: 0;
            font-size: 18px;
            color: #2c3e50;
        }

        .close-help {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #7f8c8d;
        }

        .close-help:hover {
            color: #c0392b;
        }

        .help-content {
            padding: 20px;
            overflow-y: auto;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            font-size: 14px;
            text-transform: uppercase;
            color: #2980b9;
            border-bottom: 2px solid #e3f2fd;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .help-section p,
        .help-section li {
            font-size: 14px;
            color: #444;
            line-height: 1.5;
        }

        .help-footer {
            background: #f8f9fa;
            padding: 10px;
            text-align: center;
            font-size: 11px;
            color: #95a5a6;
            border-top: 1px solid #eee;
        }

        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            box-shadow: 0 1px 1px rgba(0, 0, 0, .2), 0 2px 0 0 rgba(255, 255, 255, .7) inset;
            color: #333;
            display: inline-block;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
            padding: 2px 4px;
            white-space: nowrap;
            font-family: monospace;
        }

        .shortcut-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .sc-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #555;
        }

        #instructionBox {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 300px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 200px;
        }

        .instr-header {
            background: #f1f3f4;
            padding: 8px 12px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            font-weight: bold;
            color: #555;
            font-size: 13px;
            user-select: none;
        }

        .instr-close {
            border: none;
            background: none;
            cursor: pointer;
            font-weight: bold;
            color: #999;
        }

        .instr-close:hover {
            color: red;
        }

        .instr-toolbar {
            display: flex;
            padding: 4px;
            background: #fff;
            border-bottom: 1px solid #eee;
            gap: 2px;
            flex-wrap: wrap;
        }

        .instr-toolbar button {
            border: 1px solid transparent;
            background: white;
            cursor: pointer;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            color: #444;
        }

        .instr-toolbar button:hover {
            background: #f0f0f0;
            border-color: #ddd;
        }

        .instr-sep {
            width: 1px;
            background: #ddd;
            margin: 0 4px;
        }

        #instrContent {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            outline: none;
            line-height: 1.5;
            color: #333;
            max-height: 400px;
        }

        #instrContent h3 {
            margin-top: 0;
            font-size: 16px;
            color: #2980b9;
            border-bottom: 2px solid #eee;
            padding-bottom: 4px;
        }

        #instrContent ul {
            padding-left: 20px;
            margin: 5px 0;
        }

        #toast-notification {
            visibility: hidden;
            min-width: 250px;
            background-color: rgba(44, 62, 80, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 50px;
            padding: 12px 24px;
            position: fixed;
            z-index: 6000;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
        }

        #toast-notification.show {
            visibility: visible;
            opacity: 1;
            bottom: 50px;
        }

        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            background: #222;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: sans-serif;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease-out;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
            z-index: 10000;
            transition-delay: 0.5s;
        }
    </style>
</head>

<div id="helpModal" class="modal-overlay" onclick="if(event.target === this) app.toggleHelp()">
    <div class="modal-box help-box">
        <div class="help-header">
            <h2>Guide Rapide G√©oSoft</h2>
            <button class="close-help" onclick="app.toggleHelp()">‚úï</button>
        </div>
        <div class="help-content">

            <div class="help-section">
                <h3>üñ±Ô∏è Souris & Interaction</h3>
                <p><strong>Clic Gauche :</strong> S√©lectionner, D√©placer, Cr√©er des points.</p>
                <p><strong>Clic Droit :</strong> Menu Contextuel (Couleur, √âpaisseur, Hachures, Nom).</p>
                <p><strong>Molette :</strong> Zoomer / D√©zoomer.</p>
                <p><strong>Clic Molette (ou Espace + Glisser) :</strong> Bouger la feuille (Pan).</p>
            </div>

            <div class="help-section">
                <h3>‚å®Ô∏è Raccourcis Clavier</h3>
                <div class="shortcut-grid">
                    <div class="sc-row"><kbd>Ctrl</kbd> + <kbd>Z</kbd> <span>Annuler</span></div>
                    <div class="sc-row"><kbd>Ctrl</kbd> + <kbd>Y</kbd> <span>R√©tablir</span></div>
                    <div class="sc-row"><kbd>Suppr</kbd> <span>Supprimer la s√©lection</span></div>
                    <div class="sc-row"><kbd>Echap</kbd> <span>Annuler l'outil / D√©s√©lectionner</span></div>
                    <div class="sc-row"><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> <span>D√©placement pr√©cis
                            (1px)</span></div>
                </div>
            </div>

            <div class="help-section">
                <h3>üí° Astuces Outils</h3>
                <ul style="text-align: left; padding-left: 20px; margin: 5px 0;">
                    <li><strong>R√®gle / Rapporteur :</strong> Cliquez au centre pour d√©placer, sur les bords pour
                        tourner.</li>
                    <li><strong>Compas :</strong> Tirez la branche crayon pour √©carter. Cliquez sur la poign√©e haute
                        pour tourner.</li>
                    <li><strong>Polygone :</strong> Cliquez sur le 1er point pour fermer la forme.</li>
                    <li><strong>Sym√©trie :</strong> Cliquez d'abord sur l'objet √† transformer, puis sur l'axe (ou le
                        centre).</li>
                </ul>
            </div>

        </div>

        <div class="help-footer">
            G√©omaster v1.0 - Logiciel de G√©om√©trie Dynamique par DEVODDERE R√©my
        </div>
    </div>
</div>
<div id="instructionBox" style="display:none;">
    <div class="instr-header" id="instrDragHandle">
        <span>üìù Consignes</span>
        <button class="instr-close" onclick="app.toggleInstructions()">‚úï</button>
    </div>

    <div class="instr-toolbar">
        <button onmousedown="event.preventDefault(); document.execCommand('bold', false, null);"
            title="Gras"><b>B</b></button>
        <button onmousedown="event.preventDefault(); document.execCommand('italic', false, null);"
            title="Italique"><i>I</i></button>
        <button onmousedown="event.preventDefault(); document.execCommand('underline', false, null);"
            title="Soulign√©"><u>U</u></button>
        <div class="instr-sep"></div>
        <button onmousedown="event.preventDefault(); document.execCommand('insertUnorderedList', false, null);"
            title="Liste √† puces">‚Ä¢ Liste</button>
        <button onmousedown="event.preventDefault(); document.execCommand('formatBlock', false, '<h3>');"
            title="Titre">Titre</button>
        <button onmousedown="event.preventDefault(); document.execCommand('removeFormat', false, null);"
            title="Effacer style">üßπ</button>
    </div>

    <div id="instrContent" contenteditable="true" placeholder="√âcrivez vos consignes ici...">
        <h3>Exercice :</h3>
        <p>1. Tracez un triangle...</p>
    </div>
</div>
<div id="toast-notification">Message par d√©faut</div>

<body>
    <header>
        <div class="logo">G√©omaster</div>

        <input type="text" id="docTitleInput" value="Sans titre" placeholder="Nom du projet..."
            aria-label="Renommer le projet" data-tooltip="Renommer le projet">

        <div class="top-toolbar">

            <div class="toolbar-group">
                <button class="top-btn" id="btnPan" onclick="app.togglePanMode()"
                    aria-label="D√©placer la feuille (Main)" data-tooltip="D√©placer la feuille (Main)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" />
                        <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" />
                        <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
                        <path
                            d="M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
                    </svg>
                </button>
                <button class="top-btn" onclick="app.resetView()" aria-label="Recentrer la vue (100%)"
                    data-tooltip="Recentrer la vue (100%)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="10" />
                        <circle cx="12" cy="12" r="3" />
                        <line x1="22" y1="12" x2="18" y2="12" />
                        <line x1="6" y1="12" x2="2" y2="12" />
                        <line x1="12" y1="6" x2="12" y2="2" />
                        <line x1="12" y1="22" x2="12" y2="18" />
                    </svg>
                </button>
            </div>

            <div class="toolbar-group">
                <button class="top-btn danger" onclick="app.clearAll()" aria-label="Tout effacer"
                    data-tooltip="Tout effacer">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <polyline points="3 6 5 6 21 6" />
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                        <line x1="10" y1="11" x2="10" y2="17" />
                        <line x1="14" y1="11" x2="14" y2="17" />
                    </svg>
                </button>

                <button class="top-btn" onclick="document.getElementById('fileInput').click()"
                    aria-label="Ouvrir un fichier" data-tooltip="Ouvrir un fichier">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
                    </svg>
                </button>
                <input type="file" id="fileInput" accept=".geo" onchange="app.loadFile(this)">

                <button class="top-btn" onclick="app.saveFile()" aria-label="Sauvegarder" data-tooltip="Sauvegarder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                        <polyline points="17 21 17 13 7 13 7 21" />
                        <polyline points="7 3 7 8 15 8" />
                    </svg>
                </button>

                <button class="top-btn" onclick="app.exportSVG()" aria-label="Exporter en SVG"
                    data-tooltip="Exporter en SVG">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" y1="15" x2="12" y2="3" />
                    </svg>
                </button>

                <button class="top-btn" onclick="app.exportImage('png')" aria-label="Exporter l'image (PNG)"
                    data-tooltip="Exporter l'image (PNG)">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                </button>

                <button class="top-btn" id="btnCopy" onclick="app.copyToClipboard()"
                    aria-label="Copier la figure (Presse-papier)" data-tooltip="Copier la figure (Presse-papier)">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>
            </div>


            <div class="toolbar-group">
                <button class="top-btn" id="btnGrid" onclick="app.toggleGrid()" aria-label="Changer de Grille"
                    data-tooltip="Changer de Grille">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                        <line x1="3" y1="9" x2="21" y2="9" />
                        <line x1="3" y1="15" x2="21" y2="15" />
                        <line x1="9" y1="3" x2="9" y2="21" />
                        <line x1="15" y1="3" x2="15" y2="21" />
                    </svg>
                </button>
                <button class="top-btn" id="btnMagnet" onclick="app.toggleMagnet()" aria-label="Aimantation (Grille)"
                    data-tooltip="Aimantation (Grille)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M3 14v-9h4v9a5 5 0 0 0 10 0v-9h4v9a9 9 0 0 1-18 0Z" fill="currentColor"
                            fill-opacity="0.2" />
                        <line x1="3" y1="9" x2="7" y2="9" />
                        <line x1="17" y1="9" x2="21" y2="9" />
                    </svg>
                </button>
                <button class="top-btn" onclick="app.autoCodeSegments()" aria-label="Codage Automatique des longueurs"
                    data-tooltip="Codage Automatique des longueurs">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="m17 6 1 3 3 0.5-2.5 2 1 3L17 13l-2.5 1.5 1-3L13 9.5l3-0.5z" />
                        <path d="M15 12 4 22" />
                    </svg>
                </button>
            </div>

            <div class="toolbar-group">
                <div class="header-dropdown">
                    <button class="top-btn" aria-label="Style du Point" data-tooltip="Style du Point">
                        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none">
                            <circle cx="12" cy="12" r="3" fill="currentColor" />
                            <circle cx="12" cy="12" r="8" />
                        </svg>
                    </button>

                    <div class="header-dropdown-content">
                        <div class="icon-btn" id="btnPtCross" onclick="app.setGlobalPointStyle('cross')"
                            aria-label="Croix" data-tooltip="Croix">
                            <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="3" fill="none">
                                <path d="M6 6l12 12M18 6l-12 12" />
                            </svg>
                        </div>
                        <div class="icon-btn" id="btnPtDot" onclick="app.setGlobalPointStyle('dot')" aria-label="Disque"
                            data-tooltip="Disque">
                            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                <circle cx="12" cy="12" r="5" />
                            </svg>
                        </div>
                        <div class="icon-btn" id="btnPtPixel" onclick="app.setGlobalPointStyle('pixel')"
                            aria-label="Pixel" data-tooltip="Pixel">
                            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                                <rect x="10" y="10" width="4" height="4" />
                            </svg>
                        </div>
                    </div>
                </div>

                <div
                    style="position:relative; width:34px; height:34px; display:flex; align-items:center; justify-content:center;">
                    <input type="color" id="globalColorPicker" value="#000000" oninput="app.setGlobalColor(this.value)"
                        onchange="app.setGlobalColor(this.value)"
                        style="position:absolute; opacity:0; width:100%; height:100%; cursor:pointer;"
                        aria-label="Choisir la couleur" data-tooltip="Choisir la couleur">

                    <div id="colorPreview"
                        style="width:20px; height:20px; border-radius:50%; background:#000; border:2px solid #ddd; pointer-events:none;">
                    </div>
                </div>


                <button class="top-btn" id="btnGlobalDash" onclick="app.toggleGlobalDash()"
                    aria-label="Style de trait (Plein/Pointill√©)" data-tooltip="Style de trait (Plein/Pointill√©)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <line x1="2" y1="12" x2="22" y2="12" stroke-width="2" />
                    </svg>
                </button>

                <div class="slider-container" style="flex-direction:row; gap:8px; margin: 0 4px;">
                    <input type="range" id="globalWidth" min="1" max="8" value="2"
                        oninput="app.setGlobalWidth(this.value)" aria-label="√âpaisseur" data-tooltip="√âpaisseur">
                    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor">
                        <line id="headerStrokeIcon" x1="2" y1="12" x2="22" y2="12" stroke-width="2"
                            stroke-linecap="round" />
                    </svg>
                </div>

                <button class="top-btn" id="btnPaint" onclick="app.togglePaintMode()" aria-label="Mode Peinture"
                    data-tooltip="Mode Peinture">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path
                            d="M13.5 3C8.3 3 4 7.3 4 12.5C4 17.7 8.3 22 13.5 22C16.5 22 19 20 19 17.5C19 16.7 18.3 16 17.5 16H16.5C15.7 16 15 15.3 15 14.5C15 13.7 15.7 13 16.5 13H17C18.7 13 20 11.7 20 10C20 6.1 17.1 3 13.5 3Z" />
                        <circle cx="8.5" cy="10.5" r="1.5" fill="#e74c3c" stroke="none" />
                        <circle cx="13.5" cy="7.5" r="1.5" fill="#f1c40f" stroke="none" />
                        <circle cx="8.5" cy="15.5" r="1.5" fill="#3498db" stroke="none" />
                    </svg>
                </button>
            </div>

            <div class="header-dropdown">
                <button class="top-btn" aria-label="Options de Texte" data-tooltip="Options de Texte">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <text x="12" y="18" font-family="serif" font-size="18" fill="currentColor" stroke="none"
                            font-weight="bold" text-anchor="middle">A</text>
                    </svg>
                </button>

                <div class="header-dropdown-content" style="width: 50px;">
                    <button class="icon-btn" onclick="app.toggleGlobalLabels()" aria-label="Afficher/Masquer les noms"
                        data-tooltip="Afficher/Masquer les noms">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                            <circle cx="12" cy="12" r="3" color="white" />
                        </svg>
                    </button>

                    <div class="sep-h"></div>

                    <button class="icon-btn" onclick="app.offsetGlobalTextSize(2)" aria-label="Agrandir le texte"
                        data-tooltip="Agrandir le texte">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19V5 M5 12l7-7 7 7" />
                        </svg>
                    </button>

                    <button class="icon-btn" onclick="app.offsetGlobalTextSize(-2)" aria-label="R√©duire le texte"
                        data-tooltip="R√©duire le texte">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 5v14 M19 12l-7 7-7-7" />
                        </svg>
                    </button>

                    <div class="sep-h"></div>

                    <button class="icon-btn" onclick="app.resetGlobalText()" aria-label="R√©initialiser (Standard)"
                        data-tooltip="R√©initialiser (Standard)">=
                    </button>
                </div>
            </div>

            <div class="toolbar-group">
                <button class="top-btn" id="btnUndo" onclick="app.undo()" disabled aria-label="Annuler (Ctrl+Z)"
                    data-tooltip="Annuler (Ctrl+Z)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M3 7v6h6" />
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                    </svg>
                </button>
                <button class="top-btn" id="btnRedo" onclick="app.redo()" disabled aria-label="R√©tablir (Ctrl+Y)"
                    data-tooltip="R√©tablir (Ctrl+Y)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M21 7v6h-6" />
                        <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" />
                    </svg>
                </button>
            </div>

            <button class="top-btn" onclick="app.toggleInstructions()" aria-label="Afficher/Masquer les Consignes"
                data-tooltip="Afficher/Masquer les Consignes">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
            </button>
            <button class="top-btn" onclick="app.toggleHelp()" aria-label="Aide & Raccourcis"
                data-tooltip="Aide & Raccourcis" style="margin-left:auto;">
                <span style="font-weight:bold; font-size:18px;">?</span>
            </button>
        </div>
    </header>
    <div class="main-container">
        <div class="toolbar">
            <div class="group-label">Action</div>

            <button class="tool-btn active" onclick="app.setTool('move')" aria-label="D√©placer / S√©lectionner"
                data-tooltip="D√©placer / S√©lectionner">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2.9-3.2-7.3L7 18z" />
                </svg>
            </button>

            <button class="tool-btn delete-btn" onclick="app.setTool('delete')" aria-label="Supprimer"
                data-tooltip="Supprimer">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18 M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Points</div>

            <button class="tool-btn" onclick="app.setTool('point')" aria-label="Point" data-tooltip="Point">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round">
                    <line x1="8" y1="8" x2="16" y2="16" />
                    <line x1="16" y1="8" x2="8" y2="16" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('midpoint')" aria-label="Milieu" data-tooltip="Milieu">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="2" y1="12" x2="22" y2="12" stroke-width="2" />
                    <line x1="2" y1="10" x2="2" y2="14" stroke-width="2" />
                    <line x1="22" y1="10" x2="22" y2="14" stroke-width="2" />
                    <path d="M9 9 L15 15 M9 15 L15 9" stroke-width="1" />
                    <path d="M5 10 L7 14" stroke-width="1" />
                    <path d="M17 10 L19 14" stroke-width="1" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Transf.</div>

            <button class="tool-btn" onclick="app.setTool('sym_axial')" aria-label="Sym√©trie Axiale (Miroir)"
                data-tooltip="Sym√©trie Axiale (Miroir)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2v20 M4 12l4-4 M4 12l4 4 M20 12l-4-4 M20 12l-4 4" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('sym_central')" aria-label="Sym√©trie Centrale (Rotation 180¬∞)"
                data-tooltip="Sym√©trie Centrale (Rotation 180¬∞)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="2" fill="currentColor" />
                    <path d="M6 12a6 6 0 0 1 12 0" stroke-dasharray="2,2" />
                    <circle cx="4" cy="12" r="2" />
                    <circle cx="20" cy="12" r="2" fill="currentColor" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Lignes</div>

            <button class="tool-btn" onclick="app.setTool('segment')" aria-label="Segment [AB]"
                data-tooltip="Segment [AB]">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="5" y1="19" x2="19" y2="5" />
                    <line x1="3" y1="17" x2="7" y2="21" stroke-width="2.5" />
                    <line x1="17" y1="3" x2="21" y2="7" stroke-width="2.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('line')" aria-label="Droite (AB)" data-tooltip="Droite (AB)">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="2" y1="22" x2="22" y2="2" />
                    <line x1="5" y1="15" x2="9" y2="19" stroke-width="2.5" />
                    <line x1="15" y1="5" x2="19" y2="9" stroke-width="2.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('ray')" aria-label="Demi-droite [AB)"
                data-tooltip="Demi-droite [AB)">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round">
                    <line x1="5" y1="19" x2="22" y2="2" />
                    <line x1="3" y1="17" x2="7" y2="21" stroke-width="2.5" />
                    <line x1="13" y1="7" x2="17" y2="11" stroke-width="2.5" />
                </svg>
            </button>
            <div class="tool-sep"></div>

            <div class="group-label">Relat.</div>

            <button class="tool-btn" onclick="app.setTool('perpendicular')" aria-label="Perpendiculaire"
                data-tooltip="Perpendiculaire">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <line x1="4" y1="20" x2="20" y2="20" />
                    <line x1="12" y1="4" x2="12" y2="20" />
                    <rect x="12" y="15" width="5" height="5" stroke-width="1.5" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('parallel')" aria-label="Parall√®le" data-tooltip="Parall√®le">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M5 20L17 4 M9 22L21 6" />
                </svg>
            </button>

            <div class="tool-sep"></div>
            <div class="group-label">Annot.</div>
            <button class="tool-btn" onclick="app.setTool('text')" aria-label="Texte / Renommer"
                data-tooltip="Texte / Renommer">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <text x="12" y="18" font-family="Arial" font-size="16" font-weight="bold"
                        text-anchor="middle">A</text>
                    <path d="M14 6 L17 6 L17 8 L15 8 L15 6 L14 6" stroke="currentColor" stroke-width="1" fill="none" />
                    <circle cx="16" cy="17" r="1" />
                </svg>
            </button>

            <button class="tool-btn" onclick="app.setTool('angle')" aria-label="Angle" data-tooltip="Angle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <line x1="4" y1="20" x2="20" y2="20" />
                    <line x1="4" y1="20" x2="16" y2="4" />
                    <path d="M 12 20 A 8 8 0 0 0 9 13" stroke-width="1.5" />
                </svg>
            </button>
            <div class="tool-sep"></div>


            <div class="group-label">Formes</div>
            <button class="tool-btn" onclick="app.setTool('circle')" aria-label="Cercle" data-tooltip="Cercle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <circle cx="12" cy="12" r="8" />
                    <path d="M11 12 L13 12 M12 11 L12 13" stroke-width="1.5" />
                </svg>
            </button>
            <button class="tool-btn" onclick="app.setTool('polygon')" aria-label="Polygone" data-tooltip="Polygone">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M12 3l9 7-4 11H7L3 10z" />
                </svg>
            </button>
            <div class="tool-sep"></div>
            <div class="group-label">Outils</div>
            <button class="tool-btn" id="btn-compass" onclick="app.toggleWidget('compass')" aria-label="Compas"
                data-tooltip="Compas">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none"
                    stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="5" r="2" />
                    <line x1="12" y1="7" x2="7" y2="21" />
                    <line x1="12" y1="7" x2="17" y2="21" />
                    <line x1="7" y1="21" x2="7" y2="21" stroke-width="3" />
                    <line x1="17" y1="21" x2="17" y2="21" stroke-width="3" />
                </svg>
            </button>
            <button class="tool-btn" id="btn-setsquare" onclick="app.toggleWidget('setsquare')" aria-label="√âquerre"
                data-tooltip="√âquerre">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M4 20h16L4 4z" />
                </svg>
            </button>

            <button class="tool-btn" id="btn-protractor" onclick="app.toggleWidget('protractor')"
                aria-label="Rapporteur" data-tooltip="Rapporteur">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2" fill="none">
                    <path d="M 2 16 A 8 10 0 0 1 22 16 Z" />
                    <line x1="12" y1="16" x2="12" y2="12" stroke-width="1.5" />
                </svg>
            </button>

            <button class="tool-btn" id="btn-ruler" onclick="app.toggleWidget('ruler')" aria-label="R√®gle"
                data-tooltip="R√®gle">
                <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" stroke-width="2">
                    <rect x="4" y="8" width="16" height="8" rx="1" fill="none" />
                    <path d="M6 8v3 M9 8v2 M12 8v3 M15 8v2 M18 8v3" stroke-width="1.5" />
                </svg>
            </button>
        </div>

        <div id="textEditor" style="display:none;">
            <div class="editor-toolbar">
                <select id="fontFamilyInput" title="Police">
                    <option value="'Segoe UI', sans-serif">Standard</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="'Times New Roman', serif">S√©rif</option>
                    <option value="'Courier New', monospace">Code</option>
                    <option value="'Comic Sans MS', 'Chalkboard SE', sans-serif">Fun</option>
                    <option value="Impact, sans-serif">Gras</option>
                </select>
                <input type="number" id="fontSizeInput" value="16" min="8" max="100" step="2" title="Taille (px)">
            </div>
            <input type="text" id="textInput" placeholder="Texte..." autocomplete="off">
            <div class="editor-buttons">
                <button id="btnTextCancel" title="Annuler">‚úï</button>
                <button id="btnTextSave" title="Valider">‚úì</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="geoCanvas" width=3000 height="2000"></canvas>

            <div id="replayBar">
                <div class="replay-control-group">
                    <button class="replay-btn" id="btnPlay" onclick="app.playFromStart()"
                        title="Lire depuis le d√©but">‚ñ∂</button>
                    <button class="replay-btn" id="btnStop" onclick="app.stopAnimation()"
                        title="Stop (Aller √† la fin)">‚ñ†</button>
                    <button class="replay-btn" id="btnLoop" onclick="app.toggleLoop()" title="Boucle (OFF)">üîÅ</button>
                </div>

                <div class="replay-control-group slider-container">
                    <span class="slider-icon">Vitesse</span>
                    <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="app.setSpeed(this.value)">
                </div>

                <div class="replay-control-group slider-container">
                    <span class="slider-icon">Pause</span>
                    <input type="range" id="pauseSlider" min="0" max="3000" step="100" value="1000"
                        oninput="app.setLoopDelay(this.value)">
                </div>
            </div>

            <div id="contextMenu">
                <div class="drag-handle" id="menuDragHandle"></div>

                <div class="menu-row justify-center">
                    <div class="color-dot" style="background:#222;" onclick="app.styleObject('black')"></div>
                    <div class="color-dot" style="background:#2980b9;" onclick="app.styleObject('blue')"></div>
                    <div class="color-dot" style="background:#c0392b;" onclick="app.styleObject('red')"></div>
                    <div class="color-dot" style="background:#27ae60;" onclick="app.styleObject('green')"></div>
                    <div class="color-dot" style="background:#e67e22;" onclick="app.styleObject('orange')"></div>
                </div>
                <div class="menu-row justify-center">
                    <div class="color-dot" style="background:#8e44ad;" onclick="app.styleObject('purple')"></div>
                    <div class="color-dot" style="background:#7f8c8d;" onclick="app.styleObject('gray')"></div>
                    <div class="color-dot" style="background:#e91e63;" onclick="app.styleObject('pink')"></div>
                    <div class="color-dot" style="background:#f1c40f;" onclick="app.styleObject('yellow')"></div>
                    <div class="color-dot" style="background:#1abc9c;" onclick="app.styleObject('cyan')"></div>
                </div>

                <div id="sepFill" class="sep-h" style="display:none;"></div>

                <div id="rowFill" class="menu-row" style="display:none;">
                    <div class="icon-btn" onclick="app.styleObject('fill-solid')" title="Plein">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="currentColor" opacity="0.5"
                                stroke="currentColor" stroke-width="2" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-hatch')" title="Hachures">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                            <path d="M6 18L18 6 M10 20L20 10 M4 14L14 4" stroke="currentColor" stroke-width="1" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-dots')" title="Points">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                            <circle cx="8" cy="8" r="1" fill="currentColor" />
                            <circle cx="16" cy="8" r="1" fill="currentColor" />
                            <circle cx="8" cy="16" r="1" fill="currentColor" />
                            <circle cx="16" cy="16" r="1" fill="currentColor" />
                            <circle cx="12" cy="12" r="1" fill="currentColor" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('fill-none')" title="Vide">
                        <svg viewBox="0 0 24 24">
                            <rect x="4" y="4" width="16" height="16" fill="none" stroke="currentColor"
                                stroke-width="2" />
                        </svg>
                    </div>
                </div>

                <div id="sep1" class="sep-h"></div>
                <div id="rowStyle" class="menu-row">
                    <div class="icon-btn" onclick="app.styleObject('solid')" title="Plein">
                        <svg viewBox="0 0 24 24">
                            <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('dashed')" title="Pointill√©s">
                        <svg viewBox="0 0 24 24">
                            <line x1="2" y1="12" x2="22" y2="12" stroke="currentColor" stroke-width="3"
                                stroke-dasharray="4,2" />
                        </svg>
                    </div>
                    <input type="range" class="compact-slider" id="widthRange" min="1" max="8" step="1"
                        oninput="app.previewLineWidth(this.value)" onchange="app.setLineWidth(this.value)"
                        title="√âpaisseur">
                </div>

                <div id="rowMeasure" style="display:none;">
                    <div class="switch-container">
                        <div id="btnMesNone" class="switch-btn" onclick="app.styleObject('toggleLength-off')"
                            title="Masquer la mesure">
                            <svg viewBox="0 0 24 24">
                                <path
                                    d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24">
                                </path>
                                <line x1="1" y1="1" x2="23" y2="23"></line>
                            </svg>
                        </div>

                        <div id="btnMesUp" class="switch-btn" onclick="app.styleObject('measureUp')"
                            title="Mesure au-dessus">
                            <svg viewBox="0 0 24 24">
                                <line x1="2" y1="19" x2="22" y2="19"></line>
                                <rect x="7" y="5" width="10" height="8" rx="2"></rect>
                                <path d="M12 13v6"></path>
                            </svg>
                        </div>

                        <div id="btnMesDown" class="switch-btn" onclick="app.styleObject('measureDown')"
                            title="Mesure en-dessous">
                            <svg viewBox="0 0 24 24">
                                <line x1="2" y="5" x2="22" y2="5"></line>
                                <rect x="7" y="11" width="10" height="8" rx="2"></rect>
                                <path d="M12 5v6"></path>
                            </svg>
                        </div>
                    </div>
                </div>

                <div id="rowCoding" class="coding-grid" style="display:none;">
                    <div class="mark-btn" onclick="app.styleObject('mark-none')" title="Aucun">√ò</div>
                    <div class="mark-btn" onclick="app.styleObject('mark-1')"><svg viewBox="0 0 20 20">
                            <line x1="10" y1="4" x2="10" y2="16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-2')"><svg viewBox="0 0 20 20">
                            <path d="M7 4 L7 16 M13 4 L13 16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-3')"><svg viewBox="0 0 20 20">
                            <path d="M5 4 L5 16 M10 4 L10 16 M15 4 L15 16" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-x')"><svg viewBox="0 0 20 20">
                            <path d="M5 5 L15 15 M15 5 L5 15" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-xx')"><svg viewBox="0 0 20 20">
                            <path d="M2 5 L8 15 M8 5 L2 15 M12 5 L18 15 M18 5 L12 15" stroke="currentColor"
                                stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-o')"><svg viewBox="0 0 20 20">
                            <circle cx="10" cy="10" r="5" fill="none" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                    <div class="mark-btn" onclick="app.styleObject('mark-oo')"><svg viewBox="0 0 20 20">
                            <circle cx="6" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="2" />
                            <circle cx="14" cy="10" r="3" fill="none" stroke="currentColor" stroke-width="2" />
                        </svg></div>
                </div>

                <div id="rowAngle" class="menu-row" style="display:none;">

                    <div id="btnToggleAngleVal" class="icon-btn" onclick="app.styleObject('toggleAngleVal')"
                        title="Afficher Valeur">
                        <svg viewBox="0 0 24 24">
                            <text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-family="Arial"
                                font-weight="bold" font-size="10" fill="currentColor">12¬∞</text>
                        </svg>
                    </div>

                    <div id="btnToggleAngleFill" class="icon-btn" onclick="app.styleObject('toggleAngleFill')"
                        title="Remplir">
                        <div class="icon-btn" id="btnAngleFill" onclick="app.toggleAngleFill()" title="Remplir / Vider">
                            <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linejoin="round">
                                <path d="M4 20 L4 4 A16 16 0 0 1 20 20 H4 Z" fill="none" />

                                <path d="M4 20 L4 4 A16 16 0 0 1 15.3 8.7 Z" fill="currentColor" stroke="none" />
                            </svg>
                        </div>
                    </div>

                    <div id="btnFlipAngle" class="icon-btn" onclick="app.styleObject('flipAngle')"
                        title="Inverser (360¬∞)">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 16.03 20 14.57 20 13c0-4.42-3.58-8-8-8zm-6 8c0-1.65.67-3.15 1.76-4.24L6.3 7.3C4.89 8.7 4 10.74 4 13c0 4.42 3.58 8 8 8v-3l5 5-5 5v-3c-3.31 0-6-2.69-6-6z" />
                        </svg>
                    </div>

                </div>
                <div id="rowTextProps" class="menu-row justify-center"
                    style="display:none; border-bottom:1px solid #eee; padding-bottom:4px; margin-bottom:4px;">
                    <div id="btnToggleLabel" class="icon-btn" onclick="app.styleObject('toggleLabel')"
                        title="Afficher/Masquer le nom" style="margin-right:8px;">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
                                fill="currentColor" />
                        </svg>
                    </div>

                    <div class="icon-btn" onclick="app.styleObject('textSize-dec')" title="R√©duire">
                        <svg viewBox="0 0 24 24">
                            <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </div>

                    <div
                        style="font-weight:bold; color:#555; width:24px; text-align:center; font-size:14px; line-height:32px;">
                        A</div>

                    <div class="icon-btn" onclick="app.styleObject('textSize-inc')" title="Augmenter">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                    </div>
                </div>
                <div id="rowLabelPos" style="display:none; padding: 4px 0; border-bottom: 1px solid #eee;">
                    <div class="label-positioner" id="labelPosBox">
                        <div class="label-preview">A</div>
                        <div class="label-cross"></div>
                        <div class="label-knob" id="labelPosKnob"></div>
                    </div>
                </div>
                <div id="rowPointStyle" class="menu-row justify-center"
                    style="display:none; border-bottom:1px solid #eee; padding-bottom:4px; margin-bottom:4px;">
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-cross')" title="Croix">
                        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="3" fill="none">
                            <path d="M5 5l14 14M19 5l-14 14" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-dot')" title="Disque">
                        <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <circle cx="12" cy="12" r="6" />
                        </svg>
                    </div>
                    <div class="icon-btn" onclick="app.styleObject('pointStyle-pixel')" title="Pixel">
                        <svg viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <rect x="9" y="9" width="6" height="6" />
                        </svg>
                    </div>
                </div>
                <div id="rowRenamer" style="display:none;">
                    <div class="renamer-container">
                        <button class="renamer-btn" onclick="app.cyclePointName(-1)">‚óÄ</button>

                        <div class="renamer-display" id="renamerDisplay">A</div>
                        <button class="renamer-btn" onclick="app.cyclePointName(1)">‚ñ∂</button>

                        <button class="renamer-btn" onclick="app.addPrime()" title="Ajouter '"><b>'</b></button>
                    </div>
                </div>

                <div class="menu-row">
                    <div class="icon-btn btn-trash" onclick="app.deleteFromMenu()">üóëÔ∏è</div>
                </div>
            </div>
        </div>
    </div>
    <div id="virtualKeyboard" class="v-keyboard">
    </div>
    <div id="customModal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-text" id="modalMessage">√ätes-vous s√ªr ?</div>
            <div class="modal-buttons">
                <button class="modal-btn modal-cancel" onclick="app.closeModal()">Annuler</button>
                <button class="modal-btn modal-confirm danger" id="btnModalConfirm">Confirmer</button>
            </div>
        </div>
    </div>


    <script>

        const PatternUtils = {
            // Cr√©e un motif de hachures diagonales pour le Canvas
            createHatchPattern(ctx, color) {
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 10;
                pCanvas.height = 10;
                const pCtx = pCanvas.getContext('2d');

                pCtx.strokeStyle = color;
                pCtx.lineWidth = 1;
                pCtx.lineCap = 'square';

                // Ligne diagonale /
                pCtx.beginPath();
                pCtx.moveTo(0, 10);
                pCtx.lineTo(10, 0);
                pCtx.stroke();

                return ctx.createPattern(pCanvas, 'repeat');
            },

            // Cr√©e un motif de points
            createDotPattern(ctx, color) {
                const pCanvas = document.createElement('canvas');
                pCanvas.width = 6;
                pCanvas.height = 6;
                const pCtx = pCanvas.getContext('2d');

                pCtx.fillStyle = color;
                pCtx.beginPath();
                pCtx.arc(3, 3, 1, 0, Math.PI * 2);
                pCtx.fill();

                return ctx.createPattern(pCanvas, 'repeat');
            }
        };

        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        const UNIT = 50;
        const MathUtils = {
            /* --- DANS MathUtils --- */

            // Sym√©trie Centrale : P' = 2*Centre - P
            getCentralSymmetry(pt, center) {
                return {
                    x: 2 * center.x - pt.x,
                    y: 2 * center.y - pt.y
                };
            },
            // Sym√©trie Axiale : P' = 2*Projection - P
            getAxialSymmetry(pt, axis) {
                // 1. On trouve la projection orthogonale H sur l'axe
                const H = this.getProjectedPoint(pt.x, pt.y, axis);
                // 2. On applique la formule vectorielle
                return {
                    x: 2 * H.x - pt.x,
                    y: 2 * H.y - pt.y
                };
            },
            getLineCoords(obj) {
                if (obj.getDynamicP2) return {
                    p1: obj.p1,
                    p2: obj.getDynamicP2()
                };
                if (obj instanceof LinearObject) return {
                    p1: obj.p1,
                    p2: obj.p2
                };
                return {
                    p1: obj.p1,
                    p2: obj.p2
                };
            },
            drawInfiniteLineFromVector(ctx, x, y, dx, dy, color, width, dash) {
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return;
                const ndx = dx / len;
                const ndy = dy / len;
                const LARGE_NUM = 10000;
                ctx.beginPath();
                ctx.moveTo(x - ndx * LARGE_NUM, y - ndy * LARGE_NUM);
                ctx.lineTo(x + ndx * LARGE_NUM, y + ndy * LARGE_NUM);
                ctx.strokeStyle = color || '#000000';
                ctx.lineWidth = width || 3;
                ctx.setLineDash(dash || []);
                ctx.lineCap = 'round';
                ctx.stroke();
            },
            distanceToLineVector(mx, my, px, py, dx, dy) {
                const len2 = dx * dx + dy * dy;
                if (len2 === 0) return Infinity;
                const t = ((mx - px) * dx + (my - py) * dy) / len2;
                const projX = px + t * dx;
                const projY = py + t * dy;
                return Math.sqrt((mx - projX) ** 2 + (my - projY) ** 2);
            },
            distanceToSegment(x, y, x1, y1, x2, y2) {
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq != 0) param = dot / len_sq;
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },
            dist(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
            },
            isPointOnArc(pt, arcObj) {
                const center = (arcObj instanceof CompassArc || arcObj instanceof Arc) ? arcObj.center : arcObj.p1;
                if (!center || (center.x === undefined && !center.length)) return false;

                // R√©cup√©ration des coordonn√©es (g√®re les objets Point ou simples {x,y})
                const cx = center.x ?? 0;
                const cy = center.y ?? 0;

                // 1. Calcul de l'angle de la souris (0 √† 2PI)
                let angle = Math.atan2(pt.y - cy, pt.x - cx);
                if (angle < 0) angle += Math.PI * 2;

                // --- FIX 360¬∞ (CERCLE COMPLET) ---
                const totalRotation = Math.abs(arcObj.endAngle - arcObj.startAngle);
                const PI2 = Math.PI * 2;

                // Si c'est un cercle complet, on accepte tout
                if (totalRotation >= PI2 - 0.01) return true;

                // Normalisation des angles de l'arc (0 √† 2PI)
                let s = (arcObj.startAngle % PI2 + PI2) % PI2;
                let e = (arcObj.endAngle % PI2 + PI2) % PI2;
                const ccw = arcObj.counterClockwise;

                // Logique standard pour les arcs partiels
                if (ccw) {
                    // Sens anti-horaire
                    if (s > e) return angle <= s && angle >= e;
                    return angle <= s || angle >= e; // Passage par z√©ro
                } else {
                    // Sens horaire
                    if (s < e) return angle >= s && angle <= e;
                    return angle >= s || angle <= e; // Passage par z√©ro
                }

            },
            intersectLineCircle(p1, p2, center, radius, lineType) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const A = dx * dx + dy * dy;
                const B = 2 * (dx * (p1.x - center.x) + dy * (p1.y - center.y));
                const C = (p1.x - center.x) ** 2 + (p1.y - center.y) ** 2 - radius ** 2;
                const delta = B * B - 4 * A * C;
                const points = [];
                if (delta >= 0 && A > 0) {
                    const t1 = (-B - Math.sqrt(delta)) / (2 * A);
                    const t2 = (-B + Math.sqrt(delta)) / (2 * A);
                    const checkBounds = (t) => {
                        if (lineType === 'Segment') return t >= 0 && t <= 1;
                        if (lineType === 'Ray') return t >= 0;
                        return true;
                    };
                    if (checkBounds(t1)) points.push({
                        x: p1.x + t1 * dx,
                        y: p1.y + t1 * dy
                    });
                    if (delta > 0 && checkBounds(t2)) points.push({
                        x: p1.x + t2 * dx,
                        y: p1.y + t2 * dy
                    });
                }
                return points;
            },
            intersectCircleCircle(c1, r1, c2, r2) {
                const d2 = (c1.x - c2.x) ** 2 + (c1.y - c2.y) ** 2;
                const d = Math.sqrt(d2);
                if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];
                const a = (r1 ** 2 - r2 ** 2 + d2) / (2 * d);
                const h = Math.sqrt(Math.max(0, r1 ** 2 - a ** 2));
                const x2 = c1.x + a * (c2.x - c1.x) / d;
                const y2 = c1.y + a * (c2.y - c1.y) / d;
                const pts = [];
                pts.push({
                    x: x2 + h * (c2.y - c1.y) / d,
                    y: y2 - h * (c2.x - c1.x) / d
                });
                if (h > 0.001) pts.push({
                    x: x2 - h * (c2.y - c1.y) / d,
                    y: y2 + h * (c2.x - c1.x) / d
                });
                return pts;
            },
            getIntersections(obj1, obj2) {
                // 1. D√©finition des types
                const isLin1 = (obj1 instanceof LinearObject || obj1 instanceof ParallelLine || obj1 instanceof PerpendicularLine);
                const isLin2 = (obj2 instanceof LinearObject || obj2 instanceof ParallelLine || obj2 instanceof PerpendicularLine);

                const isCirc1 = (obj1 instanceof Circle || obj1 instanceof Arc || obj1 instanceof CompassArc || obj1 instanceof CompassCircle);
                const isCirc2 = (obj2 instanceof Circle || obj2 instanceof Arc || obj2 instanceof CompassArc || obj2 instanceof CompassCircle);

                // 2. Helper pour extraire proprement Centre et Rayon de n'importe quoi
                const getCircleData = (o) => {
                    if (o instanceof CompassCircle) return { c: o.center || o.p1, r: o.getRadius() };
                    if (o instanceof CompassArc) return { c: o.center, r: o.radius };
                    if (o instanceof Arc) return { c: o.center, r: o.radius };
                    // Pour un cercle standard d√©fini par 2 points
                    return { c: o.p1, r: MathUtils.dist(o.p1.x, o.p1.y, o.p2.x, o.p2.y) };
                };

                let rawPoints = [];

                // --- CAS 1 : LIGNE vs LIGNE ---
                if (isLin1 && isLin2) {
                    const c1 = MathUtils.getLineCoords(obj1);
                    const c2 = MathUtils.getLineCoords(obj2);
                    const A = c1.p1, B = c1.p2;
                    const C = c2.p1, D = c2.p2;

                    if (!A || !B || !C || !D) return [];

                    const det = (B.x - A.x) * (D.y - C.y) - (D.x - C.x) * (B.y - A.y);
                    if (det === 0) return []; // Parall√®les

                    const t = ((C.x - A.x) * (D.y - C.y) - (C.y - A.y) * (D.x - C.x)) / det;
                    const u = ((C.x - A.x) * (B.y - A.y) - (C.y - A.y) * (B.x - A.x)) / det;

                    const check = (val, type) => {
                        if (type === 'Segment') return val >= 0 && val <= 1;
                        if (type === 'Ray') return val >= 0;
                        return true;
                    };

                    // On v√©rifie que l'intersection est bien SUR les segments/demi-droites
                    if (check(t, obj1.constructor.name) && check(u, obj2.constructor.name)) {
                        return [{
                            x: A.x + t * (B.x - A.x),
                            y: A.y + t * (B.y - A.y)
                        }];
                    }
                    return [];
                }

                // --- CAS 2 : LIGNE vs CERCLE (Crois√©) ---
                else if (isLin1 && isCirc2) {
                    const c = MathUtils.getLineCoords(obj1);
                    const circle = getCircleData(obj2);
                    rawPoints = MathUtils.intersectLineCircle(c.p1, c.p2, circle.c, circle.r, obj1.constructor.name);
                }
                else if (isCirc1 && isLin2) {
                    const c = MathUtils.getLineCoords(obj2);
                    const circle = getCircleData(obj1);
                    rawPoints = MathUtils.intersectLineCircle(c.p1, c.p2, circle.c, circle.r, obj2.constructor.name);
                }

                // --- CAS 3 : CERCLE vs CERCLE ---
                else if (isCirc1 && isCirc2) {
                    const c1 = getCircleData(obj1);
                    const c2 = getCircleData(obj2);
                    rawPoints = MathUtils.intersectCircleCircle(c1.c, c1.r, c2.c, c2.r);
                }

                // 3. Filtrage final : On v√©rifie si les points sont bien SUR les arcs
                return rawPoints.filter(pt => {
                    let ok1 = true;
                    let ok2 = true;

                    // Si l'objet est un Arc ou un CompassArc, on v√©rifie les angles
                    if (obj1 instanceof Arc || obj1 instanceof CompassArc) ok1 = MathUtils.isPointOnArc(pt, obj1);
                    if (obj2 instanceof Arc || obj2 instanceof CompassArc) ok2 = MathUtils.isPointOnArc(pt, obj2);

                    return ok1 && ok2;
                });
            },
            distanceToLine(px, py, A, B, type) {
                if (!A || !B) return Infinity;
                const l2 = (A.x - B.x) ** 2 + (A.y - B.y) ** 2;
                if (l2 === 0) return Infinity;
                let t = ((px - A.x) * (B.x - A.x) + (py - A.y) * (B.y - A.y)) / l2;
                if (type === 'Segment') t = Math.max(0, Math.min(1, t));
                else if (type === 'Ray') t = Math.max(0, t);
                const projX = A.x + t * (B.x - A.x);
                const projY = A.y + t * (B.y - A.y);
                return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
            },
            getProjectedPoint(px, py, obj) {
                // 1. CAS CERCLES & ARCS
                if (obj instanceof Circle || obj instanceof Arc || obj instanceof CompassArc || obj instanceof CompassCircle) {
                    let center, radius;

                    if (obj instanceof CompassCircle || obj instanceof CompassArc) {
                        center = obj.center;
                        radius = obj.radius;
                        if (obj instanceof CompassCircle && obj.rP1) {
                            radius = MathUtils.dist(obj.rP1.x, obj.rP1.y, obj.rP2.x, obj.rP2.y);
                        }
                    } else {
                        center = obj.center || obj.p1;
                        radius = obj.radius || MathUtils.dist(obj.p1.x, obj.p1.y, obj.p2.x, obj.p2.y);
                    }

                    if (!center) return { x: px, y: py };

                    const angle = Math.atan2(py - center.y, px - center.x);
                    const finalX = center.x + radius * Math.cos(angle);
                    const finalY = center.y + radius * Math.sin(angle);

                    if (obj instanceof Arc || obj instanceof CompassArc) {
                        if (MathUtils.isPointOnArc({ x: finalX, y: finalY }, obj)) {
                            return { x: finalX, y: finalY };
                        } else {
                            const sx = center.x + radius * Math.cos(obj.startAngle);
                            const sy = center.y + radius * Math.sin(obj.startAngle);
                            const ex = center.x + radius * Math.cos(obj.endAngle);
                            const ey = center.y + radius * Math.sin(obj.endAngle);

                            const dStart = (px - sx) ** 2 + (py - sy) ** 2;
                            const dEnd = (px - ex) ** 2 + (py - ey) ** 2;

                            return (dStart < dEnd) ? { x: sx, y: sy } : { x: ex, y: ey };
                        }
                    }

                    return { x: finalX, y: finalY };
                }

                const c = MathUtils.getLineCoords(obj);
                const A = c.p1;
                const B = c.p2;
                if (!A || !B) return {
                    x: px,
                    y: py
                };
                const l2 = (A.x - B.x) ** 2 + (A.y - B.y) ** 2;
                if (l2 === 0) return {
                    x: A.x,
                    y: A.y
                };
                let t = ((px - A.x) * (B.x - A.x) + (py - A.y) * (B.y - A.y)) / l2;
                if (obj.constructor.name === 'Segment') t = Math.max(0, Math.min(1, t));
                else if (obj.constructor.name === 'Ray') t = Math.max(0, t);
                return {
                    x: A.x + t * (B.x - A.x),
                    y: A.y + t * (B.y - A.y)
                };
            }
        };

        // Class //
        class GeometryObject {
            constructor(p1, p2, id = null) {
                this.id = id || generateId();
                this.p1 = p1;
                this.p2 = p2;
                this.color = null;
                this.dash = [];
                this.lineWidth = 2;
            }
            getStyle(defaultColor, isHovered, isToDelete) {
                const baseColor = this.color || defaultColor;
                const baseWidth = this.lineWidth || 2;
                if (isToDelete) return {
                    color: "#d32f2f",
                    width: baseWidth + 3,
                    dash: []
                };
                if (isHovered) return {
                    color: baseColor,
                    width: baseWidth + 3,
                    dash: this.dash
                };
                return {
                    color: baseColor,
                    width: baseWidth,
                    dash: this.dash
                };
            }
            getCoords() {
                return {
                    p1: this.p1,
                    p2: this.p2
                };
            }
        }

        class Point extends GeometryObject {
            constructor(x, y, label = "", parents = [], id = null, subType = null) {
                super(null, null, id);
                this.x = x;
                this.y = y;
                this.label = label;
                this.size = 6;
                this.parents = parents;
                this.visible = true;
                this.labelAngle = -Math.PI / 4;
                this.fontSize = 14;
                this.showLabel = true;
                this.pointStyle = 'cross';
                this.subType = subType;
            }
            update() {
                if (this.subType === 'symmetry_central' && this.parents.length === 2) {
                    const origin = this.parents[0];
                    const center = this.parents[1];
                    const res = MathUtils.getCentralSymmetry(origin, center);
                    this.x = res.x;
                    this.y = res.y;
                    return;
                }
                if (this.subType === 'symmetry_axial' && this.parents.length === 2) {
                    const origin = this.parents[0];
                    const axis = this.parents[1];
                    const res = MathUtils.getAxialSymmetry(origin, axis);
                    this.x = res.x;
                    this.y = res.y;
                    return;
                }
                if (this.parents.length === 2) {
                    if (this.parents[0] instanceof Point && this.parents[1] instanceof Point) {
                        this.x = (this.parents[0].x + this.parents[1].x) / 2;
                        this.y = (this.parents[0].y + this.parents[1].y) / 2;
                        this.visible = true;
                    } else {
                        const pts = MathUtils.getIntersections(this.parents[0], this.parents[1]);
                        if (pts.length === 0) this.visible = false;
                        else {
                            this.visible = true;
                            if (pts.length === 1) {
                                this.x = pts[0].x;
                                this.y = pts[0].y;
                            } else {
                                const d1 = (this.x - pts[0].x) ** 2 + (this.y - pts[0].y) ** 2;
                                const d2 = (this.x - pts[1].x) ** 2 + (this.y - pts[1].y) ** 2;
                                if (d1 < d2) {
                                    this.x = pts[0].x;
                                    this.y = pts[0].y;
                                } else {
                                    this.x = pts[1].x;
                                    this.y = pts[1].y;
                                }
                            }
                        }
                    }
                } else if (this.parents.length === 1) {
                    const proj = MathUtils.getProjectedPoint(this.x, this.y, this.parents[0]);

                    if (proj) {
                        this.x = proj.x;
                        this.y = proj.y;
                    }
                }
            }
            isNear(mx, my) {
                return this.visible && Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2) < 12;
            }
            draw(ctx, opts) {
                if (!this.visible && !opts.isSelected) return;
                ctx.beginPath();
                const base = this.color || (this.parents.length > 0 ? "#333" : "red");
                const style = opts.isToDelete ? "#d32f2f" : (opts.isHovered ? base : (opts.isSelected ? "orange" : base));
                const w = (opts.isHovered || opts.isSelected || opts.isToDelete) ? 4 : 2;
                ctx.strokeStyle = style;
                ctx.lineWidth = w;
                ctx.setLineDash([]);
                if (this.pointStyle === 'dot') {
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                else if (this.pointStyle === 'pixel') {
                    ctx.rect(this.x - 1, this.y - 1, 2, 2);
                    ctx.fill();
                    ctx.stroke();
                }
                else {
                    ctx.moveTo(this.x - this.size, this.y - this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.moveTo(this.x + this.size, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.stroke();
                }
                if (this.label && this.showLabel) {
                    ctx.fillStyle = "black";
                    const fs = this.fontSize || 14;
                    ctx.font = `bold ${fs}px Arial`;

                    const angle = (this.labelAngle !== undefined) ? this.labelAngle : -Math.PI / 4;
                    const dist = 12 + fs / 2;
                    const lx = this.x + Math.cos(angle) * dist;
                    const ly = this.y + Math.sin(angle) * dist;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(this.label, lx, ly);
                }
            }
        }

        class TextLabel extends GeometryObject {
            constructor(x, y, text, id = null) {
                super(null, null, id);
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = "black";
                this.font = "16px Segoe UI";
                this.fontSize = 16;
                this.fontFamily = "'Segoe UI', sans-serif";
            }
            isNear(mx, my) {
                if (!this.text) return false;
                const estWidth = this.text.length * 10;
                const estHeight = 20;
                return (Math.abs(mx - this.x) < estWidth / 2 + 10) && (Math.abs(my - this.y) < estHeight / 2 + 10);
            }
            draw(ctx, opts) {
                ctx.font = `${this.fontSize}px ${this.fontFamily}`;
                ctx.fillStyle = opts.isHovered ? "#2980b9" : (opts.isSelected ? "#e67e22" : (this.color || "black"));
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.text, this.x, this.y);

                if (opts.isHovered || opts.isSelected) {
                    const w = ctx.measureText(this.text).width + 10;
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.strokeRect(this.x - w / 2, this.y - 10, w, 20);
                    ctx.setLineDash([]);
                }
            }
        }

        class LinearObject extends GeometryObject {
            isNear(mx, my) {
                return this.p1 && this.p2 && MathUtils.distanceToLine(mx, my, this.p1, this.p2, this.constructor.name) < 8;
            }
            drawInfinite(ctx, startMult, endMult, style) {
                if (!this.p1 || !this.p2) return;
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                ctx.beginPath();
                ctx.moveTo(this.p1.x + dx * startMult, this.p1.y + dy * startMult);
                ctx.lineTo(this.p1.x + dx * endMult, this.p1.y + dy * endMult);
                ctx.strokeStyle = style.color;
                ctx.lineWidth = style.width;
                ctx.setLineDash(style.dash);
                ctx.stroke();
            }
        }
        class Segment extends LinearObject {
            constructor(p1, p2, id) {
                super(p1, p2, id);
                this.showLength = false;
                this.measureOffset = -15;
                this.coding = null; // 'mark-1', 'mark-2', 'mark-x', etc.
            }
            draw(ctx, {
                isHovered,
                isToDelete
            }) {
                const s = this.getStyle("blue", isHovered, isToDelete);
                this.drawInfinite(ctx, 0, 1, s);

                if (!this.p1 || !this.p2) return;

                // --- DESSIN DU CODAGE ---
                if (this.coding && this.coding !== 'mark-none') {
                    const mx = (this.p1.x + this.p2.x) / 2;
                    const my = (this.p1.y + this.p2.y) / 2;
                    const angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);

                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const h = 6; // hauteur du trait

                    if (this.coding === 'mark-1') {
                        ctx.moveTo(0, -h); ctx.lineTo(0, h);
                    } else if (this.coding === 'mark-2') {
                        ctx.moveTo(-2, -h); ctx.lineTo(-2, h);
                        ctx.moveTo(2, -h); ctx.lineTo(2, h);
                    } else if (this.coding === 'mark-3') {
                        ctx.moveTo(-4, -h); ctx.lineTo(-4, h);
                        ctx.moveTo(0, -h); ctx.lineTo(0, h);
                        ctx.moveTo(4, -h); ctx.lineTo(4, h);
                    } else if (this.coding === 'mark-x') {
                        ctx.moveTo(-4, -4); ctx.lineTo(4, 4);
                        ctx.moveTo(-4, 4); ctx.lineTo(4, -4);
                    } else if (this.coding === 'mark-xx') {
                        ctx.translate(-5, 0);
                        ctx.moveTo(-3, -3); ctx.lineTo(3, 3);
                        ctx.moveTo(-3, 3); ctx.lineTo(3, -3);
                        ctx.translate(10, 0);
                        ctx.moveTo(-3, -3); ctx.lineTo(3, 3);
                        ctx.moveTo(-3, 3); ctx.lineTo(3, -3);
                    } else if (this.coding === 'mark-o') {
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    } else if (this.coding === 'mark-oo') {
                        ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(5, 0, 3, 0, Math.PI * 2);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // --- DESSIN DE LA MESURE ---
                if (this.showLength) {
                    const px = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                    const val = (px / UNIT).toFixed(1);
                    const mx = (this.p1.x + this.p2.x) / 2;
                    const my = (this.p1.y + this.p2.y) / 2;
                    let angle = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
                    let off = this.measureOffset;
                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        angle += Math.PI;
                        off = -off;
                    }
                    ctx.save();
                    ctx.translate(mx, my);
                    ctx.rotate(angle);
                    ctx.font = "14px Segoe UI";
                    const w = ctx.measureText(val).width;
                    ctx.fillStyle = "rgba(255,255,255,0.7)";
                    ctx.fillRect(-w / 2 - 2, off - 12, w + 4, 16);
                    ctx.fillStyle = this.color || "blue";
                    ctx.textAlign = "center";
                    ctx.fillText(val, 0, off);
                    ctx.restore();
                }
            }
        }
        class Ray extends LinearObject {
            draw(ctx, o) {
                this.drawInfinite(ctx, 0, 1000, this.getStyle("green", o.isHovered, o.isToDelete));
            }
        }
        class Line extends LinearObject {
            draw(ctx, o) {
                this.drawInfinite(ctx, -1000, 1000, this.getStyle("black", o.isHovered, o.isToDelete));
            }
        }
        class Circle extends GeometryObject {
            isNear(mx, my) {
                if (!this.p1 || !this.p2) return false;
                const r = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                return Math.abs(MathUtils.dist(mx, my, this.p1.x, this.p1.y) - r) < 8;
            }
            draw(ctx, o) {
                if (!this.p1 || !this.p2) return;
                const r = MathUtils.dist(this.p1.x, this.p1.y, this.p2.x, this.p2.y);
                ctx.beginPath();
                ctx.arc(this.p1.x, this.p1.y, r, 0, Math.PI * 2);
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.stroke();
            }
        }
        class CompassCircle extends GeometryObject {
            constructor(center, rP1, rP2, id = null) {
                super(center, null, id);
                this.rP1 = rP1;
                this.rP2 = rP2;
            }
            getRadius() {
                if (this.rP1 && this.rP2) return MathUtils.dist(this.rP1.x, this.rP1.y, this.rP2.x, this.rP2.y);
                return 0;
            }
            isNear(mx, my) {
                if (!this.p1) return false;
                const r = this.getRadius();
                return Math.abs(MathUtils.dist(mx, my, this.p1.x, this.p1.y) - r) < 8;
            }
            draw(ctx, o) {
                if (!this.p1) return;
                const r = this.getRadius();
                ctx.beginPath();
                ctx.arc(this.p1.x, this.p1.y, r, 0, Math.PI * 2);
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.stroke();
            }
        }
        class CompassArc extends GeometryObject {
            constructor(center, radius, startAngle, endAngle, counterClockwise = false, id = null) {
                super(center, null, id);
                this.center = center;
                this.radius = radius;
                this.startAngle = startAngle;
                this.endAngle = endAngle;
                this.counterClockwise = counterClockwise;
            }

            isNear(mx, my) {
                if (!this.center) return false;
                const cx = this.center.x !== undefined ? this.center.x : 0;
                const cy = this.center.y !== undefined ? this.center.y : 0;

                const d = MathUtils.dist(mx, my, cx, cy);
                if (Math.abs(d - this.radius) > 8) return false;

                return MathUtils.isPointOnArc({ x: mx, y: my }, this);
            }

            draw(ctx, opts) {
                if (!this.center) return;
                const cx = this.center.x !== undefined ? this.center.x : 0;
                const cy = this.center.y !== undefined ? this.center.y : 0;

                ctx.beginPath();
                const s = this.getStyle("black", opts.isHovered, opts.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);

                ctx.arc(cx, cy, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
                ctx.stroke();
            }
        }

        class Angle extends GeometryObject {
            constructor(p1, p2, p3, id = null) {
                super(p1, p2, id);
                this.p3 = p3;
                this.showValue = true;
                this.isFilled = false;
                this.isCounterClockwise = false;

                if (p1 && p2 && p3) {
                    const a1 = Math.atan2(p1.y - p2.y, p1.x - p2.x);
                    const a2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                    let diff = a2 - a1;
                    while (diff <= -Math.PI) diff += 2 * Math.PI;
                    while (diff > Math.PI) diff -= 2 * Math.PI;
                    this.isCounterClockwise = (diff > 0);
                }
            }

            isNear(mx, my) {
                if (!this.p2) return false;
                const d = MathUtils.dist(mx, my, this.p2.x, this.p2.y);
                return (d > 10 && d < 50);
            }
            getAngleValue() {
                if (!this.p1 || !this.p2 || !this.p3) return 0;
                const a1 = Math.atan2(this.p1.y - this.p2.y, this.p1.x - this.p2.x);
                const a2 = Math.atan2(this.p3.y - this.p2.y, this.p3.x - this.p2.x);
                let diff = a2 - a1;
                if (this.isCounterClockwise) {
                    if (diff < 0) diff += 2 * Math.PI;
                } else {
                    if (diff > 0) diff -= 2 * Math.PI;
                }
                return Math.abs(diff * 180 / Math.PI);
            }
            draw(ctx, { isHovered, isToDelete }) {
                if (!this.p1 || !this.p2 || !this.p3) return;

                const val = this.getAngleValue();
                const isRightAngle = Math.abs(val - 90) < 0.5;
                const radius = 25;

                let baseColor = this.color || "green";
                if (window.app && window.app.getThemeColor) baseColor = window.app.getThemeColor(baseColor);

                const isSelected = arguments[1] ? arguments[1].isSelected : false;
                const s = isToDelete ? "#d32f2f" : (isHovered ? baseColor : (isSelected ? "orange" : baseColor));
                const width = (isHovered || isSelected || isToDelete) ? 4 : 2;

                ctx.beginPath();
                ctx.strokeStyle = s;
                ctx.lineWidth = width;
                ctx.setLineDash([]);

                const a1 = Math.atan2(this.p1.y - this.p2.y, this.p1.x - this.p2.x);
                const a2 = Math.atan2(this.p3.y - this.p2.y, this.p3.x - this.p2.x);

                if (isRightAngle) {
                    const size = 16;
                    const d1 = MathUtils.dist(this.p2.x, this.p2.y, this.p1.x, this.p1.y);
                    const d2 = MathUtils.dist(this.p2.x, this.p2.y, this.p3.x, this.p3.y);
                    if (d1 > 0 && d2 > 0) {
                        const ux = (this.p1.x - this.p2.x) / d1 * size, uy = (this.p1.y - this.p2.y) / d1 * size;
                        const vx = (this.p3.x - this.p2.x) / d2 * size, vy = (this.p3.y - this.p2.y) / d2 * size;
                        ctx.moveTo(this.p2.x + ux, this.p2.y + uy);
                        ctx.lineTo(this.p2.x + ux + vx, this.p2.y + uy + vy);
                        ctx.lineTo(this.p2.x + vx, this.p2.y + vy);

                        if (this.isFilled) {
                            ctx.lineTo(this.p2.x, this.p2.y);
                            ctx.fillStyle = this.color ? this.color.replace('0.2', '0.4') : "rgba(39, 174, 96, 0.3)";
                            ctx.fill();
                        }
                        ctx.stroke();
                    }
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.p2.x, this.p2.y);
                    ctx.arc(this.p2.x, this.p2.y, radius, a1, a2, !this.isCounterClockwise);
                    ctx.closePath();

                    if (this.isFilled) {
                        ctx.fillStyle = this.color ? this.color.replace('0.2', '0.4') : "rgba(39, 174, 96, 0.3)";
                        ctx.fill();
                    }
                    ctx.stroke();
                }

                if (this.showValue && !isRightAngle) {
                    let diff = a2 - a1;
                    if (this.isCounterClockwise) {
                        if (diff < 0) diff += 2 * Math.PI;
                    } else {
                        if (diff > 0) diff -= 2 * Math.PI;
                    }

                    const midAngle = a1 + diff / 2;
                    const textDist = radius + 15;
                    const txtVal = Math.round(val) + "¬∞";

                    const tx = this.p2.x + Math.cos(midAngle) * textDist;
                    const ty = this.p2.y + Math.sin(midAngle) * textDist;

                    ctx.font = "bold 12px Segoe UI";
                    const tw = ctx.measureText(txtVal).width;
                    ctx.fillStyle = "rgba(255,255,255,0.7)";
                    ctx.fillRect(tx - tw / 2 - 2, ty - 8, tw + 4, 16);

                    ctx.fillStyle = s;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(txtVal, tx, ty);
                }
            }
        }

        class ParallelLine extends GeometryObject {
            constructor(p1, refLine, id = null) {
                super(p1, null, id);
                this.refLine = refLine;
                this.lineWidth = 3;
            }
            getDynamicP2() {
                if (!this.p1 || !this.refLine) return null;
                const c = MathUtils.getLineCoords(this.refLine);
                if (!c.p1 || !c.p2) return null;
                return {
                    x: this.p1.x + (c.p2.x - c.p1.x),
                    y: this.p1.y + (c.p2.y - c.p1.y)
                };
            }
            isNear(mx, my) {
                const p2 = this.getDynamicP2();
                if (!p2) return false;
                return MathUtils.distanceToLineVector(mx, my, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y) < 8;
            }
            draw(ctx, o) {
                const p2 = this.getDynamicP2();
                if (!this.p1 || !p2) return;
                const s = this.getStyle("black", o.isHovered, o.isToDelete);
                MathUtils.drawInfiniteLineFromVector(ctx, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y, s.color, s.width, s.dash);
            }
        }
        class PerpendicularLine extends GeometryObject {
            constructor(p1, refLine, id = null) {
                super(p1, null, id);
                this.refLine = refLine;
                this.lineWidth = 2;
            }

            getDynamicP2() {
                if (!this.p1 || !this.refLine) return null;
                const c = MathUtils.getLineCoords(this.refLine);
                if (!c.p1 || !c.p2) return null;
                const dx = c.p2.x - c.p1.x;
                const dy = c.p2.y - c.p1.y;
                return { x: this.p1.x - dy, y: this.p1.y + dx };
            }

            isNear(mx, my) {
                const p2 = this.getDynamicP2();
                if (!p2) return false;
                return MathUtils.distanceToLineVector(mx, my, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y) < 8;
            }

            draw(ctx, o) {
                const p2 = this.getDynamicP2();
                if (!this.p1 || !p2) return;

                const s = this.getStyle("black", o.isHovered, o.isToDelete);

                // 1. Tracer la ligne infinie
                MathUtils.drawInfiniteLineFromVector(ctx, this.p1.x, this.p1.y, p2.x - this.p1.x, p2.y - this.p1.y, s.color, s.width, s.dash);

                // 2. Tracer le codage (Petit carr√©)
                const c = MathUtils.getLineCoords(this.refLine);
                if (c.p1 && c.p2) {
                    const infiniteRef = { p1: c.p1, p2: c.p2, constructor: { name: 'Line' } };
                    const H = MathUtils.getProjectedPoint(this.p1.x, this.p1.y, infiniteRef);
                    const angle = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);

                    ctx.save();
                    ctx.translate(H.x, H.y);
                    ctx.rotate(angle);

                    const dx = this.p1.x - H.x;
                    const dy = this.p1.y - H.y;
                    const localY = -dx * Math.sin(angle) + dy * Math.cos(angle);
                    const sign = localY >= 0 ? 1 : -1;

                    const size = 12;
                    ctx.beginPath();
                    ctx.lineWidth = 1.5;
                    ctx.strokeStyle = s.color;
                    ctx.setLineDash([]);

                    ctx.moveTo(size, 0);
                    ctx.lineTo(size, sign * size);
                    ctx.lineTo(0, sign * size);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        class Polygon extends GeometryObject {
            constructor(points, id) {
                super(null, null, id);
                this.points = points;
                this.color = 'rgba(0, 150, 255, 0.2)';
                this.fillMode = 'solid';
                this.opacity = 0.2; // Opacit√© standard
            }
            getClosestSegment(mx, my) {
                let m = Infinity;
                let s = null;
                for (let i = 0; i < this.points.length; i++) {
                    const p1 = this.points[i],
                        p2 = this.points[(i + 1) % this.points.length];
                    const d = MathUtils.distanceToLine(mx, my, p1.x, p1.y, p2.x, p2.y, 'Segment');
                    if (d < m) {
                        m = d;
                        s = [p1, p2];
                    }
                }
                return {
                    seg: s,
                    dist: m
                };
            }
            isNear(mx, my) {
                if (!this.points || this.points.length < 3) return false;
                // Si on clique trop pr√®s du bord, on laisse la main aux segments du contour
                if (this.getClosestSegment(mx, my).dist < 8) return false;

                let inside = false;
                for (let i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
                    const xi = this.points[i].x;
                    const yi = this.points[i].y;
                    const xj = this.points[j].x;
                    const yj = this.points[j].y;

                    const intersect = ((yi > my) !== (yj > my)) &&
                        (mx < (xj - xi) * (my - yi) / (yj - yi) + xi);

                    if (intersect) inside = !inside;
                }
                return inside;
            }
            draw(ctx, o) {
                if (this.points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
                ctx.closePath();
                ctx.fillStyle = this.color;
                if (o.isHovered) ctx.fillStyle = 'rgba(0, 200, 255, 0.4)';
                if (o.isToDelete) ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.globalAlpha = 0.5;
                if (this.fillMode === 'solid') {
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                else if (this.fillMode === 'hatch') {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = PatternUtils.createHatchPattern(ctx, this.color);
                    ctx.fill();
                }
                else if (this.fillMode === 'dots') {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = PatternUtils.createDotPattern(ctx, this.color);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.strokeStyle = o.isToDelete ? '#d32f2f' : (o.isHovered ? '#00bcd4' : '#555');
                ctx.lineWidth = 1;
                ctx.setLineDash(this.dash);
                ctx.stroke();
            }
        }
        class Arc extends GeometryObject {
            constructor(center, radius, startAngle, endAngle, id = null) {
                super(null, null, id);
                this.center = center;
                this.radius = radius;
                this.startAngle = startAngle;
                this.endAngle = endAngle;
            }
            isNear(mx, my) {
                if (!this.center) return false;
                const d = MathUtils.dist(mx, my, this.center.x, this.center.y);
                if (Math.abs(d - this.radius) > 8) return false;
                return MathUtils.isPointOnArc({
                    x: mx,
                    y: my
                }, this);
            }
            draw(ctx, opts) {
                if (!this.center) return;
                ctx.beginPath();
                const s = this.getStyle("black", opts.isHovered, opts.isToDelete);
                ctx.strokeStyle = s.color;
                ctx.lineWidth = s.width;
                ctx.setLineDash(s.dash);
                ctx.arc(this.center.x, this.center.y, this.radius, this.startAngle, this.endAngle, this.startAngle > this.endAngle);
                ctx.stroke();
            }
        }

        // --- WIDGETS ---
        class CompassWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 120;
                this.angle = 0;
                this.legLength = 280;
                this.widgetRotationOffset = 0;
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }
            getHitZone(mx, my) {
                const local = this.toLocal(mx, my);
                const h = Math.sqrt(this.legLength ** 2 - (this.radius / 2) ** 2);
                const headX = this.radius / 2;
                const headY = -h;
                if (MathUtils.dist(local.x, local.y, this.radius, 0) < 20) return 'trace';
                if (MathUtils.distanceToSegment(local.x, local.y, headX, headY, 0, 0) < 20) return 'move';
                const legStartX = this.radius;
                const legStartY = 0;
                const legEndX = headX;
                const legEndY = headY;
                const resizeEndPos = {
                    x: legStartX + (legEndX - legStartX) * 0.15,
                    y: legStartY + (legEndY - legStartY) * 0.15
                };
                if (MathUtils.distanceToSegment(local.x, local.y, legStartX, legStartY - 20, resizeEndPos.x, resizeEndPos.y) < 15) return 'resize';
                if (MathUtils.dist(local.x, local.y, 0, 0) < 30) return 'move';
                if (MathUtils.distanceToSegment(local.x, local.y, resizeEndPos.x, resizeEndPos.y, headX, headY) < 15) return 'rotate';
                return null;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                const h = Math.sqrt(this.legLength ** 2 - (this.radius / 2) ** 2);
                const headX = this.radius / 2;
                const headY = -h;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.strokeStyle = "#7f8c8d";
                ctx.lineWidth = 8;
                ctx.moveTo(headX, headY);
                ctx.lineTo(headX * 0.15, headY * 0.15);
                ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = "#2c3e50";
                ctx.lineWidth = 2;
                ctx.moveTo(headX * 0.15, headY * 0.15);
                ctx.lineTo(0, 0);
                ctx.stroke();
                ctx.beginPath();
                ctx.fillStyle = "#2c3e50";
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                const legStartX = this.radius;
                const legStartY = 0;
                const legEndX = headX;
                const legEndY = headY;
                const resizeEndRatio = 0.2;
                const resizeEndPos = {
                    x: legStartX + (legEndX - legStartX) * resizeEndRatio,
                    y: legStartY + (legEndY - legStartY) * resizeEndRatio
                };
                ctx.beginPath();
                ctx.strokeStyle = "#f39c12";
                ctx.lineWidth = 7;
                ctx.moveTo(headX, headY);
                ctx.lineTo(resizeEndPos.x, resizeEndPos.y);
                ctx.stroke();
                const triangleHeight = 25;
                const legLen = Math.sqrt((legEndX - legStartX) ** 2 + (legEndY - legStartY) ** 2);
                const triStartRatio = triangleHeight / legLen;
                const triStartPos = {
                    x: legStartX + (legEndX - legStartX) * triStartRatio,
                    y: legStartY + (legEndY - legStartY) * triStartRatio
                };
                ctx.beginPath();
                ctx.strokeStyle = "#95a5a6";
                ctx.lineWidth = 8;
                ctx.moveTo(resizeEndPos.x, resizeEndPos.y);
                ctx.lineTo(triStartPos.x, triStartPos.y);
                ctx.stroke();

                if (app.draggedWidgetMode === 'resize') {
                    ctx.save();
                    // Code mort supprim√© ici
                    // 1. La ligne
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(100, 100, 100, 0.8)";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.radius, 0);
                    ctx.stroke();

                    // 2. Le texte
                    ctx.translate(this.radius / 2, -15);
                    ctx.rotate(-this.angle); // Contre-rotation

                    const text = Math.round((this.radius * 2) / 10) / 10 + "";
                    ctx.font = "bold 12px Arial";
                    const textWidth = ctx.measureText(text).width + 8;

                    ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                    ctx.fillRect(-textWidth / 2, -10, textWidth, 14);

                    ctx.fillStyle = "#333";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(text, 0, -3);

                    ctx.restore();
                }
                const vecX = legEndX - legStartX;
                const vecY = legEndY - legStartY;
                const len = Math.sqrt(vecX * vecX + vecY * vecY);
                const perpX = -vecY / len;
                const perpY = vecX / len;
                const halfWidth = 4;
                ctx.beginPath();
                ctx.moveTo(triStartPos.x + perpX * halfWidth, triStartPos.y + perpY * halfWidth);
                ctx.lineTo(triStartPos.x - perpX * halfWidth, triStartPos.y - perpY * halfWidth);
                ctx.lineTo(this.radius, 0);
                ctx.closePath();
                ctx.fillStyle = "#3498db";
                ctx.fill();
                ctx.beginPath();
                ctx.fillStyle = "#34495e";
                ctx.arc(headX, headY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#ecf0f1";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.fillStyle = "#bdc3c7";
                ctx.arc(headX, headY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class SetSquareWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.scale = 1;
                this.width = 400;
                this.height = 250;
                this.widgetRotationOffset = 0;
                this.slideMode = false;
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }
            getHitZone(mx, my) {
                const l = this.toLocal(mx, my);
                if (l.x > 20 && l.x < 60 && l.y > 20 && l.y < 60) return 'toggleSlide';
                if (l.x >= 5 && l.y >= 5 && (l.y <= -this.height / this.width * l.x + this.height)) {
                    if (l.y < 30) return this.slideMode ? 'slideX' : 'rotate';
                    if (l.x < 30) return this.slideMode ? 'slideY' : 'rotate';
                    return 'move';
                }
                return null;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.width, 0);
                ctx.lineTo(0, this.height);
                ctx.closePath();
                ctx.fillStyle = "rgba(200, 240, 255, 0.5)";
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#2980b9";
                ctx.stroke();
                const mm = 5;
                const cm = 50;
                const padding = 30;
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.font = "10px sans-serif";
                ctx.lineWidth = 1;
                ctx.strokeStyle = "#333";
                for (let i = 0; i <= this.width - padding; i += mm) {
                    let len = 5;
                    if (i % cm === 0) len = 12;
                    else if (i % (cm / 2) === 0) len = 8;
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, len);
                    ctx.stroke();
                    if (i > 0 && i % cm === 0) {
                        ctx.fillText(i / cm, i, 24);
                    }
                }
                for (let i = 0; i <= this.height - padding; i += mm) {
                    let len = 5;
                    if (i % cm === 0) len = 12;
                    else if (i % (cm / 2) === 0) len = 8;
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(len, i);
                    ctx.stroke();
                    if (i > 0 && i % cm === 0) {
                        ctx.save();
                        ctx.translate(24, i);
                        ctx.rotate(-Math.PI / 2);
                        ctx.fillText(i / cm, 0, 0);
                        ctx.restore();
                    }
                }
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0);
                ctx.lineTo(15, 15);
                ctx.lineTo(0, 15);
                ctx.stroke();
                ctx.fillStyle = this.slideMode ? "#4caf50" : "#e67e22";
                ctx.fillRect(40, 40, 20, 20);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.strokeRect(40, 40, 20, 20);
                ctx.fillStyle = "white";
                ctx.font = "14px Arial";
                ctx.fillText(this.slideMode ? "-" : "‚Üª", 50, 53);
                ctx.restore();
            }
        }

        class RulerWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.width = 600;
                this.height = 60;
                this.widgetRotationOffset = 0;
            }
            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }
            getHitZone(mx, my) {
                const l = this.toLocal(mx, my);
                if (l.x >= 0 && l.x <= this.width && l.y >= 5 && l.y <= this.height) {
                    if (l.y < 20 && l.y > 5) return 'rotate';
                    if (l.y > 20 && l.y < this.height - 5 && l.x > 20 && l.x < this.width - 20) return 'move';
                    return null;
                }
                return null;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = "rgba(255, 245, 200, 0.6)";
                ctx.fillRect(0, 0, this.width, this.height);
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, this.width, this.height);
                const mm = 5;
                const cm = 50;
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.font = "11px sans-serif";
                for (let i = 0; i <= this.width - 20; i += mm) {
                    let len = 5;
                    if (i % cm === 0) len = 15;
                    else if (i % (cm / 2) === 0) len = 10;
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, len);
                    ctx.stroke();
                    if (i > 0 && i % cm === 0) ctx.fillText(i / cm, i, 26);
                }
                ctx.restore();
            }
        }

        class ProtractorWidget {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.radius = 180;
                this.isLocked = false;
                this.isReversed = false;
            }

            toLocal(mx, my) {
                const dx = mx - this.x;
                const dy = my - this.y;
                return {
                    x: dx * Math.cos(-this.angle) - dy * Math.sin(-this.angle),
                    y: dx * Math.sin(-this.angle) + dy * Math.cos(-this.angle)
                };
            }

            getHitZone(mx, my) {
                const l = this.toLocal(mx, my);
                const d = Math.sqrt(l.x * l.x + l.y * l.y);

                // 1. BOUTON CADENAS (Centr√©)
                if (Math.abs(l.x) < 12 && l.y < -30 && l.y > -60) return 'toggleLock';

                // 2. BOUTON SWAP
                if (Math.abs(l.x) < 12 && l.y >= -85 && l.y <= -61) return 'toggleSwap';

                // 3. LOGIQUE DE MOUVEMENT
                if (this.isLocked) {
                    if (d < 30) return 'traceAngle';
                    return null;
                }

                if (d < 20) return 'move';
                // Zone de rotation
                if (d > this.radius - 30 && d < this.radius + 10 && l.y < 0) return 'rotate';
                // Corps du rapporteur
                if (d < this.radius && l.y < 0) return 'move';

                return null;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // --- 1. FOND ---
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, Math.PI, 0);
                ctx.closePath();

                ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = this.isLocked ? "#aaa" : "#444";
                ctx.stroke();

                // --- 2. CROIX CENTRALE ---
                ctx.beginPath();
                ctx.moveTo(0, -10); ctx.lineTo(0, 0);
                ctx.moveTo(-10, 0); ctx.lineTo(10, 0);
                ctx.strokeStyle = "red";
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.stroke();

                // --- 3. GRADUATIONS ---
                ctx.strokeStyle = "#333";
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.font = "10px sans-serif";

                for (let i = 0; i <= 180; i++) {
                    const ang = Math.PI + (i * Math.PI / 180);
                    const cos = Math.cos(ang);
                    const sin = Math.sin(ang);
                    let len = 5;
                    if (i % 5 === 0) len = 10;
                    if (i % 10 === 0) len = 15;

                    ctx.beginPath();
                    ctx.moveTo(cos * (this.radius - len), sin * (this.radius - len));
                    ctx.lineTo(cos * this.radius, sin * this.radius);
                    ctx.stroke();

                    // Affichage des chiffres
                    if (i % 10 === 0) {
                        let labelValue = this.isReversed ? (180 - i) : i;
                        ctx.save();
                        ctx.translate(cos * (this.radius - 25), sin * (this.radius - 25));
                        ctx.fillText(labelValue, 0, 0);
                        ctx.restore();
                    }
                }

                // --- 4. BOUTON CADENAS ---
                ctx.fillStyle = this.isLocked ? "#e74c3c" : "#2ecc71";
                ctx.beginPath();
                ctx.rect(-12, -55, 24, 24);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Dessin cadenas
                ctx.beginPath();
                if (this.isLocked) {
                    ctx.strokeRect(-6, -45, 12, 9);
                    ctx.beginPath(); ctx.arc(0, -45, 4, Math.PI, 0); ctx.stroke();
                } else {
                    ctx.strokeRect(-6, -43, 12, 7);
                    ctx.beginPath(); ctx.arc(0, -45, 4, Math.PI, 0); ctx.stroke();
                }

                // Bouton Swap
                ctx.fillStyle = "#3498db";
                ctx.beginPath();
                ctx.rect(-12, -85, 24, 24);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.stroke();

                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "bold 16px sans-serif";
                ctx.fillText("‚Üî", 0, -73);

                ctx.restore();
            }
        }

        // ADDED: ToolAnimation class for recording movements
        class ToolAnimation {
            constructor(widgetType, startState, endState, id = null) {
                this.id = id || generateId();
                this.widgetType = widgetType;
                this.startState = startState;
                this.endState = endState;
            }
            draw(ctx) { } // Invisible
            isNear() {
                return false;
            }
        }

        class GeometrieApp {


            showToast(message) {
                const toast = document.getElementById("toast-notification");
                if (!toast) return;
                toast.innerText = message;
                toast.className = "show";
                if (this.toastTimeout) clearTimeout(this.toastTimeout);
                this.toastTimeout = setTimeout(() => {
                    toast.className = toast.className.replace("show", "");
                }, 3000);
            }

            toggleInstructions() {
                const box = document.getElementById('instructionBox');
                if (box.style.display === 'none') {
                    box.style.display = 'flex';
                    this.initInstructionDrag(); // On active le drag
                } else {
                    box.style.display = 'none';
                }
            }

            // Logique de d√©placement (m√™me principe que le clavier virtuel)
            initInstructionDrag() {
                const box = document.getElementById('instructionBox');
                const handle = document.getElementById('instrDragHandle');

                // √âvite d'ajouter 50 √©couteurs si on clique plusieurs fois
                if (box.dataset.draggable === "true") return;
                box.dataset.draggable = "true";

                let isDragging = false;
                let startX, startY, initLeft, initTop;

                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = box.getBoundingClientRect();
                    initLeft = rect.left;
                    initTop = rect.top;
                    e.preventDefault(); // Important
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    box.style.left = (initLeft + dx) + 'px';
                    box.style.top = (initTop + dy) + 'px';
                    box.style.right = 'auto'; // On casse l'ancrage √† droite par d√©faut
                });

                window.addEventListener('mouseup', () => isDragging = false);
            }
            copyToClipboard() {
                // 1. Calcul de la zone utile (Exactement comme exportImage)
                const bounds = this.getSceneBounds();
                if (!bounds) {
                    alert("La feuille est vide !");
                    return;
                }

                // 2. Marge
                const padding = 40;
                const width = bounds.maxX - bounds.minX + (padding * 2);
                const height = bounds.maxY - bounds.minY + (padding * 2);

                // 3. Canvas temporaire
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width * this.dpr;
                tempCanvas.height = height * this.dpr;
                const ctx = tempCanvas.getContext('2d');

                // 4. Dessin
                ctx.scale(this.dpr, this.dpr);

                // Fond BLANC obligatoire (sinon fond noir/transparent al√©atoire selon o√π on colle)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);

                ctx.translate(-bounds.minX + padding, -bounds.minY + padding);

                // On redessine tout proprement
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'Point': 2, 'TextLabel': 2 };
                const toDraw = this.entities.slice().sort((a, b) => (zIndex[a.constructor.name] || 0) - (zIndex[b.constructor.name] || 0));

                toDraw.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    e.draw(ctx, { isHovered: false, isSelected: false });
                });

                // 5. Envoi au presse-papier
                tempCanvas.toBlob(blob => {
                    try {
                        // Cr√©ation de l'objet presse-papier
                        const item = new ClipboardItem({ 'image/png': blob });

                        navigator.clipboard.write([item]).then(() => {
                            // Petit feedback visuel : Le bouton change bri√®vement
                            const btn = document.getElementById('btnCopy');
                            if (btn) {
                                const originalHTML = btn.innerHTML;
                                // On met une coche verte
                                btn.innerHTML = '<svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="#27ae60" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                                // On remet l'ic√¥ne normale apr√®s 1.5 seconde
                                setTimeout(() => btn.innerHTML = originalHTML, 1500);
                                this.showToast("‚úÖ Image copi√©e dans le presse-papier !");
                            }
                        });
                    } catch (err) {
                        console.error("Erreur copie : ", err);
                        alert("Erreur lors de la copie (Navigateur non support√© ?)");
                    }
                });

            }

            toggleHelp() {
                const modal = document.getElementById('helpModal');
                // On bascule l'affichage
                if (modal.style.display === 'flex') {
                    modal.style.display = 'none';
                    this.isLocked = false; // On d√©verrouille l'interface derri√®re
                } else {
                    modal.style.display = 'flex';
                    this.isLocked = true; // On emp√™che de dessiner par erreur en cliquant √† travers
                }
            }

            getSafeFilename(extension) {
                let name = this.projectTitle || "figure_geosoft";
                // On remplace les espaces par des underscores et on enl√®ve les caract√®res bizarres
                name = name.trim().replace(/ /g, "_").replace(/[^a-zA-Z0-9_\u00C0-\u00FF-]/g, "");
                if (name === "") name = "sans_titre";
                return `${name}.${extension}`;
            }

            getSceneBounds() {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let hasObjects = false;

                // Fonction interne pour √©tendre les limites
                const extend = (x, y) => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                    hasObjects = true;
                };

                this.entities.forEach(e => {
                    if (!e.visible && e instanceof Point) return; // Ignore les points cach√©s

                    if (e instanceof Point || e instanceof TextLabel) {
                        extend(e.x, e.y);
                    }
                    else if (e instanceof Segment || e instanceof Line || e instanceof Ray || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        const c = MathUtils.getLineCoords(e);
                        if (c.p1 && c.p2) {
                            extend(c.p1.x, c.p1.y);
                            extend(c.p2.x, c.p2.y);
                        }
                    }
                    else if (e instanceof Circle || e instanceof CompassCircle) {
                        const p1 = e.p1 || e.center;
                        const r = (e.getRadius) ? e.getRadius() : MathUtils.dist(e.p1.x, e.p1.y, e.p2.x, e.p2.y);
                        if (p1 && r > 0) {
                            extend(p1.x - r, p1.y - r);
                            extend(p1.x + r, p1.y + r);
                        }
                    }
                    else if (e instanceof Arc || e instanceof CompassArc) {
                        // Simplification : on prend la boite englobante du cercle complet pour √™tre s√ªr
                        if (e.center) {
                            extend(e.center.x - e.radius, e.center.y - e.radius);
                            extend(e.center.x + e.radius, e.center.y + e.radius);
                        }
                    }
                    else if (e instanceof Polygon) {
                        e.points.forEach(p => extend(p.x, p.y));
                    }
                });

                if (!hasObjects) return null; // Rien √† dessiner

                return { minX, minY, maxX, maxY };
            }
            /* --- DANS LA CLASSE GeometrieApp --- */

            exportImage(format) {
                // 1. Calculer la zone utile
                const bounds = this.getSceneBounds();

                if (!bounds) {
                    alert("La feuille est vide !");
                    return;
                }

                // 2. Ajouter une marge confortable (padding)
                const padding = 40; // 40px de marge autour
                const width = bounds.maxX - bounds.minX + (padding * 2);
                const height = bounds.maxY - bounds.minY + (padding * 2);

                // 3. Cr√©er un Canvas temporaire (invisible)
                const tempCanvas = document.createElement('canvas');
                // On multiplie par dpr pour la qualit√© HD, comme l'√©cran
                tempCanvas.width = width * this.dpr;
                tempCanvas.height = height * this.dpr;
                const ctx = tempCanvas.getContext('2d');

                // 4. Configurer le contexte (Zoom et Translation)
                // On simule une cam√©ra qui regarde pile sur la zone utile
                ctx.scale(this.dpr, this.dpr);

                // Si JPG, on remplit le fond en BLANC (sinon transparent devient noir)
                if (format === 'jpg') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, width, height);
                }

                // On d√©place l'origine (0,0) pour que le dessin commence apr√®s la marge
                // Astuce : On soustrait le minX pour "ramener" le dessin vers 0
                ctx.translate(-bounds.minX + padding, -bounds.minY + padding);

                // 5. DESSINER !
                // On utilise la m√©thode draw() de chaque objet sur ce NOUVEAU contexte
                // On trie par Z-index pour respecter l'ordre (Polygone dessous, Point dessus)
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'Point': 2, 'TextLabel': 2 };
                const toDraw = this.entities.slice().sort((a, b) => (zIndex[a.constructor.name] || 0) - (zIndex[b.constructor.name] || 0));

                toDraw.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    // On dessine l'objet sur le canvas temporaire
                    // On passe { isHovered: false } pour ne pas avoir les surbrillances
                    e.draw(ctx, { isHovered: false, isSelected: false });
                });

                // 6. T√©l√©charger
                const mimeType = format === 'jpg' ? 'image/jpeg' : 'image/png';
                const dataURL = tempCanvas.toDataURL(mimeType, 0.95); // Qualit√© Max

                const link = document.createElement('a');
                link.download = this.getSafeFilename(format);
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                this.showToast("üñºÔ∏è Image export√©e !");
            }

            initShortcuts() {
                window.addEventListener('keydown', (e) => {
                    // Si on est en train d'√©crire du texte, on ne veut pas que "Suppr" supprime un objet g√©om√©trique !
                    // On v√©rifie si le focus est dans l'input de texte
                    if (document.activeElement === this.editorInput) return;

                    // 1. ECHAP : Annuler l'action en cours ou d√©s√©lectionner
                    if (e.key === 'Escape') {
                        if (this.isDraggingCreation) {
                            // Annuler la cr√©ation en cours (Ligne qui suit la souris)
                            this.creationStartPoint = null;
                            this.isDraggingCreation = false;
                            this.polygonPoints = []; // Reset polygone en cours
                            this.anglePoints = [];   // Reset angle en cours
                            this.render();
                        } else if (this.selectedObject) {
                            // D√©s√©lectionner
                            this.selectedObject = null;
                            document.getElementById('contextMenu').style.display = 'none';
                            this.render();
                        } else {
                            // Revenir √† l'outil par d√©faut (Move)
                            this.setTool('move');
                        }
                    }

                    // 2. SUPPR / BACKSPACE : Supprimer la s√©lection
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.selectedObject) {
                            // On utilise la logique de suppression du menu
                            const list = this.getNetworkToDelete(this.selectedObject);
                            this.entities = this.entities.filter(ent => !list.includes(ent));
                            this.selectedObject = null;
                            this.hoveredEntities = []; // S√©curit√© visuelle
                            document.getElementById('contextMenu').style.display = 'none';

                            this.saveState();
                            this.render();
                        }
                    }

                    // 3. CTRL+Z (Annuler) et CTRL+Y (R√©tablir)
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                        e.preventDefault(); // Emp√™che le navigateur de faire son propre undo
                        this.undo();
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
                        e.preventDefault();
                        this.redo();
                    }

                    // 4. FL√àCHES DIRECTIONNELLES (D√©placement pr√©cis pixel par pixel)
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        if (this.selectedObject && (this.selectedObject instanceof Point || this.selectedObject instanceof TextLabel)) {
                            e.preventDefault();
                            const speed = e.shiftKey ? 10 : 1; // Shift = aller plus vite

                            if (e.key === 'ArrowUp') this.selectedObject.y -= speed;
                            if (e.key === 'ArrowDown') this.selectedObject.y += speed;
                            if (e.key === 'ArrowLeft') this.selectedObject.x -= speed;
                            if (e.key === 'ArrowRight') this.selectedObject.x += speed;

                            // Si c'est un point, mettre √† jour ses parents/enfants
                            if (this.selectedObject.update) this.selectedObject.update();
                            this.updateDependents();

                            this.render();
                            // Note : Pour les fl√®ches, on ne sauvegarde pas l'√©tat √† chaque pixel pour ne pas saturer l'historique
                        }
                    }
                });
            }
            /* --- DANS GeometrieApp --- */

            // Cr√©ation automatique de la sym√©trie d'un objet
            createSymmetry(targetObj, referenceObj, type) {
                const subType = (type === 'central') ? 'symmetry_central' : 'symmetry_axial';

                // CAS 1 : Sym√©trique d'un POINT
                if (targetObj instanceof Point) {
                    // On cr√©e le nouveau point qui d√©pend de (Original + R√©f√©rence)
                    const newLabel = targetObj.label + "'";
                    const newPt = new Point(0, 0, newLabel, [targetObj, referenceObj], null, subType);
                    newPt.pointStyle = targetObj.pointStyle;
                    newPt.color = targetObj.color;
                    newPt.update(); // Calcul initial
                    this.addEntity(newPt);
                }

                // CAS 2 : Sym√©trique d'un SEGMENT (On cr√©e 2 points sym√©triques + 1 segment)
                else if (targetObj instanceof Segment) {
                    this.createSymmetry(targetObj.p1, referenceObj, type);
                    this.createSymmetry(targetObj.p2, referenceObj, type);

                    const p2_prime = this.entities[this.entities.length - 1];
                    const p1_prime = this.entities[this.entities.length - 2];

                    const newSeg = new Segment(p1_prime, p2_prime);
                    newSeg.color = targetObj.color;
                    newSeg.dash = targetObj.dash;
                    this.addEntity(newSeg);
                }

                // CAS 3 : Sym√©trique d'un CERCLE
                else if (targetObj instanceof Circle) {
                    this.createSymmetry(targetObj.center || targetObj.p1, referenceObj, type);
                    const newCenter = this.entities[this.entities.length - 1];

                    if (targetObj.p2) {
                        this.createSymmetry(targetObj.p2, referenceObj, type);
                        const newP2 = this.entities[this.entities.length - 1];
                        const newCircle = new Circle(null, null);
                        newCircle.p1 = newCenter;
                        newCircle.p2 = newP2;
                        newCircle.color = targetObj.color;
                        this.addEntity(newCircle);
                    }
                }

                // CAS 4 : POLYGONE (R√©cursion sur tous les points)
                else if (targetObj instanceof Polygon) {
                    const newPoints = [];
                    targetObj.points.forEach(p => {
                        this.createSymmetry(p, referenceObj, type);
                        newPoints.push(this.entities[this.entities.length - 1]);
                    });
                    const newPoly = new Polygon(newPoints);
                    newPoly.color = targetObj.color;
                    newPoly.fillMode = targetObj.fillMode;
                    this.addEntity(newPoly);
                }

                this.saveState();
                this.render();
            }
            getClosestPointOnEntity(mx, my, entity) {
                // 1. CAS DU SEGMENT
                if (entity instanceof Segment) {
                    const A = entity.p1;
                    const B = entity.p2;
                    const AtocX = mx - A.x;
                    const AtocY = my - A.y;
                    const AtoBX = B.x - A.x;
                    const AtoBY = B.y - A.y;
                    const len2 = AtoBX * AtoBX + AtoBY * AtoBY;
                    let t = (AtocX * AtoBX + AtocY * AtoBY) / len2;

                    t = Math.max(0, Math.min(1, t));

                    return {
                        x: A.x + t * AtoBX,
                        y: A.y + t * AtoBY
                    };
                }
                if (entity instanceof Circle) {
                    const angle = Math.atan2(my - entity.center.y, mx - entity.center.x);
                    const radius = MathUtils.dist(entity.center.x, entity.center.y, entity.p2.x, entity.p2.y);

                    return {
                        x: entity.center.x + radius * Math.cos(angle),
                        y: entity.center.y + radius * Math.sin(angle)
                    };
                }

                if (entity instanceof Arc) {
                    const radius = MathUtils.dist(entity.center.x, entity.center.y, entity.p2.x, entity.p2.y);
                    let angle = Math.atan2(my - entity.center.y, mx - entity.center.x);

                    const projX = entity.center.x + radius * Math.cos(angle);
                    const projY = entity.center.y + radius * Math.sin(angle);

                    const aStart = Math.atan2(entity.p1.y - entity.center.y, entity.p1.x - entity.center.x);
                    const aEnd = Math.atan2(entity.p2.y - entity.center.y, entity.p2.x - entity.center.x);

                    const dProj = MathUtils.dist(mx, my, projX, projY);
                    const dEnd1 = MathUtils.dist(mx, my, entity.p1.x, entity.p1.y);
                    const dEnd2 = MathUtils.dist(mx, my, entity.p2.x, entity.p2.y);

                    let start = aStart;
                    let end = aEnd;
                    let curr = angle;

                    if (entity.isCounterClockwise) {
                        if (end < start) end += 2 * Math.PI;
                        if (curr < start) curr += 2 * Math.PI;
                    } else {
                        if (start < end) start += 2 * Math.PI;
                        if (curr < end) curr += 2 * Math.PI;
                    }

                    const isInside = entity.isCounterClockwise ? (curr >= start && curr <= end) : (curr >= end && curr <= start);

                    if (isInside) {
                        return { x: projX, y: projY };
                    } else {
                        return (dEnd1 < dEnd2) ? { x: entity.p1.x, y: entity.p1.y } : { x: entity.p2.x, y: entity.p2.y };
                    }
                }

                return { x: mx, y: my };
            }

            setGlobalPointStyle(style) {
                this.defaultPointStyle = style;

                ['cross', 'dot', 'pixel'].forEach(s => {
                    const btn = document.getElementById('btnPt' + s.charAt(0).toUpperCase() + s.slice(1));
                    if (btn) {
                        if (s === style) {
                            btn.style.background = "#e3f2fd";
                            btn.style.color = "#1976d2";
                        } else {
                            btn.style.background = "transparent";
                            btn.style.color = "#555";
                        }
                    }
                });
            }

            togglePanMode() {
                const btn = document.getElementById('btnPan');

                if (this.currentTool === 'pan') {
                    this.setTool('move');
                    btn.classList.remove('active');
                } else {
                    this.setTool('pan');
                    btn.classList.add('active');
                }
            }
            // --- AUTO CODAGE (Baguette Magique) ---
            autoCodeSegments() {
                const segments = this.entities.filter(e => e instanceof Segment);
                if (segments.length < 2) return;

                segments.forEach(s => s.coding = null);

                const groups = {};
                segments.forEach(seg => {
                    const len = MathUtils.dist(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y);
                    const key = Math.round(len * 10) / 10;

                    if (!groups[key]) groups[key] = [];
                    groups[key].push(seg);
                });

                const marks = ['mark-1', 'mark-2', 'mark-3', 'mark-o', 'mark-oo', 'mark-x', 'mark-xx'];
                let markIndex = 0;

                for (const key in groups) {
                    const group = groups[key];
                    if (group.length > 1) {
                        const currentMark = marks[markIndex % marks.length];
                        group.forEach(seg => seg.coding = currentMark);
                        markIndex++;
                    }
                }

                this.saveState();
                this.render();
            }

            showModal(message, onConfirm) {
                const modal = document.getElementById('customModal');
                const txt = document.getElementById('modalMessage');
                const btn = document.getElementById('btnModalConfirm');

                txt.innerText = message;
                modal.style.display = 'flex';

                btn.onclick = () => {
                    onConfirm(); // On lance l'action
                    this.closeModal(); // On ferme
                };

                btn.focus();
            }

            closeModal() {
                document.getElementById('customModal').style.display = 'none';
            }

            toggleGlobalLabels() {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                const hasHidden = points.some(p => p.showLabel === false);
                const newState = hasHidden ? true : false;

                points.forEach(p => p.showLabel = newState);

                this.saveState();
                this.render();
            }

            // 2. Changer la taille globale (+2 ou -2)
            offsetGlobalTextSize(delta) {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                points.forEach(p => {
                    let newSize = (p.fontSize || 14) + delta;
                    if (newSize < 8) newSize = 8;
                    if (newSize > 32) newSize = 32;
                    p.fontSize = newSize;
                });

                if (points.length > 0) this.defaultFontSize = points[0].fontSize;

                this.saveState();
                this.render();
            }

            // 3. Uniformiser (Reset standard)
            resetGlobalText() {
                const points = this.entities.filter(e => e instanceof Point);
                if (points.length === 0) return;

                this.showModal("Remettre tous les textes √† la taille standard (14px) et visibles ?", () => {
                    points.forEach(p => {
                        p.fontSize = 14;
                        p.showLabel = true;
                    });
                    this.defaultFontSize = 14;

                    this.saveState();
                    this.render();
                });
            }
            cyclePointName(direction) {
                if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                const currentLabel = this.selectedObject.label;
                const baseChar = currentLabel.replace(/['‚Äô]/g, "");
                const primes = currentLabel.substring(baseChar.length);

                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                let currentIndex = alphabet.indexOf(baseChar);
                if (currentIndex === -1) currentIndex = 0;

                const usedNames = this.entities
                    .filter(e => e instanceof Point && e !== this.selectedObject)
                    .map(e => e.label);

                let newChar = baseChar;
                let loops = 0;

                do {
                    currentIndex += direction;
                    if (currentIndex >= alphabet.length) currentIndex = 0;
                    if (currentIndex < 0) currentIndex = alphabet.length - 1;

                    newChar = alphabet[currentIndex];
                    loops++;
                    if (loops > 26) break;

                } while (usedNames.includes(newChar + primes));

                this.selectedObject.label = newChar + primes;

                const display = document.getElementById('renamerDisplay');
                if (display) display.innerText = this.selectedObject.label;

                this.saveState();
                this.render();
            }

            addPrime() {
                if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                let label = this.selectedObject.label;

                if (label.endsWith("'''")) {
                    label = label.substring(0, label.length - 3);
                } else {
                    label += "'";
                }

                this.selectedObject.label = label;
                document.getElementById('renamerDisplay').innerText = label;
                this.saveState();
                this.render();
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                this.dpr = window.devicePixelRatio || 1;

                this.canvas.width = Math.round(rect.width * this.dpr);
                this.canvas.height = Math.round(rect.height * this.dpr);

                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';

                this.render();
            }

            rewindState() {
                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const ent = this.entities[i];

                    if (ent instanceof ToolAnimation && (ent.widgetType === 'pointMove' || ent.widgetType === 'textMove')) {
                        const target = this.entities.find(e => e.id === ent.targetId);

                        if (target) {
                            target.x = ent.startState.x;
                            target.y = ent.startState.y;
                            if (target.update) target.update();
                        }
                    }
                }
                this.updateDependents();
            }


            // --- GESTION GRILLE & AIMANT ---
            toggleMagnet() {
                this.isMagnetActive = !this.isMagnetActive;
                const btn = document.getElementById('btnMagnet');
                if (this.isMagnetActive) {
                    btn.classList.add('active');
                    btn.style.background = '#e67e22';
                } else {
                    btn.classList.remove('active');
                    btn.style.background = '';
                }
            }

            toggleGrid() {
                this.gridMode = (this.gridMode + 1) % 4;
                const labels = ["‚ñ¶ Grille", "‚Åô Points", "‚ñ≥ Iso", "‚ñ° Blanc"];
                document.getElementById('btnGrid').innerText = labels[this.gridMode];
                this.render();
            }

            getSmartCoords(evt) {
                const raw = this.getMousePos(evt);
                if (!this.isMagnetActive || this.gridMode === 3) {
                    this.activeSnapPoint = null;
                    return raw;
                }

                const x = raw.x;
                const y = raw.y;
                let nx = x,
                    ny = y;

                if (this.gridMode === 0 || this.gridMode === 1) {
                    nx = Math.round(x / UNIT) * UNIT;
                    ny = Math.round(y / UNIT) * UNIT;
                }

                else if (this.gridMode === 2) {
                    const isoH = UNIT * Math.sqrt(3) / 2;
                    const row = Math.round(y / isoH);
                    ny = row * isoH;
                    const offset = (row % 2 !== 0) ? (UNIT / 2) : 0;
                    nx = Math.round((x - offset) / UNIT) * UNIT + offset;
                }

                const dist = Math.sqrt((x - nx) ** 2 + (y - ny) ** 2);

                if (dist < 15) {
                    this.activeSnapPoint = {
                        x: nx,
                        y: ny
                    };
                    return {
                        x: nx,
                        y: ny,
                        snapped: true
                    };
                }

                this.activeSnapPoint = null;
                return raw;
            }

            initVirtualKeyboard() {
                this.vkContainer = document.getElementById('virtualKeyboard');
                this.renderKeyboard();

                const handle = document.getElementById('vkHandle');
                let isDraggingVK = false;
                let startX, startY, initLeft, initTop;

                this.vkContainer.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.vk-drag-handle')) {
                        isDraggingVK = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        const rect = this.vkContainer.getBoundingClientRect();
                        initLeft = rect.left;
                        initTop = rect.top;
                        e.preventDefault();
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDraggingVK) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    this.vkContainer.style.left = (initLeft + dx) + 'px';
                    this.vkContainer.style.top = (initTop + dy) + 'px';
                    this.vkContainer.style.transform = 'none';
                });

                window.addEventListener('mouseup', () => { isDraggingVK = false; });
            }

            renderKeyboard() {
                this.vkContainer.innerHTML = '';

                const handle = document.createElement('div');
                handle.className = 'vk-drag-handle';
                handle.id = 'vkHandle';
                this.vkContainer.appendChild(handle);

                const row0 = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"];
                const row1_low = ["a", "z", "e", "r", "t", "y", "u", "i", "o", "p"];
                const row1_up = ["A", "Z", "E", "R", "T", "Y", "U", "I", "O", "P"];
                const row2_low = ["q", "s", "d", "f", "g", "h", "j", "k", "l", "m"];
                const row2_up = ["Q", "S", "D", "F", "G", "H", "J", "K", "L", "M"];
                const row3_low = ["w", "x", "c", "v", "b", "n", ".", ",", "?", "!"];
                const row3_up = ["W", "X", "C", "V", "B", "N", ".", ":", ";", "/"];
                const row4_low = ["√©", "√®", "√†", "√π", "√ß", "'", "-", "(", ")", "="];
                const row4_up = ["√â", "√à", "√Ä", "√ô", "√á", '"', "+", "[", "]", "*"];

                const currentR1 = this.isShift ? row1_up : row1_low;
                const currentR2 = this.isShift ? row2_up : row2_low;
                const currentR3 = this.isShift ? row3_up : row3_low;
                const currentR4 = this.isShift ? row4_up : row4_low;

                this.createRow(row0, 'num');
                this.createRow(currentR1);
                this.createRow(currentR2);

                const div3 = document.createElement('div');
                div3.className = 'vk-row';

                const btnShift = document.createElement('button');
                btnShift.className = 'vk-btn special' + (this.isShift ? ' active-shift' : '');
                btnShift.innerHTML = '‚áß';
                btnShift.onmousedown = (e) => {
                    e.preventDefault();
                    this.toggleShift();
                };
                div3.appendChild(btnShift);

                currentR3.forEach(char => {
                    const btn = document.createElement('button');
                    btn.className = 'vk-btn';
                    btn.innerText = char;
                    btn.onmousedown = (e) => {
                        e.preventDefault();
                        this.typeChar(char);
                    };
                    div3.appendChild(btn);
                });

                const btnBack = document.createElement('button');
                btnBack.className = 'vk-btn special';
                btnBack.innerHTML = '‚å´';
                btnBack.onmousedown = (e) => {
                    e.preventDefault();
                    this.backspace();
                };
                div3.appendChild(btnBack);

                this.vkContainer.appendChild(div3);

                this.createRow(currentR4);

                const divSpace = document.createElement('div');
                divSpace.className = 'vk-row';
                const btnSpace = document.createElement('button');
                btnSpace.className = 'vk-btn space';
                btnSpace.innerText = 'Espace';
                btnSpace.onmousedown = (e) => {
                    e.preventDefault();
                    this.typeChar(' ');
                };
                divSpace.appendChild(btnSpace);
                this.vkContainer.appendChild(divSpace);
            }

            createRow(chars, extraClass = '') {
                const div = document.createElement('div');
                div.className = 'vk-row';
                chars.forEach(char => {
                    const btn = document.createElement('button');
                    btn.className = `vk-btn ${extraClass}`;
                    btn.innerText = char;
                    btn.onmousedown = (e) => {
                        e.preventDefault();
                        this.typeChar(char);
                    };
                    div.appendChild(btn);
                });
                this.vkContainer.appendChild(div);
            }

            toggleShift() {
                this.isShift = !this.isShift;
                this.renderKeyboard();
            }

            typeChar(char) {
                if (this.editorInput) {
                    const start = this.editorInput.selectionStart;
                    const end = this.editorInput.selectionEnd;
                    const text = this.editorInput.value;
                    const before = text.substring(0, start);
                    const after = text.substring(end, text.length);

                    this.editorInput.value = before + char + after;
                    this.editorInput.selectionStart = this.editorInput.selectionEnd = start + 1;
                    this.editorInput.focus();
                }
            }

            backspace() {
                if (this.editorInput) {
                    const start = this.editorInput.selectionStart;
                    const end = this.editorInput.selectionEnd;
                    const text = this.editorInput.value;

                    if (start === end) {
                        if (start > 0) {
                            this.editorInput.value = text.substring(0, start - 1) + text.substring(end);
                            this.editorInput.selectionStart = this.editorInput.selectionEnd = start - 1;
                        }
                    } else {
                        this.editorInput.value = text.substring(0, start) + text.substring(end);
                        this.editorInput.selectionStart = this.editorInput.selectionEnd = start;
                    }
                    this.editorInput.focus();
                }
            }

            applyTextEdit() {
                const val = this.editorInput.value.trim();
                if (this.editingEntity) {
                    if (this.editingEntity instanceof Point) {
                        this.editingEntity.label = val;
                    } else if (this.editingEntity instanceof TextLabel) {
                        if (val === "") {
                            this.entities = this.entities.filter(e => e !== this.editingEntity);
                        } else {
                            this.editingEntity.text = val;
                        }
                    } else if (this.editingEntity.type === 'new' && val !== "") {
                        this.addEntity(new TextLabel(this.editingEntity.x, this.editingEntity.y, val));
                    }
                    this.saveState();
                }
                this.cancelTextEdit();
                this.render();
            }

            cancelTextEdit() {
                this.editorDiv.style.display = 'none';
                this.editingEntity = null;
                this.editorInput.value = "";
                this.canvas.focus();
                document.getElementById('virtualKeyboard').classList.remove('visible');
            }


            constructor(canvasId) {
                this.view = { x: 0, y: 0, zoom: 1 };
                this.projectTitle = "Nom";

                const titleInput = document.getElementById('docTitleInput');
                if (titleInput) {
                    titleInput.oninput = (e) => {
                        this.projectTitle = e.target.value;
                        document.title = "G√©oSoft - " + this.projectTitle;
                    };
                }
                this.isPanning = false;
                this.lastMouseScreen = { x: 0, y: 0 };
                this.initAnimationState();

                this.isShift = false;
                this.initVirtualKeyboard();
                this.editingEntity = null;
                this.editorDiv = document.getElementById('textEditor');
                this.editorInput = document.getElementById('textInput');

                document.getElementById('btnTextSave').onclick = () => this.applyTextEdit();
                document.getElementById('btnTextCancel').onclick = () => this.cancelTextEdit();
                this.editorInput.onkeydown = (e) => {
                    if (e.key === 'Enter') this.applyTextEdit();
                    if (e.key === 'Escape') this.cancelTextEdit();
                    e.stopPropagation();
                };
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.entities = [];
                this.currentTool = 'move';
                this.draggedPoint = null;
                this.creationStartPoint = null;
                this.isDraggingCreation = false;
                this.referenceObject = null;
                this.showTools = true;
                this.mousePos = { x: 0, y: 0 };
                this.hoveredEntities = [];
                this.ghostIntersection = null;
                this.toDeletePreview = [];
                this.polygonPoints = [];
                this.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                this.anglePoints = [];

                this.draggedPoint = null;
                this.draggedText = null;

                this.replayIndex = null;
                this.isPlaying = false;
                this.playInterval = null;
                this.isToolAnimating = false;
                this.toolAnimStartTime = 0;
                this.lastStepTime = 0;

                this.compassWidget = null;
                this.protractorWidget = null;
                this.setSquareWidget = null;
                this.rulerWidget = null;
                this.activeWidgets = {
                    compass: false,
                    protractor: false,
                    setsquare: false,
                    ruler: false
                };

                this.draggedWidget = null;
                this.draggedWidgetMode = null;
                this.widgetOffset = {
                    x: 0,
                    y: 0
                };
                this.widgetRotationOffset = 0;
                this.dragStartMouse = {
                    x: 0,
                    y: 0
                };
                this.dragStartWidget = {
                    x: 0,
                    y: 0
                };

                this.widgetStartState = null;
                this.draggedWidgetType = null;
                this.historyPast = [];
                this.historyFuture = [];
                this.contextMenu = document.getElementById('contextMenu');
                this.selectedObject = null;
                this.initEventListeners();
                this.initShortcuts();
                this.render();

            }


            getWidgetState(widget) {
                if (!widget) return null;
                return {
                    x: widget.x,
                    y: widget.y,
                    angle: widget.angle,
                    radius: widget.radius || 0
                };
            }

            applyInterpolation(anim, t) {
                const ease = t;

                const s = anim.startState;
                const e = anim.endState;

                const lerp = (a, b, t) => a + (b - a) * t;

                const lerpAngle = (a, b, t) => {
                    let diff = b - a;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    return a + diff * t;
                };

                if (anim.widgetType === 'pointMove' || anim.widgetType === 'textMove') {
                    const targetObj = this.entities.find(ent => ent.id === anim.targetId);
                    if (targetObj) {
                        targetObj.x = lerp(s.x, e.x, ease);
                        targetObj.y = lerp(s.y, e.y, ease);
                        if (targetObj.update) targetObj.update();
                        this.updateDependents();
                    }
                    return;
                }

                if (anim.widgetType.endsWith('Hide')) {
                    const realType = anim.widgetType.replace('Hide', '');
                    this.activeWidgets[realType] = false;
                    const btn = document.getElementById('btn-' + realType);
                    if (btn) btn.classList.remove('widget-active');
                    return;
                }

                this.activeWidgets[anim.widgetType] = true;
                const btn = document.getElementById('btn-' + anim.widgetType);
                if (btn) btn.classList.add('widget-active');

                let w = null;
                if (anim.widgetType === 'ruler') {
                    if (!this.rulerWidget) this.rulerWidget = new RulerWidget(0, 0);
                    w = this.rulerWidget;
                } else if (anim.widgetType === 'compass') {
                    if (!this.compassWidget) this.compassWidget = new CompassWidget(0, 0);
                    w = this.compassWidget;
                } else if (anim.widgetType === 'setsquare') {
                    if (!this.setSquareWidget) this.setSquareWidget = new SetSquareWidget(0, 0);
                    w = this.setSquareWidget;
                } else if (anim.widgetType === 'protractor') {
                    if (!this.protractorWidget) this.protractorWidget = new ProtractorWidget(0, 0);
                    w = this.protractorWidget;
                }

                if (w) {
                    w.x = lerp(s.x, e.x, ease);
                    w.y = lerp(s.y, e.y, ease);

                    if (anim.widgetType === 'compass' && this.ArcTracing) {
                        w.angle = lerp(s.angle, e.angle, ease);
                    }
                    else {
                        w.angle = lerpAngle(s.angle, e.angle, ease);
                    }

                    if (w.radius !== undefined && s.radius !== undefined) {
                        w.radius = lerp(s.radius, e.radius, ease);
                    }
                }
            }
            toggleTools() {
                this.showTools = !this.showTools;
                document.getElementById('btnTools').classList.toggle('active');
                this.render();
            }

            clearAll() {
                this.showModal("Voulez-vous vraiment tout effacer ?", () => {
                    this.entities = [];
                    this.historyPast = [];
                    this.historyFuture = [];
                    this.replayIndex = 0;
                    this.resetInteraction();
                    this.saveState();
                    this.render();
                });
            }

            addEntity(entity) {
                this.entities.push(entity);
                this.replayIndex = this.entities.length;
            }

            saveFile() {
                const content = document.getElementById('instrContent').innerHTML;
                const isVisible = document.getElementById('instructionBox').style.display !== 'none';
                const saveData = {
                    title: this.projectTitle,
                    data: this.serialize(),
                    instructions: {
                        html: content,
                        visible: isVisible
                    }
                };

                const json = JSON.stringify(saveData, null, 2);
                const blob = new Blob([json], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                a.download = this.getSafeFilename('geo');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                this.showToast("üíæ Projet sauvegard√© avec succ√®s !");
            }
            loadFile(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = JSON.parse(e.target.result);

                        if (content.title && content.data) {
                            this.projectTitle = content.title;
                            if (content.instructions) {
                                const box = document.getElementById('instructionBox');
                                const div = document.getElementById('instrContent');

                                div.innerHTML = content.instructions.html;

                                if (content.instructions.visible) {
                                    box.style.display = 'flex';
                                    this.initInstructionDrag();
                                } else {
                                    box.style.display = 'none';
                                }
                            } else {
                                document.getElementById('instrContent').innerHTML = '<h3>Exercice :</h3><p>...</p>';
                                document.getElementById('instructionBox').style.display = 'none';
                            }
                            document.getElementById('docTitleInput').value = content.title;
                            document.title = "G√©oSoft - " + content.title;

                            this.entities = this.deserialize(content.data);
                        }
                        else {
                            this.entities = this.deserialize(e.target.result);
                        }

                        this.historyPast = [];
                        this.saveState();
                        this.render();
                    } catch (err) {
                        console.error(err);
                        alert("Erreur chargement fichier");
                    }
                };
                reader.readAsText(file);
                input.value = '';
            }

            initAnimationState() {
                this.defaultPointStyle = 'cross';
                this.globalStyle = {
                    color: '#000000',
                    width: 2,
                    dash: []
                };
                this.ArcTracing = false;
                this.isPaintMode = false;
                this.defaultFontSize = 14;
                this.gridMode = 0;
                this.isMagnetActive = false;
                this.playbackSpeed = 500;
                this.loopDelay = 1000;
                this.isLooping = false;
                this.isLocked = false;
                this.waitEndTime = 0;
                this.view = { x: 0, y: 0, zoom: 1 };
                this.isPanning = false;
                this.lastMouseScreen = { x: 0, y: 0 };
                this.dpr = window.devicePixelRatio || 1;
            }

            setGlobalColor(val) {
                const colorMap = { 'black': '#202124', 'blue': '#1a73e8', 'red': '#d93025', 'green': '#1e8e3e', 'orange': '#e37400' };
                const hex = colorMap[val] || val;
                this.globalStyle.color = hex;

                document.querySelectorAll('.header-dot').forEach(dot => dot.classList.remove('active'));
                const customDot = document.getElementById('colorPreview');
                customDot.classList.add('active');
                customDot.style.background = hex;

                const picker = document.getElementById('globalColorPicker');
                if (picker) picker.value = hex;
            }

            setGlobalWidth(val) {
                const w = parseInt(val);
                this.globalStyle.width = w;

                const icon = document.getElementById('headerStrokeIcon');
                if (icon) {
                    icon.setAttribute('stroke-width', Math.min(w, 6));
                }
            }

            toggleGlobalDash() {
                const btn = document.getElementById('btnGlobalDash');
                if (this.globalStyle.dash.length === 0) {
                    this.globalStyle.dash = [5, 5];
                    btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="2" y1="12" x2="22" y2="12" stroke-width="2" stroke-dasharray="4,2"/></svg>';
                    btn.classList.add('active');
                } else {
                    this.globalStyle.dash = [];
                    btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="2" y1="12" x2="22" y2="12" stroke-width="2"/></svg>';
                    btn.classList.remove('active');
                }
            }

            resetView() {
                this.view = { x: 0, y: 0, zoom: 1 };
                this.render();
            }

            setSpeed(val) {
                const min = 50;
                const max = 1500;
                this.playbackSpeed = max - ((val - 1) * (max - min) / 9);
            }

            setLoopDelay(val) {
                this.loopDelay = parseInt(val);
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                const btn = document.getElementById('btnLoop');
                if (this.isLooping) {
                    btn.classList.add('active');
                    btn.title = "Boucle (ON)";
                } else {
                    btn.classList.remove('active');
                    btn.title = "Boucle (OFF)";
                }
            }

            playFromStart() {
                this.saveState();
                if (this.isPlaying) return;

                this.activeWidgets = { compass: false, protractor: false, setsquare: false, ruler: false };
                ['compass', 'protractor', 'setsquare', 'ruler'].forEach(t => {
                    const btn = document.getElementById('btn-' + t);
                    if (btn) btn.classList.remove('widget-active');
                });
                if (this.historyPast.length > 0) {
                    this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                }

                this.rewindState();

                this.replayIndex = 0;
                this.lockInterface(true);
                this.isPlaying = true;
                this.isToolAnimating = false;
                this.lastStepTime = performance.now();

                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚è∏";
                btn.onclick = () => this.pauseAnimation();

                this.render();
                this.animateLoop();
            }

            pauseAnimation() {
                this.isPlaying = false;
                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚ñ∂";
                btn.onclick = () => this.resumeAnimation();
            }

            resumeAnimation() {
                this.isPlaying = true;
                this.lastStepTime = performance.now();
                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚è∏";
                btn.onclick = () => this.pauseAnimation();
                this.animateLoop();
            }

            stopAnimation() {
                this.isPlaying = false;
                this.isToolAnimating = false;
                this.waitEndTime = 0;

                this.replayIndex = this.entities.length;

                if (this.historyPast.length > 0) {
                    this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                }

                this.lockInterface(false);
                this.render();

                const btn = document.getElementById('btnPlay');
                btn.innerHTML = "‚ñ∂";
                btn.onclick = () => this.playFromStart();
            }

            lockInterface(locked) {
                this.isLocked = locked;
                if (locked) {
                    document.body.classList.add('interface-locked');
                    document.getElementById('contextMenu').style.display = 'none';
                    document.getElementById('textEditor').style.display = 'none';
                } else {
                    document.body.classList.remove('interface-locked');
                }
            }

            animateLoop() {
                if (!this.isPlaying) return;

                const now = performance.now();
                const max = this.entities.length;

                if (this.waitEndTime > 0) {
                    if (now > this.waitEndTime) {
                        this.waitEndTime = 0;
                        this.replayIndex = 0;

                        if (this.historyPast.length > 0) {
                            this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                        }
                        this.rewindState();

                        this.lastStepTime = now;
                    }
                    this.render();
                    requestAnimationFrame(() => this.animateLoop());
                    return;
                }

                if (this.isToolAnimating) {
                    const elapsed = now - this.toolAnimStartTime;
                    const anim = this.entities[this.replayIndex];
                    let duration = this.playbackSpeed;

                    if (anim && anim.startState && anim.endState &&
                        typeof anim.startState.angle === 'number' &&
                        typeof anim.endState.angle === 'number') {

                        const startA = anim.startState.angle;
                        const endA = anim.endState.angle;
                        const delta = Math.abs(endA - startA);

                        if (delta > 0.01) {
                            duration = delta * (this.playbackSpeed * 0.5);
                        }
                    }

                    if (duration < 150) duration = 150;

                    let t = elapsed / duration;
                    if (t > 1) t = 1;

                    if (anim) this.applyInterpolation(anim, t);

                    if (t === 1) {
                        this.isToolAnimating = false;
                        this.replayIndex++;

                        if (this.replayIndex < this.entities.length) {
                            const nextObj = this.entities[this.replayIndex];
                            if (nextObj instanceof CompassArc ||
                                nextObj instanceof Segment ||
                                nextObj instanceof Circle ||
                                nextObj instanceof Line ||
                                nextObj instanceof Ray ||
                                nextObj instanceof Angle ||
                                nextObj instanceof Point) {
                                this.replayIndex++;
                            }
                        }

                        this.lastStepTime = now;
                    }

                    this.render();
                    requestAnimationFrame(() => this.animateLoop());
                    return;
                }

                if (now - this.lastStepTime > this.playbackSpeed) {

                    if (this.replayIndex >= max) {
                        if (this.isLooping) {
                            this.waitEndTime = now + this.loopDelay;
                        } else {
                            this.stopAnimation();
                            return;
                        }
                    } else {
                        const nextEnt = this.entities[this.replayIndex];

                        if (nextEnt instanceof ToolAnimation) {
                            this.isToolAnimating = true;
                            this.toolAnimStartTime = now;
                        } else {
                            this.replayIndex++;
                            this.lastStepTime = now;
                        }
                    }
                }
                this.render();
                requestAnimationFrame(() => this.animateLoop());
            }
            drawRuler(ctx, start, end) {
                if (this.activeWidgets.ruler) return;
                const dist = MathUtils.dist(start.x, start.y, end.x, end.y);
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const length = 600;
                ctx.save();
                ctx.translate(start.x, start.y);
                ctx.rotate(angle);
                ctx.fillStyle = "rgba(240, 248, 255, 0.7)";
                ctx.fillRect(0, 0, 600 + 20, 60);
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, 600 + 20, 60);
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.font = "10px Arial";
                for (let i = 0; i <= 600; i += 5) {
                    const h = (i % 50 === 0) ? 25 : ((i % 50 === 25) ? 20 : 15);
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, h);
                    ctx.stroke();
                    if (i % 50 === 0 && i != 0) ctx.fillText(i / 50, i, 40);
                }
                ctx.restore();
            }
            drawPerpendicularHint(ctx, refObj, mouse) {
                const P = MathUtils.getProjectedPoint(mouse.x, mouse.y, refObj);
                const c = MathUtils.getLineCoords(refObj);
                const angle = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);
                ctx.save();
                ctx.translate(P.x, P.y);
                ctx.rotate(angle);
                const dx = mouse.x - P.x;
                const dy = mouse.y - P.y;
                const localY = -dx * Math.sin(angle) + dy * Math.cos(angle);
                ctx.scale(1, localY > 0 ? -1 : 1);
                ctx.fillStyle = "rgba(200, 235, 255, 0.8)";
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -300);
                ctx.lineTo(-180, 0);
                ctx.lineTo(0, 0);
                ctx.fill();
                ctx.strokeStyle = "#888";
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.beginPath();
                ctx.moveTo(-30, -30);
                ctx.lineTo(-30, -120);
                ctx.lineTo(-90, -30);
                ctx.fill();
                ctx.restore();
            }

            styleObject(action) {
                this.saveState();
                if (!this.selectedObject) return;
                if (action.startsWith('fill-')) {
                    if (this.selectedObject instanceof Polygon) {
                        this.selectedObject.fillMode = action.replace('fill-', '');
                    }
                }

                const colorMap = {
                    'black': '#333',
                    'blue': '#2980b9',
                    'red': '#c0392b',
                    'green': '#27ae60',
                    'orange': '#e67e22',
                    'purple': '#8e44ad',
                    'gray': '#7f8c8d',
                    'pink': '#e91e63',
                    'yellow': '#f1c40f',
                    'cyan': '#1abc9c'
                };
                if (colorMap[action]) {
                    if (this.selectedObject instanceof Polygon) this.selectedObject.color = colorMap[action].replace(')', ',0.2)'); // Astuce rgba rapide
                    else this.selectedObject.color = colorMap[action];
                }

                else if (action === 'solid') this.selectedObject.dash = [];
                else if (action === 'dashed') this.selectedObject.dash = [5, 5];

                else if (this.selectedObject instanceof Segment) {
                    if (action === 'toggleLength-off') {
                        this.selectedObject.showLength = false;
                    } else if (action === 'measureUp') {
                        this.selectedObject.showLength = true;
                        this.selectedObject.measureOffset = -15;
                    } else if (action === 'measureDown') {
                        this.selectedObject.showLength = true;
                        this.selectedObject.measureOffset = 20;
                    }
                    else if (action.startsWith('mark-')) {
                        this.selectedObject.coding = action;
                    }
                }

                else if (this.selectedObject instanceof Angle) {
                    if (action === 'flipAngle') this.selectedObject.isCounterClockwise = !this.selectedObject.isCounterClockwise;
                    else if (action === 'toggleAngleVal') this.selectedObject.showValue = !this.selectedObject.showValue;
                    else if (action === 'toggleAngleFill') this.selectedObject.isFilled = !this.selectedObject.isFilled;
                } else if (action === 'toggleLabel') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.showLabel = !this.selectedObject.showLabel;
                    }
                } else if (action === 'textSize-inc') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.fontSize = (this.selectedObject.fontSize || 14) + 2;
                        if (this.selectedObject.fontSize > 32) this.selectedObject.fontSize = 32;
                        this.defaultFontSize = this.selectedObject.fontSize;
                    }
                } else if (action === 'textSize-dec') {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.fontSize = (this.selectedObject.fontSize || 14) - 2;
                        if (this.selectedObject.fontSize < 8) this.selectedObject.fontSize = 8;
                        this.defaultFontSize = this.selectedObject.fontSize;
                    }
                }
                else if (action.startsWith('pointStyle-')) {
                    if (this.selectedObject instanceof Point) {
                        this.selectedObject.pointStyle = action.split('-')[1];
                    }
                }

                this.updateContextMenuUI();
                this.render();
            }

            updateContextMenuUI() {
                if (!this.selectedObject) return;

                document.querySelectorAll('.icon-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.switch-btn').forEach(b => b.classList.remove('active'));

                if (this.selectedObject instanceof Segment) {
                    if (!this.selectedObject.showLength) {
                        document.getElementById('btnMesNone').classList.add('active');
                    } else if (this.selectedObject.measureOffset < 0) {
                        document.getElementById('btnMesUp').classList.add('active');
                    } else {
                        document.getElementById('btnMesDown').classList.add('active');
                    }
                }

                const rowFill = document.getElementById('rowFill');
                const sepFill = document.getElementById('sepFill');


                if (this.selectedObject instanceof Polygon) {
                    rowFill.style.display = 'flex';
                    sepFill.style.display = 'block';

                    const mode = this.selectedObject.fillMode || 'solid';
                    const btn = rowFill.querySelector(`.icon-btn[onclick="app.styleObject('fill-${mode}')"]`);
                    if (btn) btn.classList.add('active');

                    if (document.getElementById('rowAngle')) document.getElementById('rowAngle').style.display = 'none';
                    if (document.getElementById('rowMeasure')) document.getElementById('rowMeasure').style.display = 'none';
                    if (document.getElementById('rowCoding')) document.getElementById('rowCoding').style.display = 'none';

                }
                else {
                    rowFill.style.display = 'none';
                    sepFill.style.display = 'none';
                }

                if (this.selectedObject instanceof Angle) {
                    if (this.selectedObject.showValue) document.getElementById('btnToggleAngleVal').classList.add('active');
                    if (this.selectedObject.isFilled) document.getElementById('btnToggleAngleFill').classList.add('active');
                }
            }
            previewLineWidth(val) {
                if (this.selectedObject) {
                    this.selectedObject.lineWidth = parseInt(val);
                    this.render();
                }
            }
            setLineWidth(val) {
                if (this.selectedObject) {
                    this.selectedObject.lineWidth = parseInt(val);
                    this.saveState();
                }
            }
            deleteFromMenu() {
                this.saveState();
                if (this.selectedObject) {
                    const list = this.getNetworkToDelete(this.selectedObject);
                    this.entities = this.entities.filter(e => !list.includes(e));
                }
                this.contextMenu.style.display = 'none';
                this.render();
            }


            serialize() {
                const state = this.entities.map(e => {
                    if (e instanceof ToolAnimation) {
                        return {
                            type: 'ToolAnimation',
                            id: e.id,
                            widgetType: e.widgetType,
                            startState: e.startState,
                            endState: e.endState,
                            targetId: e.targetId
                        };
                    }
                    const data = {
                        type: e.constructor.name,
                        id: e.id,
                        color: e.color,
                        dash: e.dash,
                        lineWidth: e.lineWidth,
                        showLength: e.showLength,
                        measureOffset: e.measureOffset
                    };
                    if (e instanceof Point) {
                        data.x = e.x;
                        data.y = e.y;
                        data.subType = e.subType;
                        data.pointStyle = e.pointStyle;
                        data.color = e.color;
                        data.label = e.label;
                        data.showLabel = e.showLabel;
                        data.labelAngle = e.labelAngle;
                        data.fontSize = e.fontSize;
                        data.showLabel = e.showLabel;
                        data.parentIds = e.parents.map(p => {
                            if (Array.isArray(p)) return [p[0].id, p[1].id];
                            return p.id;
                        });
                    } else if (e instanceof Segment) {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                        if (e.coding) data.coding = e.coding;
                    } else if (e instanceof Angle) {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                        data.p3Id = e.p3.id;
                        data.isCCW = e.isCounterClockwise;
                        data.showVal = e.showValue;
                        data.isFilled = e.isFilled;
                    } else if (e instanceof Polygon) {
                        data.fillMode = e.fillMode;
                        data.pointIds = e.points.map(p => p.id);
                    } else if (e instanceof CompassArc) {
                        if (e.center instanceof Point) {
                            data.centerId = e.center.id;
                        } else {
                            data.cx = e.center.x;
                            data.cy = e.center.y;
                        }
                        data.radius = e.radius;
                        data.startA = e.startAngle;
                        data.endA = e.endAngle;
                        data.counterClockwise = e.counterClockwise
                    } else if (e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        data.p1Id = e.p1.id;
                        data.refLineId = e.refLine.id;
                    } else if (e instanceof Arc) {
                        data.centerId = e.center.id;
                        data.radius = e.radius;
                        data.startA = e.startAngle;
                        data.endA = e.endAngle;
                    } else if (e instanceof TextLabel) {
                        data.x = e.x;
                        data.y = e.y;
                        data.text = e.text;
                        data.fontSize = e.fontSize;
                        data.fontFamily = e.fontFamily;
                    } else {
                        data.p1Id = e.p1.id;
                        data.p2Id = e.p2.id;
                    }
                    return data;
                });
                return JSON.stringify(state);
            }

            deserialize(jsonString) {
                const state = JSON.parse(jsonString);
                const idMap = new Map();
                const newEntities = [];
                state.forEach(data => {
                    let obj;
                    if (data.type === 'ToolAnimation') {
                        obj = new ToolAnimation(data.widgetType, data.startState, data.endState, data.id);
                        obj.targetId = data.targetId;
                    } else if (data.type === 'Point') {
                        obj = new Point(data.x, data.y, data.label, [], data.id, data.subType);
                        if (data.pointStyle !== undefined) obj.pointStyle = data.pointStyle;
                        if (data.showLabel !== undefined) obj.showLabel = data.showLabel;
                        if (data.labelAngle !== undefined) obj.labelAngle = data.labelAngle;
                        if (data.fontSize !== undefined) obj.fontSize = data.fontSize;
                        if (data.showLabel !== undefined) obj.showLabel = data.showLabel;
                    } else if (data.type === 'Segment') obj = new Segment(null, null, data.id);
                    else if (data.type === 'Ray') obj = new Ray(null, null, data.id);
                    else if (data.type === 'Line') obj = new Line(null, null, data.id);
                    else if (data.type === 'Circle') obj = new Circle(null, null, data.id);
                    else if (data.type === 'CompassArc') obj = new CompassArc(null, data.radius, data.startA, data.endA, data.counterClockwise, data.id);
                    else if (data.type === 'Angle') obj = new Angle(null, null, null, data.id);
                    else if (data.type === 'ParallelLine') obj = new ParallelLine(null, null, data.id);
                    else if (data.type === 'PerpendicularLine') obj = new PerpendicularLine(null, null, data.id);
                    else if (data.type === 'Polygon') obj = new Polygon([], data.id);
                    else if (data.type === 'Arc') obj = new Arc(null, data.radius, data.startA, data.endA, data.id);
                    else if (data.type === 'TextLabel') {
                        obj = new TextLabel(data.x, data.y, data.text, data.id);
                        if (data.fontSize) obj.fontSize = data.fontSize;
                        if (data.fontFamily) obj.fontFamily = data.fontFamily;
                    }
                    else if (data.type === 'Polygon') {
                        obj = new Polygon([], data.id);
                        obj.points = data.pointIds.map(pid => idMap.get(pid)).filter(p => p);
                        if (data.fillMode) obj.fillMode = data.fillMode;
                    }
                    if (obj) {
                        if (obj instanceof GeometryObject) {
                            obj.color = data.color;
                            obj.dash = data.dash || [];
                            obj.lineWidth = data.lineWidth || 2;
                            if (obj instanceof Segment) {
                                obj.showLength = data.showLength || false;
                                obj.measureOffset = data.measureOffset || -15;
                                obj.coding = data.coding || null;
                            }
                            if (obj instanceof Angle) {
                                obj.isCounterClockwise = data.isCCW;
                                obj.showValue = (data.showVal !== undefined) ? data.showVal : true;
                                obj.isFilled = data.isFilled || false;
                            }
                        }
                        idMap.set(data.id, obj);
                        newEntities.push(obj);
                    }
                });
                state.forEach((data, index) => {
                    const obj = newEntities[index];
                    if (data.type === 'Point') {
                        obj.parents = data.parentIds.map(pid => {
                            if (Array.isArray(pid)) return [idMap.get(pid[0]), idMap.get(pid[1])];
                            return idMap.get(pid);
                        }).filter(p => p);
                        obj.update();
                    } else if (data.type === 'Angle') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.p2 = idMap.get(data.p2Id);
                        obj.p3 = idMap.get(data.p3Id);
                    } else if (data.type === 'CompassArc') {
                        if (data.centerId) obj.center = idMap.get(data.centerId);
                        else obj.center = {
                            x: data.cx,
                            y: data.cy
                        };
                    } else if (data.type === 'Arc') {
                        obj.center = idMap.get(data.centerId);
                    } else if (data.type === 'Polygon') {
                        obj.points = data.pointIds.map(pid => idMap.get(pid)).filter(p => p);
                    } else if (data.type === 'ParallelLine' || data.type === 'PerpendicularLine') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.refLine = idMap.get(data.refLineId);
                    } else if (data.type !== 'ToolAnimation') {
                        obj.p1 = idMap.get(data.p1Id);
                        obj.p2 = idMap.get(data.p2Id);
                    }
                });
                return newEntities;
            }
            saveState() {
                // 1. On g√©n√®re la cha√Æne de sauvegarde une seule fois
                const currentState = this.serialize();

                if (this.historyPast.length > 0) {
                    const lastState = this.historyPast[this.historyPast.length - 1];
                    if (lastState === currentState) {
                        this.replayIndex = this.entities.length;
                        return;
                    }
                }

                // 3. Gestion de la limite de l'historique (50 √©tapes)
                if (this.historyPast.length > 50) this.historyPast.shift();

                // 4. Ajout du nouvel √©tat
                this.historyPast.push(currentState);

                // 5. On vide le futur (car on vient de cr√©er une nouvelle branche temporelle)
                this.historyFuture = [];

                // 6. Mise √† jour variables et UI
                this.replayIndex = this.entities.length;
                this.updateButtons();
            }

            undo() {
                if (this.historyPast.length <= 1) return;
                this.historyFuture.push(this.serialize());
                this.historyPast.pop();
                this.entities = this.deserialize(this.historyPast[this.historyPast.length - 1]);
                this.resetInteraction();
                this.replayIndex = this.entities.length;
                this.render();
                this.updateButtons();
            }

            redo() {
                if (this.historyFuture.length === 0) return;
                const next = this.historyFuture.pop();
                this.historyPast.push(next);
                this.entities = this.deserialize(next);
                this.replayIndex = this.entities.length;
                this.render();
                this.updateButtons();
            }
            updateButtons() {
                document.getElementById('btnUndo').disabled = (this.historyPast.length <= 1);
                document.getElementById('btnRedo').disabled = (this.historyFuture.length === 0);
            }
            resetInteraction() {
                this.hoveredEntities = [];
                this.toDeletePreview = [];
                this.creationStartPoint = null;
                this.isDraggingCreation = false;
                this.referenceObject = null;
                this.polygonPoints = [];
                this.anglePoints = [];
                this.draggedWidgetMode = null;
            }

            toggleWidget(type) {
                const wasActive = this.activeWidgets[type];
                this.activeWidgets[type] = !wasActive;
                const btn = document.getElementById(`btn-${type}`);

                if (this.activeWidgets[type]) {
                    if (btn) btn.classList.add('widget-active');

                    const container = this.canvas.parentElement;
                    const visibleWidth = container.clientWidth;
                    const visibleHeight = container.clientHeight;
                    const screenCenterX = visibleWidth / 2;
                    const screenCenterY = visibleHeight / 2;
                    const viewX = this.view ? this.view.x : 0;
                    const viewY = this.view ? this.view.y : 0;
                    const viewZ = this.view ? this.view.zoom : 1;
                    const worldX = (screenCenterX - viewX) / viewZ;
                    const worldY = (screenCenterY - viewY) / viewZ;

                    if (type === 'compass') {
                        if (!this.compassWidget) this.compassWidget = new CompassWidget(worldX, worldY);
                        else { this.compassWidget.x = worldX; this.compassWidget.y = worldY; }
                    }
                    else if (type === 'protractor') {
                        if (!this.protractorWidget) this.protractorWidget = new ProtractorWidget(worldX, worldY);
                        else { this.protractorWidget.x = worldX; this.protractorWidget.y = worldY; }
                    }
                    else if (type === 'ruler') {
                        const rx = worldX - 300;
                        const ry = worldY - 30;
                        if (!this.rulerWidget) this.rulerWidget = new RulerWidget(rx, ry);
                        else { this.rulerWidget.x = rx; this.rulerWidget.y = ry; }
                    }
                    else if (type === 'setsquare') {
                        const sx = worldX - 140;
                        const sy = worldY - 100;
                        if (!this.setSquareWidget) this.setSquareWidget = new SetSquareWidget(sx, sy);
                        else { this.setSquareWidget.x = sx; this.setSquareWidget.y = sy; }
                    }

                } else {
                    if (btn) btn.classList.remove('widget-active');
                    const anim = new ToolAnimation(type + 'Hide', {}, {});
                    this.addEntity(anim);
                    this.saveState();
                }
                this.render();
            }

            setTool(toolName) {
                if (this.isPaintMode && toolName !== 'move' && toolName !== 'pan') {
                    this.isPaintMode = false;
                    const btnPaint = document.getElementById('btnPaint');
                    if (btnPaint) btnPaint.classList.remove('active');
                    this.canvas.style.cursor = 'default';
                }

                this.currentTool = toolName;
                this.resetInteraction();

                const btnPan = document.getElementById('btnPan');
                if (btnPan) {
                    if (toolName === 'pan') btnPan.classList.add('active');
                    else btnPan.classList.remove('active');
                }

                document.querySelectorAll('.tool-btn:not([id^="btn-"])').forEach(btn => btn.classList.remove('active'));

                if (toolName !== 'pan') {
                    const btn = document.querySelector(`.tool-btn[onclick="app.setTool('${toolName}')"]`);
                    if (btn) btn.classList.add('active');
                }

                this.render();
            }

            togglePaintMode() {
                this.isPaintMode = !this.isPaintMode;
                const btn = document.getElementById('btnPaint');

                if (this.isPaintMode) {
                    btn.classList.add('active');

                    if (this.currentTool === 'pan') {
                        this.isPanning = false;
                        const btnPan = document.getElementById('btnPan');
                        if (btnPan) btnPan.classList.remove('active');
                    }

                    this.currentTool = 'move';
                    this.resetInteraction();

                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    const btnMove = document.querySelector(`.tool-btn[onclick="app.setTool('move')"]`);
                    if (btnMove) btnMove.classList.add('active');

                    this.canvas.style.cursor = 'crosshair';
                } else {
                    btn.classList.remove('active');
                    this.canvas.style.cursor = 'default';
                }
            }

            getMousePos(evt) {
                const rect = this.canvas.getBoundingClientRect();

                // 1. Position brute sur l'√©cran (Pixels)
                const cssX = evt.clientX - rect.left;
                const cssY = evt.clientY - rect.top;

                // 2. Conversion vers le Monde G√©om√©trique (Cam√©ra)
                return {
                    x: (cssX - this.view.x) / this.view.zoom,
                    y: (cssY - this.view.y) / this.view.zoom,
                    screenX: cssX,
                    screenY: cssY
                };
            }

            drawGrid() {
                const width = this.canvas.width / this.dpr / this.view.zoom;
                const height = this.canvas.height / this.dpr / this.view.zoom;

                const left = -this.view.x / this.view.zoom;
                const top = -this.view.y / this.view.zoom;

                if (this.gridMode === 3) {
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(left, top, width, height);
                    return;
                }
                const pad = 2;

                const startX = Math.floor((-this.view.x) / this.view.zoom / UNIT) * UNIT - UNIT * pad;
                const startY = Math.floor((-this.view.y) / this.view.zoom / UNIT) * UNIT - UNIT * pad;

                const endX = Math.ceil((this.canvas.width / this.dpr - this.view.x) / this.view.zoom / UNIT) * UNIT + UNIT * pad;
                const endY = Math.ceil((this.canvas.height / this.dpr - this.view.y) / this.view.zoom / UNIT) * UNIT + UNIT * pad;

                this.ctx.beginPath();

                this.ctx.lineWidth = 1 / this.view.zoom;

                // --- MODE 0 : CARR√âS ---
                if (this.gridMode === 0) {
                    this.ctx.strokeStyle = "#e0e0e0";
                    for (let x = startX; x <= endX; x += UNIT) { this.ctx.moveTo(x, startY); this.ctx.lineTo(x, endY); }
                    for (let y = startY; y <= endY; y += UNIT) { this.ctx.moveTo(startX, y); this.ctx.lineTo(endX, y); }
                    this.ctx.stroke();
                }

                // --- MODE 1 : POINTS ---
                else if (this.gridMode === 1) {
                    this.ctx.fillStyle = "#bdc3c7";
                    for (let x = startX; x <= endX; x += UNIT) {
                        for (let y = startY; y <= endY; y += UNIT) {
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 2 / this.view.zoom, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }

                // --- MODE 2 : ISOM√âTRIQUE ---
                else if (this.gridMode === 2) {
                    this.ctx.strokeStyle = "#dcdcdc";

                    const isoH = UNIT * Math.sqrt(3) / 2;

                    const rowStart = Math.floor(startY / isoH) - 1;
                    const rowEnd = Math.ceil(endY / isoH) + 1;
                    const colStart = Math.floor(startX / UNIT) - 2;
                    const colEnd = Math.ceil(endX / UNIT) + 2;

                    for (let r = rowStart; r < rowEnd; r++) {
                        const y = r * isoH;
                        const offset = (Math.abs(r) % 2 === 1) ? (UNIT / 2) : 0;

                        // 1. Ligne Horizontale
                        this.ctx.moveTo(startX, y);
                        this.ctx.lineTo(endX, y);

                        // 2. Diagonales
                        for (let c = colStart; c < colEnd; c++) {
                            const x = c * UNIT + offset;
                            // Diagonale Bas-Droite
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + UNIT / 2, y + isoH);
                            // Diagonale Bas-Gauche
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x - UNIT / 2, y + isoH);
                        }
                    }
                    this.ctx.stroke();
                }
            }

            getNextLabel() {
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const existingLabels = this.entities
                    .filter(e => e instanceof Point && e.label)
                    .map(e => e.label);

                for (let char of alphabet) {
                    if (!existingLabels.includes(char)) return char;
                }

                for (let char of alphabet) {
                    if (!existingLabels.includes(char + "'")) return char + "'";
                }

                for (let char of alphabet) {
                    if (!existingLabels.includes(char + "''")) return char + "''";
                }

                return "";
            }

            findIntersectionAtMouse(x, y) {
                const geom = this.entities.filter(e => e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine || e instanceof Circle || e instanceof CompassArc || e instanceof Arc); // ALL
                for (let i = 0; i < geom.length; i++) {
                    for (let j = i + 1; j < geom.length; j++) {
                        const pts = MathUtils.getIntersections(geom[i], geom[j]);
                        for (let pt of pts) {
                            if (Math.sqrt((pt.x - x) ** 2 + (pt.y - y) ** 2) < 10) return {
                                x: pt.x,
                                y: pt.y,
                                parents: [geom[i], geom[j]]
                            };
                        }
                    }
                }
                return null;
            }
            updateDependents() {
                this.entities.forEach(entity => {
                    if (entity instanceof Point && entity.parents.length > 0) entity.update();
                });
            }
            getNetworkToDelete(target) {
                let toDelete = [target];
                let changed = true;
                while (changed) {
                    changed = false;
                    this.entities.forEach(e => {
                        if (toDelete.includes(e)) return;
                        let isAttached = false;
                        if (e instanceof ParallelLine || e instanceof PerpendicularLine) {
                            isAttached = (toDelete.includes(e.p1) || toDelete.includes(e.refLine));
                        } else if (e instanceof CompassArc) {
                            isAttached = toDelete.includes(e.center);
                        } else if (e instanceof Angle) {
                            isAttached = toDelete.includes(e.p1) || toDelete.includes(e.p2) || toDelete.includes(e.p3);
                        } else if (e instanceof Arc) {
                            isAttached = toDelete.includes(e.center);
                        } else if (e instanceof GeometryObject) {
                            isAttached = (toDelete.includes(e.p1) || toDelete.includes(e.p2));
                        } else if (e instanceof Polygon) {
                            isAttached = e.points.includes(target);
                        }
                        const isChildIntersection = (e instanceof Point && e.parents.some(p => toDelete.includes(p)));
                        if (isAttached || isChildIntersection) {
                            toDelete.push(e);
                            changed = true;
                        }
                    });
                }
                if (target instanceof Point) {
                    this.entities.forEach(e => {
                        if (e instanceof Polygon && e.points.includes(target)) {
                            const idx = toDelete.indexOf(e);
                            if (idx > -1) toDelete.splice(idx, 1);
                        }
                    });
                }
                return toDelete;
            }
            createPointAt(x, y) {
                const existing = this.hoveredEntities.filter(e => e instanceof Point).pop();
                if (existing) return existing;

                const label = this.getNextLabel();
                let newPoint;

                if (this.ghostIntersection) {
                    newPoint = new Point(this.ghostIntersection.x, this.ghostIntersection.y, label, this.ghostIntersection.parents);
                }
                else {
                    const poly = this.entities.filter(e => e instanceof Polygon).find(p => p.isNear(x, y) === false && p.getClosestSegment(x, y).dist < 8);

                    const support = this.hoveredEntities.slice().reverse().find(e =>
                        e instanceof LinearObject ||
                        e instanceof ParallelLine ||
                        e instanceof PerpendicularLine ||
                        e instanceof Circle ||
                        e instanceof Arc ||
                        e instanceof CompassArc ||
                        e instanceof CompassCircle
                    );

                    if (poly) {
                        const edge = poly.getClosestSegment(x, y);
                        const segObj = { constructor: { name: 'Segment' }, p1: edge.seg[0], p2: edge.seg[1] };
                        const proj = MathUtils.getProjectedPoint(x, y, segObj);
                        newPoint = new Point(proj.x, proj.y, label, [edge.seg]);
                    }
                    else if (support) {
                        const proj = MathUtils.getProjectedPoint(x, y, support);

                        if (proj) {
                            newPoint = new Point(proj.x, proj.y, label, [support]);
                        } else {
                            newPoint = new Point(x, y, label);
                        }
                    }
                    else {
                        newPoint = new Point(x, y, label);
                    }
                }

                if (newPoint) {
                    newPoint.fontSize = this.defaultFontSize;
                    newPoint.showLabel = true;
                    newPoint.color = this.globalStyle.color;
                    newPoint.pointStyle = this.defaultPointStyle;
                    this.addEntity(newPoint);
                }

                return newPoint;
            }

            startTextEditor(x, y, entity = null) {
                this.editingEntity = entity;

                const rect = this.canvas.getBoundingClientRect();
                const editorX = x + rect.left;
                const editorY = y + rect.top;

                this.editorDiv.style.left = editorX + 'px';
                this.editorDiv.style.top = editorY + 'px';
                this.editorDiv.style.display = 'flex';

                const fontInput = document.getElementById('fontFamilyInput');
                const sizeInput = document.getElementById('fontSizeInput');
                const textInput = document.getElementById('textInput');

                if (entity instanceof TextLabel) {
                    textInput.value = entity.text;
                    fontInput.value = entity.fontFamily || "'Segoe UI', sans-serif";
                    sizeInput.value = entity.fontSize || 16;
                } else {
                    textInput.value = "";
                    fontInput.value = "'Segoe UI', sans-serif";
                    sizeInput.value = 16;
                    this.editingEntity = { x: x, y: y, type: 'new' };
                }

                setTimeout(() => textInput.focus(), 50);

                const vk = document.getElementById('virtualKeyboard');
                if (vk) {
                    vk.classList.add('visible');

                    requestAnimationFrame(() => {
                        const inputRect = this.editorDiv.getBoundingClientRect();
                        const vkRect = vk.getBoundingClientRect();

                        let top = inputRect.bottom + 10;
                        let left = inputRect.left + (inputRect.width / 2) - (vkRect.width / 2);

                        const winW = window.innerWidth;
                        const winH = window.innerHeight;

                        if (left < 10) left = 10;
                        if (left + vkRect.width > winW) left = winW - vkRect.width - 10;
                        if (top + vkRect.height > winH) top = inputRect.top - vkRect.height - 10;

                        vk.style.left = left + 'px';
                        vk.style.top = top + 'px';
                        vk.style.transform = 'none';
                    });
                }
            }

            initEventListeners() {
                // --- GESTION TACTILE (TABLETTES) ---
                const touchHandler = (e, type) => {
                    if (e.touches.length > 1) return; // Ignore le zoom √† 2 doigts
                    e.preventDefault(); // Emp√™che le scroll

                    const touch = e.changedTouches[0];
                    const mouseEvent = new MouseEvent(type, {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0,
                        bubbles: true
                    });

                    this.canvas.dispatchEvent(mouseEvent);
                };

                let longPressTimer;
                const LONG_PRESS_DELAY = 600; // Temps en ms avant d√©clenchement (0.6s)
                let touchStartCoords = { x: 0, y: 0 };

                this.canvas.addEventListener('touchstart', (e) => {
                    // On ne g√®re que le doigt unique
                    if (e.touches.length !== 1) return;

                    const touch = e.touches[0];
                    touchStartCoords = { x: touch.clientX, y: touch.clientY };

                    // On lance le chronom√®tre
                    longPressTimer = setTimeout(() => {
                        // Le temps est √©coul√© : C'est un appui long !

                        // 1. On cr√©e un faux √©v√©nement "Clic Droit"
                        const contextMenuEvent = new MouseEvent('contextmenu', {
                            bubbles: true,
                            cancelable: true,
                            view: window,
                            button: 2, // 2 = Clic droit
                            buttons: 2,
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });

                        // 2. On l'envoie au canvas (votre √©couteur existant va r√©agir)
                        this.canvas.dispatchEvent(contextMenuEvent);

                        // Optionnel : petite vibration haptique (Android uniquement)
                        if (navigator.vibrate) navigator.vibrate(50);

                    }, LONG_PRESS_DELAY);
                }, { passive: false });

                // Si on bouge le doigt ou qu'on rel√¢che, on annule le chronom√®tre
                const cancelLongPress = (e) => {
                    // Si on bouge un tout petit peu, √ßa va, mais si on glisse vraiment, on annule
                    if (e.type === 'touchmove') {
                        const touch = e.touches[0];
                        const dist = Math.sqrt(
                            (touch.clientX - touchStartCoords.x) ** 2 +
                            (touch.clientY - touchStartCoords.y) ** 2
                        );
                        if (dist < 10) return; // Mouvement n√©gligeable (< 10px), on continue le timer
                    }
                    clearTimeout(longPressTimer);
                };

                this.canvas.addEventListener('touchmove', cancelLongPress, { passive: false });
                this.canvas.addEventListener('touchend', cancelLongPress, { passive: false });
                this.canvas.addEventListener('touchcancel', cancelLongPress, { passive: false });
                // --- ZOOM (Molette) ---
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const zoomIntensity = 0.1;
                    const direction = e.deltaY < 0 ? 1 : -1;
                    const factor = (direction > 0) ? (1 + zoomIntensity) : (1 / (1 + zoomIntensity));

                    const mouse = this.getMousePos(e);

                    this.view.zoom *= factor;

                    this.view.x = mouse.screenX - (mouse.x * this.view.zoom);
                    this.view.y = mouse.screenY - (mouse.y * this.view.zoom);

                    this.render();
                }, { passive: false });

                const menu = document.getElementById('contextMenu');
                const handle = document.getElementById('menuDragHandle');

                let isDraggingMenu = false;
                let startX, startY, initialLeft, initialTop;

                handle.addEventListener('mousedown', (e) => {
                    isDraggingMenu = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = menu.getBoundingClientRect();
                    initialLeft = rect.left;
                    initialTop = rect.top;
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDraggingMenu) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    menu.style.left = `${initialLeft + dx}px`;
                    menu.style.top = `${initialTop + dy}px`;
                });

                window.addEventListener('mouseup', () => {
                    isDraggingMenu = false;
                });

                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const {
                        x,
                        y
                    } = this.getMousePos(e);

                    const targets = this.entities.filter(ent => ent.isNear(x, y));

                    targets.sort((a, b) => {
                        if (a instanceof Point) return 1;
                        if (b instanceof Point) return -1;
                        if (a instanceof Angle) return 1;
                        if (b instanceof Angle) return -1;
                        if (a instanceof Polygon) return 1;
                        if (b instanceof Polygon) return -1;
                        return 0;
                    });

                    if (targets.length > 0) {
                        this.selectedObject = targets.pop();
                        this.updateContextMenuUI();

                        const rowMeasure = document.getElementById('rowMeasure');
                        const rowCoding = document.getElementById('rowCoding');
                        const rowAngle = document.getElementById('rowAngle');
                        const rowStyle = document.getElementById('rowStyle');
                        const sep1 = document.getElementById('sep1');
                        const slider = document.getElementById('widthRange');

                        if (this.selectedObject instanceof Segment) {
                            rowMeasure.style.display = 'block';
                            rowCoding.style.cssText = "display: grid !important; grid-template-columns: repeat(4, 1fr); gap: 4px;";
                            this.updateContextMenuUI();
                        } else {
                            rowMeasure.style.display = 'none';
                            rowCoding.style.cssText = "display: none !important;";
                        }

                        const isPoint = this.selectedObject instanceof Point;
                        const rowPointStyle = document.getElementById('rowPointStyle')
                        const rowLabelPos = document.getElementById('rowLabelPos');
                        const rowRenamer = document.getElementById('rowRenamer');

                        if (isPoint) {
                            rowLabelPos.style.display = 'block';
                            rowRenamer.style.display = 'block';
                            rowPointStyle.style.display = 'flex';
                            rowTextProps.style.display = 'flex';
                            const btnEye = document.getElementById('btnToggleLabel');
                            if (this.selectedObject.showLabel) btnEye.classList.add('active');
                            else btnEye.classList.remove('active');
                            document.getElementById('renamerDisplay').innerText = this.selectedObject.label;

                            const angle = this.selectedObject.labelAngle || -Math.PI / 4;
                            const knob = document.getElementById('labelPosKnob');
                            const r = 24;
                            knob.style.left = (30 + Math.cos(angle) * r) + 'px';
                            knob.style.top = (30 + Math.sin(angle) * r) + 'px';

                            rowStyle.style.display = 'none';
                            sep1.style.display = 'none';
                        } else {
                            rowLabelPos.style.display = 'none';
                            rowTextProps.style.display = 'none';
                            rowRenamer.style.display = 'none';

                            rowStyle.style.display = 'flex';
                            sep1.style.display = 'block';
                            slider.value = this.selectedObject.lineWidth || 2;
                        }

                        if (this.selectedObject instanceof Angle) {
                            rowAngle.style.cssText = "display: flex !important; flex-direction: row; justify-content: center; gap: 8px;";
                            this.updateContextMenuUI();
                        } else {
                            rowAngle.style.cssText = "display: none !important;";
                        }

                        const menu = document.getElementById('contextMenu');
                        menu.style.left = e.clientX + 'px';
                        menu.style.top = e.clientY + 'px';
                        menu.style.display = 'flex';
                    }

                });
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#contextMenu')) document.getElementById('contextMenu').style.display = 'none';
                });

                this.canvas.onmousedown = (e) => {

                    // =========================================================================
                    // 1. S√âCURIT√âS & GESTION PANNING
                    // =========================================================================

                    if (e.button === 1 || (this.currentTool === 'pan' && e.button === 0)) {
                        this.isPanning = true;
                        this.lastMouseScreen = { x: e.clientX, y: e.clientY };
                        this.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                        return;
                    }

                    if (this.isLocked) return;

                    const menu = document.getElementById('contextMenu');
                    if (menu.style.display && menu.style.display !== 'none') {
                        menu.style.display = 'none';
                        return;
                    }

                    if (e.button !== 0 && e.button !== 2) return;


                    // =========================================================================
                    // 2. CALCUL DES COORDONN√âES (RAW vs SMART)
                    // =========================================================================
                    // AJOUT POUR TACTILE : Force la d√©tection sous le curseur/doigt au moment du clic
                    const mousePos = this.getMousePos(e);
                    this.hoveredEntities = this.entities.filter(ent => ent.isNear(mousePos.x, mousePos.y));

                    let smart;
                    if (this.getSmartCoords) {
                        smart = this.getSmartCoords(e);
                    } else {
                        const mp = this.getMousePos(e);
                        smart = { x: mp.x, y: mp.y };
                    }

                    let finalX = smart.x;
                    let finalY = smart.y;

                    if (this.activeWidgets.ruler && this.rulerWidget) {
                        const r = this.rulerWidget;
                        const rawMouse = this.getMousePos(e);
                        const local = r.toLocal(rawMouse.x, rawMouse.y);
                        const rulerZeroOffset = 0;

                        if (Math.abs(local.x - rulerZeroOffset) < 20 && Math.abs(local.y) < 30) {
                            finalX = r.x + rulerZeroOffset * Math.cos(r.angle);
                            finalY = r.y + rulerZeroOffset * Math.sin(r.angle);
                        }
                    }

                    const x = finalX;
                    const y = finalY;
                    const ghost = this.findIntersectionAtMouse(x, y);
                    let snapX = x;
                    let snapY = y;

                    if (ghost) {
                        snapX = ghost.x;
                        snapY = ghost.y;
                        this.ghostIntersection = ghost;
                    }


                    // =========================================================================
                    // 3. OUTIL "POT DE PEINTURE" (STYLE)
                    // =========================================================================
                    if (this.isPaintMode && e.button === 0) {
                        const target = [...this.entities].reverse().find(ent => ent.isNear(x, y));

                        if (target) {
                            target.color = this.globalStyle.color;
                            target.lineWidth = this.globalStyle.width;
                            target.dash = [...this.globalStyle.dash];

                            if (target instanceof Point) {
                                target.lineWidth = 2;
                            }

                            this.saveState();
                            this.render();
                        }
                        return;
                    }


                    // =========================================================================
                    // 4. D√âTECTION DES OBJETS SOUS LA SOURIS (HIT TESTING)
                    // =========================================================================
                    const entities = this.hoveredEntities || [];
                    const clickedPoint = entities.filter(ent => ent instanceof Point).pop();
                    const clickedText = entities.find(ent => ent instanceof TextLabel);
                    const clickedLinear = entities.filter(ent =>
                        ent instanceof LinearObject ||
                        ent instanceof ParallelLine ||
                        ent instanceof PerpendicularLine ||
                        ent instanceof Circle ||
                        ent instanceof Arc ||
                        ent instanceof Segment
                    ).pop();


                    // =========================================================================
                    // 5. GESTION DES WIDGETS (INTERACTION OUTILS)
                    // =========================================================================
                    let targetWidget = null;
                    let wType = '';

                    if (this.activeWidgets.ruler && this.rulerWidget && this.rulerWidget.getHitZone(x, y)) {
                        targetWidget = this.rulerWidget; wType = 'ruler';
                    } else if (this.activeWidgets.setsquare && this.setSquareWidget && this.setSquareWidget.getHitZone(x, y)) {
                        targetWidget = this.setSquareWidget; wType = 'setsquare';
                    } else if (this.activeWidgets.protractor && this.protractorWidget && this.protractorWidget.getHitZone(x, y)) {
                        targetWidget = this.protractorWidget; wType = 'protractor';
                    } else if (this.activeWidgets.compass && this.compassWidget && this.compassWidget.getHitZone(x, y)) {
                        targetWidget = this.compassWidget; wType = 'compass';
                    }

                    if (targetWidget) {
                        const zone = targetWidget.getHitZone(x, y);
                        if (zone) {
                            if (zone === 'toggleSwap' && targetWidget instanceof ProtractorWidget) {
                                targetWidget.isReversed = !targetWidget.isReversed;
                                this.render(); return;
                            }
                            if (zone === 'toggleLock' && targetWidget instanceof ProtractorWidget) {
                                targetWidget.isLocked = !targetWidget.isLocked;
                                this.render(); return;
                            }
                            if (zone === 'toggleSlide' && targetWidget instanceof SetSquareWidget) {
                                targetWidget.slideMode = !targetWidget.slideMode;
                            }
                            else {
                                this.draggedWidget = targetWidget;
                                this.draggedWidgetMode = zone;
                                this.widgetStartState = this.getWidgetState(targetWidget);
                                this.draggedWidgetType = wType;

                                if (zone === 'rotate') this.widgetRotationOffset = Math.atan2(y - targetWidget.y, x - targetWidget.x) - targetWidget.angle;

                                if (zone === 'slideX' || zone === 'slideY') {
                                    this.dragStartMouse = { x: x, y: y };
                                    this.dragStartWidget = { x: targetWidget.x, y: targetWidget.y };
                                }

                                if (targetWidget instanceof CompassWidget && zone === 'trace') {
                                    const w = targetWidget;
                                    w.isTracing = true;
                                    const startAngle = Math.atan2(snapY - w.y, snapX - w.x);
                                    w.startAngle = startAngle;
                                    this.widgetStartState.angle = startAngle;
                                    w.angle = startAngle;
                                    w.lastMouseAngle = startAngle;
                                    w.totalRotation = 0;
                                    this.currentTracingArc = null;
                                }

                                if (zone === 'move') {
                                    this.widgetOffset.x = x - targetWidget.x;
                                    this.widgetOffset.y = y - targetWidget.y;
                                }
                            }
                            this.render();
                            return;
                        }
                    }


                    // =========================================================================
                    // 6. √âDITEUR DE TEXTE
                    // =========================================================================
                    if (this.currentTool === 'text') {
                        if (this.editorDiv && this.editorDiv.style.display !== 'none') {
                            this.applyTextEdit();
                            return;
                        }
                        if (clickedPoint) this.startTextEditor(clickedPoint.x, clickedPoint.y, clickedPoint);
                        else if (clickedText) this.startTextEditor(clickedText.x, clickedText.y, clickedText);
                        else this.startTextEditor(smart.x, smart.y, null);

                        this.render();
                        return;
                    }


                    // =========================================================================
                    // 7. OUTILS DE DESSIN G√âOM√âTRIQUE (CLIC GAUCHE)
                    // =========================================================================
                    if (e.button !== 0) return;

                    if (this.replayIndex !== null && this.replayIndex < this.entities.length) {
                        this.replayIndex = this.entities.length;
                    }

                    const toolsModifying = ['point', 'segment', 'line', 'ray', 'circle', 'midpoint', 'parallel', 'perpendicular', 'delete', 'polygon', 'angle', 'compass'];
                    if (toolsModifying.includes(this.currentTool) || (this.currentTool === 'move' && (clickedPoint || clickedText))) {
                        this.saveState();
                    }

                    if (this.currentTool === 'move') {
                        if (clickedPoint && clickedPoint.parents.length !== 2) {
                            this.draggedPoint = clickedPoint;
                            this.dragStartPos = { x: clickedPoint.x, y: clickedPoint.y };
                        } else if (clickedText) {
                            this.draggedText = clickedText;
                            this.dragStartPos = { x: clickedText.x, y: clickedText.y };
                            this.dragOffset = { x: x - clickedText.x, y: y - clickedText.y };
                        }
                    }

                    else if (this.currentTool === 'point') {
                        this.createPointAt(x, y);
                    }

                    else if (['segment', 'ray', 'line', 'circle'].includes(this.currentTool)) {
                        this.creationStartPoint = this.createPointAt(x, y);
                        this.isDraggingCreation = true;
                    }

                    else if (this.currentTool === 'angle') {
                        const pt = this.createPointAt(x, y);
                        this.anglePoints.push(pt);
                        if (this.anglePoints.length === 3) {
                            const ang = new Angle(this.anglePoints[0], this.anglePoints[1], this.anglePoints[2]);
                            ang.color = this.globalStyle.color;
                            ang.lineWidth = this.globalStyle.width;
                            this.addEntity(ang);
                            this.anglePoints = [];
                            this.saveState();
                        }
                    }

                    else if (this.currentTool === 'polygon') {
                        if (clickedPoint && this.polygonPoints.length > 2 && clickedPoint === this.polygonPoints[0]) {
                            const poly = new Polygon([...this.polygonPoints]);
                            this.addEntity(poly);

                            for (let i = 0; i < this.polygonPoints.length; i++) {
                                const p1 = this.polygonPoints[i];
                                const p2 = this.polygonPoints[(i + 1) % this.polygonPoints.length];
                                const seg = new Segment(p1, p2);
                                seg.color = this.globalStyle.color;
                                seg.lineWidth = this.globalStyle.width;
                                seg.dash = [...this.globalStyle.dash];
                                this.addEntity(seg);
                            }
                            this.polygonPoints = [];
                            this.saveState();
                        } else {
                            this.polygonPoints.push(this.createPointAt(x, y));
                        }
                    }

                    else if (this.currentTool === 'midpoint') {
                        if (clickedLinear instanceof Segment) {
                            const mid = new Point(0, 0, this.getNextLabel(), [clickedLinear.p1, clickedLinear.p2]);
                            mid.update();
                            this.addEntity(mid);
                        } else if (clickedPoint) {
                            if (this.creationStartPoint && this.creationStartPoint !== clickedPoint) {
                                const mid = new Point(0, 0, this.getNextLabel(), [this.creationStartPoint, clickedPoint]);
                                mid.update();
                                this.addEntity(mid);
                                this.creationStartPoint = null;
                            } else {
                                this.creationStartPoint = clickedPoint;
                            }
                        }
                    }

                    else if (['parallel', 'perpendicular'].includes(this.currentTool)) {
                        if (clickedLinear) {
                            this.referenceObject = clickedLinear;
                            this.isDraggingCreation = true;
                        }
                    }

                    else if (['sym_central', 'sym_axial'].includes(this.currentTool)) {
                        let target = clickedPoint || clickedText || clickedLinear || this.hoveredEntities.filter(e => e instanceof Polygon).pop();

                        if (target) {
                            if (!this.transformationSource) {
                                this.transformationSource = target;
                                this.canvas.style.cursor = "copy";
                            } else {
                                let ref = target;
                                const mode = (this.currentTool === 'sym_central') ? 'central' : 'axial';
                                let valid = false;

                                if (mode === 'central' && ref instanceof Point) valid = true;
                                if (mode === 'axial' && (ref instanceof LinearObject || ref instanceof Segment || ref instanceof Line || ref instanceof Ray)) valid = true;

                                if (valid) {
                                    this.createSymmetry(this.transformationSource, ref, mode);
                                    this.transformationSource = null;
                                    this.canvas.style.cursor = "default";
                                }
                            }
                        }
                    }

                    else if (this.currentTool === 'delete') {
                        let target = clickedPoint || clickedText;
                        if (!target) target = this.entities.slice().reverse().find(e => e.isNear && e.isNear(smart.x, smart.y));

                        if (target) {
                            let listToDelete = this.getNetworkToDelete(target);

                            if (target instanceof Point) {
                                this.entities.forEach(poly => {
                                    if (poly instanceof Polygon) {
                                        const idx = poly.points.indexOf(target);
                                        if (idx !== -1) {
                                            const len = poly.points.length;
                                            const prevPoint = poly.points[(idx - 1 + len) % len];
                                            const nextPoint = poly.points[(idx + 1) % len];

                                            poly.points.splice(idx, 1);

                                            if (poly.points.length >= 3) {
                                                listToDelete = listToDelete.filter(item => item !== poly);

                                                const segmentExists = this.entities.some(e =>
                                                    e instanceof Segment &&
                                                    ((e.p1 === prevPoint && e.p2 === nextPoint) || (e.p1 === nextPoint && e.p2 === prevPoint))
                                                );
                                                if (!segmentExists) {
                                                    const newSeg = new Segment(prevPoint, nextPoint);
                                                    this.entities.push(newSeg);
                                                }
                                            }
                                        }
                                    }
                                });
                            }

                            this.entities = this.entities.filter(e => !listToDelete.includes(e));
                            this.toDeletePreview = [];
                            this.selectedObject = null;
                            this.saveState();
                            this.render();
                        }
                    }

                    this.render();
                };

                this.canvas.onmousemove = (e) => {
                    // =========================================================================
                    // 1. GESTION DU PANNING (D√âPLACEMENT DE LA VUE)
                    // =========================================================================
                    if (this.isPanning) {
                        const dx = e.clientX - this.lastMouseScreen.x;
                        const dy = e.clientY - this.lastMouseScreen.y;
                        this.view.x += dx;
                        this.view.y += dy;
                        this.lastMouseScreen = { x: e.clientX, y: e.clientY };
                        this.render();
                        return;
                    }

                    // =========================================================================
                    // 2. CALCUL DES COORDONN√âES & MAGN√âTISME (SNAP)
                    // =========================================================================
                    this.mousePos = this.getSmartCoords(e);

                    const ghost = this.findIntersectionAtMouse(this.mousePos.x, this.mousePos.y);

                    if (ghost) {
                        this.mousePos = { x: ghost.x, y: ghost.y, snapped: true };
                        this.ghostIntersection = ghost;
                    } else {
                        this.ghostIntersection = null;
                    }

                    const { x, y } = this.mousePos;


                    // =========================================================================
                    // 3. LOGIQUE DE DRAG & DROP DES WIDGETS (OUTILS)
                    // =========================================================================
                    if (this.draggedWidget) {
                        const w = this.draggedWidget;
                        const mode = this.draggedWidgetMode;

                        // A. D√âPLACEMENT DE L'OUTIL (MOVE)
                        if (mode === 'move') {
                            let targetX = x - this.widgetOffset.x;
                            let targetY = y - this.widgetOffset.y;

                            const snap = this.findIntersectionAtMouse(targetX, targetY);

                            if (snap) {
                                w.x = snap.x;
                                w.y = snap.y;
                                this.ghostIntersection = snap;
                            } else {
                                w.x = targetX;
                                w.y = targetY;
                                const allPoints = this.entities.filter(ent => ent instanceof Point);
                                for (let pt of allPoints) {
                                    if (MathUtils.dist(w.x, w.y, pt.x, pt.y) < 15) {
                                        w.x = pt.x;
                                        w.y = pt.y;
                                        break;
                                    }
                                }
                            }
                        }
                        // B. GLISSEMENT SUR AXES (EQUERRE/R√àGLE)
                        else if (mode === 'slideX' || mode === 'slideY') {
                            const dx = x - this.dragStartMouse.x;
                            const dy = y - this.dragStartMouse.y;
                            let axisAngle = w.angle;
                            if (mode === 'slideY') axisAngle += Math.PI / 2;

                            const dot = dx * Math.cos(axisAngle) + dy * Math.sin(axisAngle);
                            w.x = this.dragStartWidget.x + dot * Math.cos(axisAngle);
                            w.y = this.dragStartWidget.y + dot * Math.sin(axisAngle);
                        }
                        // C. ROTATION
                        else if (mode === 'rotate') {
                            const angleMouse = Math.atan2(y - w.y, x - w.x);
                            let newAngle = angleMouse - this.widgetRotationOffset;

                            let snappedAngle = null;
                            let bestDist = 25;

                            for (let ent of this.entities) {
                                if (ent instanceof Point) {
                                    const distMousePoint = MathUtils.dist(x, y, ent.x, ent.y);
                                    if (distMousePoint < bestDist) {
                                        const angleToPoint = Math.atan2(ent.y - w.y, ent.x - w.x);
                                        const norm = (a) => (a + Math.PI * 4) % (Math.PI * 2);

                                        const targetA = norm(angleToPoint);
                                        const targetB = norm(angleToPoint + Math.PI);
                                        const currentForCalc = norm(newAngle);

                                        const distA = Math.min(Math.abs(currentForCalc - targetA), 2 * Math.PI - Math.abs(currentForCalc - targetA));
                                        const distB = Math.min(Math.abs(currentForCalc - targetB), 2 * Math.PI - Math.abs(currentForCalc - targetB));

                                        if (distA < distB) snappedAngle = angleToPoint;
                                        else snappedAngle = angleToPoint + Math.PI;
                                        bestDist = distMousePoint;
                                    }
                                }
                            }
                            w.angle = (snappedAngle !== null) ? snappedAngle : newAngle;
                        }
                        // D. REDIMENSIONNEMENT (COMPAS)
                        else if (mode === 'resize' && w instanceof CompassWidget) {
                            let newRadius = MathUtils.dist(x, y, w.x, w.y);
                            const snap = this.entities.filter(ent => ent instanceof Point).find(p => MathUtils.dist(x, y, p.x, p.y) < 15);

                            if (snap) {
                                newRadius = MathUtils.dist(w.x, w.y, snap.x, snap.y);
                                w.angle = Math.atan2(snap.y - w.y, snap.x - w.x);
                            } else {
                                w.angle = Math.atan2(y - w.y, x - w.x);
                            }
                            w.radius = newRadius;
                        }
                        // E. TRAC√â (COMPAS)
                        else if (mode === 'trace' && w instanceof CompassWidget) {
                            const currentAngle = Math.atan2(y - w.y, x - w.x);
                            let diff = currentAngle - w.lastMouseAngle;

                            while (diff > Math.PI) diff -= 2 * Math.PI;
                            while (diff < -Math.PI) diff += 2 * Math.PI;

                            let nextTotal = w.totalRotation + diff;
                            const TWO_PI = Math.PI * 2;

                            if (nextTotal > TWO_PI) nextTotal = TWO_PI - 0.001;
                            if (nextTotal < -TWO_PI) nextTotal = -TWO_PI + 0.001;

                            w.totalRotation = nextTotal;
                            w.lastMouseAngle = currentAngle;
                            w.angle = w.startAngle + w.totalRotation;

                            const isCCW = (w.totalRotation < 0);

                            if (this.currentTracingArc) {
                                const idx = this.entities.indexOf(this.currentTracingArc);
                                if (idx !== -1) this.entities.splice(idx, 1);
                                this.currentTracingArc = null;
                            }

                            if (Math.abs(w.totalRotation) > 0.01) {
                                const center = { x: w.x, y: w.y };
                                const centerPoint = this.entities.filter(ent => ent instanceof Point && MathUtils.dist(ent.x, ent.y, center.x, center.y) < 5).pop();

                                this.currentTracingArc = new CompassArc(
                                    centerPoint || center,
                                    w.radius,
                                    w.startAngle,
                                    w.startAngle + w.totalRotation,
                                    isCCW
                                );
                                this.currentTracingArc.color = app.globalStyle.color;
                                this.currentTracingArc.lineWidth = this.globalStyle.width;
                                this.addEntity(this.currentTracingArc);
                            }
                        }

                        this.render();
                        return;
                    }


                    // =========================================================================
                    // 4. LOGIQUE DE D√âPLACEMENT D'ENTIT√âS (POINTS, TEXTE)
                    // =========================================================================
                    if (this.currentTool === 'move') {
                        if (this.draggedPoint) {
                            if (this.draggedPoint.parents.length === 1) {
                                const pObj = this.draggedPoint.parents[0];
                                const p = Array.isArray(pObj) ? { constructor: { name: 'Segment' }, p1: pObj[0], p2: pObj[1] } : pObj;

                                const proj = MathUtils.getProjectedPoint(x, y, p);
                                this.draggedPoint.x = proj.x;
                                this.draggedPoint.y = proj.y;
                            } else {
                                this.draggedPoint.x = x;
                                this.draggedPoint.y = y;
                            }
                            this.updateDependents();
                        }
                        else if (this.draggedText) {
                            this.draggedText.x = x - this.dragOffset.x;
                            this.draggedText.y = y - this.dragOffset.y;
                            this.render();
                        }
                    }


                    // =========================================================================
                    // 5. SURVOL, CURSEURS ET SNAP OUTILS (MODE PASSIF)
                    // =========================================================================

                    this.hoveredEntities = this.entities.filter(ent => ent.isNear(x, y));

                    let cursor = 'default';
                    let activeWidget = null;

                    if (this.activeWidgets.compass && this.compassWidget.getHitZone(x, y)) activeWidget = this.compassWidget;
                    else if (this.activeWidgets.ruler && this.rulerWidget.getHitZone(x, y)) activeWidget = this.rulerWidget;
                    else if (this.activeWidgets.setsquare && this.setSquareWidget.getHitZone(x, y)) activeWidget = this.setSquareWidget;
                    else if (this.activeWidgets.protractor && this.protractorWidget.getHitZone(x, y)) activeWidget = this.protractorWidget;

                    if (activeWidget) {
                        const zone = activeWidget.getHitZone(x, y);
                        const cursors = {
                            'move': 'move',
                            'resize': 'ew-resize',
                            'slideY': 'col-resize',
                            'slideX': 'row-resize',
                            'rotate': 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'16\' height=\'16\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'black\' stroke-width=\'2.5\' stroke-linecap=\'round\' stroke-linejoin=\'round\' style=\'filter: drop-shadow(1px 1px 0px white);\'><path d=\'M21 2v6h-6\'/><path d=\'M3 22v-6h6\'/><path d=\'M2 11.5a10 10 0 0 1 18.8-4.3\'/><path d=\'M22 12.5a10 10 0 0 1-18.8 4.3\'/></svg>") 16 16, auto',
                            'trace': 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'black\' stroke-width=\'1.5\' stroke-linecap=\'round\' stroke-linejoin=\'round\' style=\'filter: drop-shadow(1px 1px 0px white);\'><path d=\'M18.5 2.5a2.121 2.121 0 0 1 3 3L7.5 20.5 2 22l1.5-5.5L18.5 2.5z\' fill=\'white\'/><path d=\'M2 22 L7.5 20.5 L3.5 16.5 Z\' fill=\'black\'/></svg>") 2 22, crosshair'
                        };
                        if (zone === 'traceAngle') cursors.traceAngle = cursors.trace;
                        if (cursors[zone]) cursor = cursors[zone];
                    }

                    if (this.currentTool === 'pan') {
                        cursor = this.isPanning ? 'grabbing' : 'grab';
                    } else if (['segment', 'line', 'point'].includes(this.currentTool) && cursor === 'default') {
                        cursor = 'crosshair';
                    } else if (['parallel', 'perpendicular'].includes(this.currentTool)) {
                        const clickedLinear = this.hoveredEntities.filter(e => e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine).pop();
                        if (clickedLinear) cursor = 'pointer';
                    }

                    if (this.currentTool === 'move' && this.hoveredEntities.length > 0 && !activeWidget) {
                        cursor = 'pointer';
                    }

                    this.canvas.style.cursor = cursor;

                    if (['segment', 'line', 'ray'].includes(this.currentTool) && this.activeWidgets.ruler) {
                        const r = this.rulerWidget;
                        const local = r.toLocal(x, y);
                        if (Math.abs(local.y) < 25 && local.x > -25 && local.x < r.width + 5) {
                            let snapX = local.x;
                            if (Math.abs(local.x) < 15) snapX = 0;
                            this.mousePos = {
                                x: r.x + snapX * Math.cos(r.angle),
                                y: r.y + snapX * Math.sin(r.angle)
                            };
                        }
                    }

                    this.render();
                };

                // =============================================================================
                // GESTIONNAIRE D'√âV√âNEMENT GLOBAL : MOUSEUP (FIN D'ACTION)
                // =============================================================================
                window.addEventListener('mouseup', () => {

                    // 1. GESTION DU PANNING (D√©placement de vue)
                    if (this.isPanning) {
                        this.isPanning = false;
                        return;
                    }

                    // 2. FIN D√âPLACEMENT D'UN POINT (Animation + Sauvegarde)
                    if (this.draggedPoint) {
                        const dx = this.draggedPoint.x - this.dragStartPos.x;
                        const dy = this.draggedPoint.y - this.dragStartPos.y;

                        if (Math.sqrt(dx * dx + dy * dy) > 1) {
                            const anim = new ToolAnimation('pointMove', this.dragStartPos, {
                                x: this.draggedPoint.x,
                                y: this.draggedPoint.y
                            });
                            anim.targetId = this.draggedPoint.id;
                            this.addEntity(anim);
                        }

                        this.saveState();
                        this.draggedPoint = null;
                    }

                    // 3. GESTION SP√âCIALE : TRAC√â RAPPORTEUR (Protractor)
                    if (this.draggedWidget instanceof ProtractorWidget && this.draggedWidgetMode === 'traceAngle') {
                        const w = this.draggedWidget;

                        let p1 = this.entities.find(e => e instanceof Point && MathUtils.dist(e.x, e.y, w.x, w.y) < 5);
                        if (!p1) {
                            p1 = new Point(w.x, w.y, this.getNextLabel());
                            this.addEntity(p1);
                        }

                        const p2 = new Point(this.mousePos.x, this.mousePos.y, this.getNextLabel());
                        this.addEntity(p2);

                        const ray = new Ray(p1, p2);
                        ray.color = this.globalStyle.color;
                        ray.lineWidth = this.globalStyle.width;
                        this.addEntity(ray);

                        this.saveState();
                        this.draggedWidget = null;
                        this.draggedWidgetMode = null;
                        this.render();
                        return;
                    }

                    // 4. GESTION G√âN√âRALE DES WIDGETS (R√®gle, Equerre, Compas)
                    if (this.draggedWidget) {
                        const w = this.draggedWidget;

                        const endState = this.getWidgetState(w);
                        let anim = null;

                        if (this.widgetStartState) {
                            const s = this.widgetStartState;
                            const e = endState;
                            const moved = (Math.abs(s.x - e.x) > 0.1 || Math.abs(s.y - e.y) > 0.1 || Math.abs(s.angle - e.angle) > 0.001 || Math.abs(s.radius - e.radius) > 0.1);

                            if (moved) {
                                anim = new ToolAnimation(this.draggedWidgetType, s, e);
                            }
                        }

                        if (w instanceof CompassWidget && this.draggedWidgetMode === 'trace') {

                            const rawEndAngle = w.startAngle + w.totalRotation;
                            const isCCW = (w.totalRotation < 0);

                            if (anim) {
                                anim.endState.angle = rawEndAngle;
                                anim.counterClockwise = isCCW;

                                const arcIndex = this.entities.indexOf(this.currentTracingArc);
                                if (arcIndex !== -1) this.entities.splice(arcIndex, 0, anim);
                                else this.entities.push(anim);
                            }

                            this.currentTracingArc.endAngle = rawEndAngle;
                            this.currentTracingArc.counterClockwise = isCCW;
                            this.saveState();

                            this.currentTracingArc = null;
                            w.isTracing = false;
                            w.totalRotation = 0;
                            w.lastMouseAngle = null;

                        } else {
                            if (anim) {
                                this.addEntity(anim);
                                this.saveState();
                            }
                        }

                        this.draggedWidget = null;
                        this.draggedWidgetMode = null;
                    }

                    // 5. GESTION CR√âATION DE FORMES (Segment, Ligne, Cercle...)
                    if (['segment', 'ray', 'line', 'circle'].includes(this.currentTool) && this.isDraggingCreation && this.creationStartPoint) {
                        const dist = Math.sqrt((this.mousePos.x - this.creationStartPoint.x) ** 2 + (this.mousePos.y - this.creationStartPoint.y) ** 2);

                        if (dist > 10) {
                            const endPoint = this.createPointAt(this.mousePos.x, this.mousePos.y);
                            let newObj;
                            if (this.currentTool === 'segment') newObj = new Segment(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'line') newObj = new Line(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'ray') newObj = new Ray(this.creationStartPoint, endPoint);
                            if (this.currentTool === 'circle') newObj = new Circle(this.creationStartPoint, endPoint);

                            if (newObj) {
                                newObj.color = this.globalStyle.color;
                                newObj.lineWidth = this.globalStyle.width;
                                newObj.dash = [...this.globalStyle.dash];
                                this.addEntity(newObj);
                                this.updateDependents();
                                this.saveState();
                            }
                        }
                        this.creationStartPoint = null;
                        this.isDraggingCreation = false;
                        this.render();
                    }

                    // 6. GESTION PARALL√àLE / PERPENDICULAIRE
                    if (['parallel', 'perpendicular'].includes(this.currentTool) && this.isDraggingCreation && this.referenceObject) {
                        const p1 = this.createPointAt(this.mousePos.x, this.mousePos.y);
                        let newObj;
                        if (this.currentTool === 'parallel') newObj = new ParallelLine(p1, this.referenceObject);
                        else newObj = new PerpendicularLine(p1, this.referenceObject);

                        newObj.color = this.globalStyle.color;
                        newObj.lineWidth = this.globalStyle.width;
                        newObj.dash = [...this.globalStyle.dash];

                        this.addEntity(newObj);
                        this.updateDependents();
                        this.saveState();
                        this.referenceObject = null;
                        this.isDraggingCreation = false;
                        this.render();
                    }

                    // 7. GESTION D√âPLACEMENT TEXTE (Animation)
                    if (this.draggedText) {
                        const dx = this.draggedText.x - this.dragStartPos.x;
                        const dy = this.draggedText.y - this.dragStartPos.y;

                        if (Math.sqrt(dx * dx + dy * dy) > 1) {
                            const anim = new ToolAnimation('textMove', this.dragStartPos, {
                                x: this.draggedText.x,
                                y: this.draggedText.y
                            });
                            anim.targetId = this.draggedText.id;
                            this.addEntity(anim);
                        }

                        this.saveState();
                        this.draggedText = null;
                    }

                    // 8. RESET LABEL ANGLE
                    if (typeof isDraggingLabel !== 'undefined' && isDraggingLabel) {
                        isDraggingLabel = false;
                    }
                });

                const box = document.getElementById('labelPosBox');
                const knob = document.getElementById('labelPosKnob');

                const updateLabelAngle = (e) => {
                    if (!this.selectedObject || !(this.selectedObject instanceof Point)) return;

                    const rect = box.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);

                    this.selectedObject.labelAngle = angle;

                    const r = 24;
                    knob.style.left = (30 + Math.cos(angle) * r) + 'px';
                    knob.style.top = (30 + Math.sin(angle) * r) + 'px';

                    this.render();
                };

                let isDraggingLabel = false;

                box.addEventListener('mousedown', (e) => {
                    isDraggingLabel = true;
                    updateLabelAngle(e);
                    e.preventDefault();
                });

                window.addEventListener('mousemove', (e) => {
                    if (isDraggingLabel) updateLabelAngle(e);
                });

                window.addEventListener('mouseup', () => {
                    if (isDraggingLabel) {
                        isDraggingLabel = false;
                        this.saveState();
                    }
                });

                const renamerDisplay = document.getElementById('renamerDisplay');

                renamerDisplay.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const direction = e.deltaY > 0 ? 1 : -1;
                    this.cyclePointName(direction);

                }, { passive: false });
            }

            drawCreationGhost() {


                if (this.creationStartPoint && this.isDraggingCreation && !['compass', 'protractor', 'setsquare', 'ruler'].includes(this.currentTool)) {
                    const start = this.creationStartPoint;
                    const end = this.mousePos;
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#555";
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    if (this.currentTool === 'segment') {
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                    } else if (this.currentTool === 'ray') {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(start.x + dx * 100, start.y + dy * 100);
                    } else if (this.currentTool === 'line') {
                        const dx = end.x - start.x;
                        const dy = end.y - start.y;
                        this.ctx.moveTo(start.x - dx * 100, start.y - dy * 100);
                        this.ctx.lineTo(start.x + dx * 100, start.y + dy * 100);
                    } else if (this.currentTool === 'circle') {
                        const r = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                        this.ctx.arc(start.x, start.y, r, 0, Math.PI * 2);
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);

                    // NEW: Add Length for Segment
                    if (this.currentTool === 'segment') {
                        const dist = MathUtils.dist(start.x, start.y, end.x, end.y);
                        const val = (dist / UNIT).toFixed(1);
                        const mx = (start.x + end.x) / 2;
                        const my = (start.y + end.y) / 2;
                        let angle = Math.atan2(end.y - start.y, end.x - start.x);
                        if (angle > Math.PI / 2 || angle < -Math.PI / 2) angle += Math.PI;
                        this.ctx.save();
                        this.ctx.translate(mx, my);
                        this.ctx.rotate(angle);
                        const text = val;
                        const w = this.ctx.measureText(text).width + 8;
                        this.ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                        this.ctx.fillRect(-w / 2, -20, w, 16);
                        this.ctx.fillStyle = "#333";
                        this.ctx.font = "14px Segoe UI";
                        this.ctx.textAlign = "center";
                        this.ctx.fillText(text, 0, -8);
                        this.ctx.restore();
                    }
                }

                // Angle Ghost
                if (this.currentTool === 'angle' && this.anglePoints.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#999";
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.moveTo(this.anglePoints[0].x, this.anglePoints[0].y);
                    if (this.anglePoints.length === 2) this.ctx.lineTo(this.anglePoints[1].x, this.anglePoints[1].y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.anglePoints.forEach(pt => {
                        this.ctx.beginPath();
                        this.ctx.fillStyle = "#333";
                        this.ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                }

                if (this.showTools && ['segment', 'ray', 'line'].includes(this.currentTool) && this.isDraggingCreation && this.creationStartPoint) {
                    this.drawRuler(this.ctx, this.creationStartPoint, this.mousePos);
                }
                if (!this.activeWidgets.setsquare && this.showTools && this.currentTool === 'perpendicular' && this.referenceObject && this.isDraggingCreation) {
                    this.drawPerpendicularHint(this.ctx, this.referenceObject, this.mousePos);
                }

                if (this.referenceObject && this.isDraggingCreation) {
                    const mouse = this.mousePos;
                    const ref = this.referenceObject;
                    const c = MathUtils.getLineCoords(ref);
                    const p1 = c.p1;
                    const p2 = c.p2;
                    if (p1 && p2) {
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        let color = "#444";
                        let width = 2;
                        if (this.currentTool === 'parallel') MathUtils.drawInfiniteLineFromVector(this.ctx, mouse.x, mouse.y, dx, dy, color, width, [5, 5]);
                        else MathUtils.drawInfiniteLineFromVector(this.ctx, mouse.x, mouse.y, -dy, dx, color, width, [5, 5]);
                        this.ctx.setLineDash([]);
                    }
                }

                if (this.activeWidgets.protractor && this.protractorWidget) this.protractorWidget.draw(this.ctx);
                if (this.activeWidgets.setsquare && this.setSquareWidget) this.setSquareWidget.draw(this.ctx);
                if (this.activeWidgets.ruler && this.rulerWidget) {
                    this.rulerWidget.draw(this.ctx);
                    // Draw Magnet Indicator only if hovering zero and active and NOT DRAGGING RULER
                    const l = this.rulerWidget.toLocal(this.mousePos.x, this.mousePos.y);
                    const startX = -20;

                    // Check if snapping for drawing (mouse is at 0) OR if just hovering near zero
                    if (['segment', 'line', 'ray'].includes(this.currentTool) && Math.abs(l.x) < 2 && Math.abs(l.y) < 2) {
                        const ang = this.rulerWidget.angle;
                        const zx = this.rulerWidget.x; //+ (-20) * Math.cos(ang);
                        const zy = this.rulerWidget.y; // + (-20) * Math.sin(ang);
                        this.ctx.beginPath();
                        this.ctx.moveTo(zx - 5, zy);
                        this.ctx.lineTo(zx + 5, zy);
                        this.ctx.moveTo(zx, zy - 5);
                        this.ctx.lineTo(zx, zy + 5);
                        this.ctx.strokeStyle = "red";
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }

                // Visual indicators for SetSquare and Protractor Snapping to Points
                if (this.activeWidgets.setsquare && this.setSquareWidget) {
                    this.setSquareWidget.draw(this.ctx);
                    // If drawing near snap
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.setSquareWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 2 && Math.abs(l.y) < 2) {
                            const ang = this.setSquareWidget.angle;
                            const zx = this.setSquareWidget.x;
                            const zy = this.setSquareWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
                if (this.activeWidgets.protractor && this.protractorWidget) {
                    this.protractorWidget.draw(this.ctx);
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.protractorWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 2 && Math.abs(l.y) < 2) {
                            const zx = this.protractorWidget.x;
                            const zy = this.protractorWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }
                // Compass snap
                if (this.activeWidgets.compass && this.compassWidget) {
                    // Check needle tip
                    if (['segment', 'line', 'ray'].includes(this.currentTool)) {
                        const l = this.compassWidget.toLocal(this.mousePos.x, this.mousePos.y);
                        if (Math.abs(l.x) < 2 && Math.abs(l.y) < 2) {
                            const zx = this.compassWidget.x;
                            const zy = this.compassWidget.y;
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(zx, zy, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }

                    // Show snap indicator for resize if dragging knob
                    if (this.draggedWidget === this.compassWidget && this.draggedWidgetMode === 'resize') {
                        const snap = this.entities.filter(ent => ent instanceof Point).find(p => MathUtils.dist(this.mousePos.x, this.mousePos.y, p.x, p.y) < 15);
                        if (snap) {
                            this.ctx.beginPath();
                            this.ctx.strokeStyle = "red";
                            this.ctx.lineWidth = 2;
                            this.ctx.arc(snap.x, snap.y, 8, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    }
                }

                // --- TRAC√â ASSIST√â DU RAPPORTEUR ---
                if (this.draggedWidget instanceof ProtractorWidget && this.draggedWidgetMode === 'traceAngle') {
                    const w = this.draggedWidget;
                    const start = {
                        x: w.x,
                        y: w.y
                    };
                    const end = this.mousePos;

                    const rawAngle = Math.atan2(end.y - start.y, end.x - start.x);

                    // 1. Ligne Rouge (On isole le style ici aussi par s√©curit√©)
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "#e74c3c";
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.moveTo(start.x, start.y);
                    this.ctx.lineTo(start.x + Math.cos(rawAngle) * 2000, start.y + Math.sin(rawAngle) * 2000);
                    this.ctx.stroke();
                    this.ctx.restore();

                    // 2. Calculs
                    let deg = (rawAngle - w.angle) * 180 / Math.PI;
                    while (deg < 0) deg += 360;
                    while (deg >= 360) deg -= 360;
                    if (deg > 180) deg = 360 - deg;

                    const val1 = Math.round(deg);
                    const val2 = 180 - val1;
                    let txt = ``;
                    if (w.isReversed) { txt = `${val1}¬∞ / ${val2}¬∞`; } else { txt = `${val2}¬∞ / ${val1}¬∞`; }
                    this.ctx.save();
                    this.ctx.font = "bold 14px Segoe UI";
                    this.ctx.textBaseline = "middle";
                    this.ctx.textAlign = "center";

                    const tw = this.ctx.measureText(txt).width;
                    const padding = 8;
                    const textDist = w.radius + 45;
                    const labelX = start.x + Math.cos(rawAngle) * textDist;
                    const labelY = start.y + Math.sin(rawAngle) * textDist;

                    // Fond blanc
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                    this.ctx.strokeStyle = "#e74c3c";
                    this.ctx.lineWidth = 1;
                    this.ctx.rect(labelX - tw / 2 - padding, labelY - 12, tw + padding * 2, 24);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Texte
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.fillText(txt, labelX, labelY);

                    // Centre
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.arc(start.x, start.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    this.ctx.restore(); // <--- ON REMET TOUT PROPRE
                }

            }

            render() {
                //  if (this.compassWidget) this.compassWidget.replayTrace = null;
                // 1. Reset de la matrice (pour effacer tout l'√©cran proprement)
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 2. Application de la Cam√©ra (Zoom/Pan)
                this.ctx.setTransform(this.view.zoom, 0, 0, this.view.zoom, this.view.x, this.view.y);

                // 3. Dessin de la grille (Adapt√©e √† la vue)
                this.drawGrid();
                if (this.isMagnetActive && this.activeSnapPoint) {
                    const snap = this.activeSnapPoint;
                    this.ctx.save();
                    // Halo orange
                    this.ctx.beginPath();
                    this.ctx.arc(snap.x, snap.y, 1, 0, Math.PI * 2);
                    this.ctx.fillStyle = "rgba(230, 126, 34, 0.4)";
                    this.ctx.fill();
                    this.ctx.strokeStyle = "#e67e22";
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();

                    // Point central rouge pr√©cis
                    this.ctx.beginPath();
                    this.ctx.arc(snap.x, snap.y, 3, 0, Math.PI * 2);
                    this.ctx.fillStyle = "#e74c3c";
                    this.ctx.fill();

                    this.ctx.restore();
                }
                const limit = (this.replayIndex !== null && this.replayIndex < this.entities.length) ? this.replayIndex : this.entities.length;

                const zIndex = {
                    'Polygon': 0,
                    'Angle': 0,
                    'CompassArc': 1,
                    'Arc': 1,
                    'Circle': 1,
                    'Line': 1,
                    'Ray': 1,
                    'Segment': 1,
                    'ParallelLine': 1,
                    'PerpendicularLine': 1,
                    'Point': 2
                };

                const toDraw = this.entities.slice(0, limit);
                toDraw.sort((a, b) => {
                    const zA = zIndex[a.constructor.name] || 0;
                    const zB = zIndex[b.constructor.name] || 0;
                    return zA - zB;
                });

                for (const entity of toDraw) {
                    if (entity instanceof ToolAnimation) continue;
                    if (this.isPlaying) {
                        const entityBeingCreated = this.entities[this.replayIndex + 1];
                        //     if (entity === entityBeingCreated && entity instanceof CompassArc) {
                        //         continue;
                        //    }
                    }
                    const isSelected = (entity === this.creationStartPoint) || (entity === this.referenceObject) || (entity === this.compassP1) || this.anglePoints.includes(entity);
                    const isHovered = this.hoveredEntities.includes(entity);
                    const isToDelete = this.toDeletePreview.includes(entity);

                    entity.draw(this.ctx, {
                        isSelected,
                        isHovered,
                        isToDelete
                    });
                }

                // Animation Encre
                if (this.isPlaying && this.isToolAnimating) {
                    const anim = this.entities[this.replayIndex];
                    //  console.log(this.entities[this.replayIndex]);
                    const nextIndex = this.replayIndex + 1;
                    if (nextIndex < this.entities.length) {
                        const nextEnt = this.entities[nextIndex];
                        const isTracing = nextEnt instanceof CompassArc;
                        if (anim instanceof ToolAnimation && anim.widgetType === 'compass' && isTracing && this.compassWidget) {
                            const w = this.compassWidget;
                            const sAngle = anim.startState.angle;
                            let drawEnd = w.angle;

                            // 2. On r√©cup√®re la VRAIE intention (le sens enregistr√©)
                            // C'est la seule v√©rit√© absolue.
                            const sens = nextEnt.counterClockwise;
                            if (this.ArcTracing) {

                                this.ctx.beginPath();

                                // 4. On dessine avec l'angle corrig√© "drawEnd"

                                this.ctx.arc(w.x, w.y, w.radius, sAngle, drawEnd, sens)
                                this.ctx.strokeStyle = "black"; // A CHANGER
                                this.ctx.lineWidth = 2;
                                this.ctx.stroke();
                            }
                            this.ArcTracing = true;
                        }
                        else { this.ArcTracing = false; }
                    }
                }

                this.drawCreationGhost();


                if (this.currentTool === 'polygon' && this.polygonPoints.length > 0) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.polygonPoints[0].x, this.polygonPoints[0].y);
                    for (let i = 1; i < this.polygonPoints.length; i++) this.ctx.lineTo(this.polygonPoints[i].x, this.polygonPoints[i].y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.strokeStyle = "#00bcd4";
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.polygonPoints.forEach(p => p.draw(this.ctx, {}));
                }
                if (this.currentTool === 'angle') {
                    this.anglePoints.forEach(p => p.draw(this.ctx, {
                        isSelected: true
                    }));
                }

                if (this.ghostIntersection) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.ghostIntersection.x, this.ghostIntersection.y, 6, 0, Math.PI * 2);
                    this.ctx.fillStyle = "rgba(100, 100, 100, 0.5)";
                    this.ctx.fill();
                    this.ctx.strokeStyle = "#fff";
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }

                if (this.activeWidgets.ruler) this.rulerWidget.draw(this.ctx);
                if (this.activeWidgets.setsquare) this.setSquareWidget.draw(this.ctx);
                if (this.activeWidgets.protractor) this.protractorWidget.draw(this.ctx);
                if (this.activeWidgets.compass) this.compassWidget.draw(this.ctx);
            }

            exportSVG() {
                const getHex = (c) => (!c ? '#000000' : c);

                // 1. Pr√©-analyse : On collecte les motifs n√©cessaires par couleur
                // On utilise un Map pour ne pas cr√©er 50 fois le motif "Rouge"
                const definitions = new Map();

                this.entities.forEach(e => {
                    if (e instanceof Polygon && (e.fillMode === 'hatch' || e.fillMode === 'dots')) {
                        const color = getHex(e.color || '#000000');
                        const cleanColor = color.replace('#', ''); // ex: 2980b9

                        // ID unique par type et couleur (ex: hatch-2980b9)
                        const id = `${e.fillMode}-${cleanColor}`;

                        if (!definitions.has(id)) {
                            let patternDef = '';
                            if (e.fillMode === 'hatch') {
                                patternDef = `<pattern id="${id}" width="10" height="10" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                        <line x1="0" y1="0" x2="0" y2="10" stroke="${color}" stroke-width="1" />
                    </pattern>`;
                            } else if (e.fillMode === 'dots') {
                                patternDef = `<pattern id="${id}" width="6" height="6" patternUnits="userSpaceOnUse">
                        <circle cx="3" cy="3" r="1" fill="${color}" />
                    </pattern>`;
                            }
                            definitions.set(id, patternDef);
                        }
                    }
                });

                // 2. Construction des <defs>
                const defsContent = Array.from(definitions.values()).join('\n');

                // 3. En-t√™te SVG
                let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${this.canvas.width}" height="${this.canvas.height}" viewBox="0 0 ${this.canvas.width} ${this.canvas.height}" style="background:white">
    <defs>
        ${defsContent}
    </defs>`;

                // 4. Tri Z-Index
                const zIndex = { 'Polygon': 0, 'Angle': 0, 'CompassArc': 1, 'Arc': 1, 'Circle': 1, 'Line': 1, 'Ray': 1, 'Segment': 1, 'ParallelLine': 1, 'PerpendicularLine': 1, 'Point': 2, 'TextLabel': 2 };

                const toExport = this.entities.slice().sort((a, b) => {
                    const zA = zIndex[a.constructor.name] || 0;
                    const zB = zIndex[b.constructor.name] || 0;
                    return zA - zB;
                });

                toExport.forEach(e => {
                    if (e instanceof ToolAnimation) return;
                    if (!e.visible && e instanceof Point) return;

                    const color = getHex(e.color || 'black');
                    const width = e.lineWidth || 2;
                    const dash = e.dash && e.dash.length > 0 ? `stroke-dasharray="${e.dash.join(',')}"` : "";

                    // --- POLYGONES ---
                    if (e instanceof Polygon) {
                        const pts = e.points.map(p => `${p.x},${p.y}`).join(' ');
                        let fillAttr = `fill="${color}" fill-opacity="0.2"`; // D√©faut Solid

                        if (e.fillMode === 'none') {
                            fillAttr = 'fill="none"';
                        }
                        else if (e.fillMode === 'hatch' || e.fillMode === 'dots') {
                            const cleanColor = color.replace('#', '');
                            const id = `${e.fillMode}-${cleanColor}`;
                            // On appelle l'ID unique g√©n√©r√© plus haut
                            fillAttr = `fill="url(#${id})"`;
                        }

                        svgContent += `<polygon points="${pts}" ${fillAttr} stroke="${color}" stroke-width="1" ${dash} />`;
                    }

                    // --- POINTS ---
                    else if (e instanceof Point) {
                        const style = e.pointStyle || 'cross';
                        if (style === 'dot') svgContent += `<circle cx="${e.x}" cy="${e.y}" r="4" fill="${color}" stroke="${color}" stroke-width="1" />`;
                        else if (style === 'pixel') svgContent += `<rect x="${e.x - 2.5}" y="${e.y - 2.5}" width="5" height="5" fill="${color}" stroke="${color}" stroke-width="1" />`;
                        else svgContent += `<path d="M${e.x - 3} ${e.y - 3} L${e.x + 3} ${e.y + 3} M${e.x + 3} ${e.y - 3} L${e.x - 3} ${e.y + 3}" stroke="${color}" stroke-width="${width > 2 ? width : 2}" stroke-linecap="round"/>`;

                        if (e.label && e.showLabel) {
                            const fs = e.fontSize || 14;
                            const angle = (e.labelAngle !== undefined) ? e.labelAngle : -Math.PI / 4;
                            const dist = 12 + fs / 2;
                            const lx = e.x + Math.cos(angle) * dist;
                            const ly = e.y + Math.sin(angle) * dist;
                            svgContent += `<text x="${lx}" y="${ly}" font-family="Arial" font-weight="bold" font-size="${fs}" fill="black" text-anchor="middle" dominant-baseline="middle">${e.label}</text>`;
                        }
                    }

                    // --- TEXTE ---
                    else if (e instanceof TextLabel) {
                        const safeText = e.text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        // On utilise les vraies valeurs
                        const fs = e.fontSize || 16;
                        // Nettoyage sommaire de la font family pour le SVG (enlever les ' superflus parfois)
                        const ff = (e.fontFamily || 'Segoe UI').replace(/'/g, "");

                        svgContent += `<text x="${e.x}" y="${e.y}" font-family="${ff}" font-size="${fs}" fill="${color}" text-anchor="middle" dominant-baseline="middle">${safeText}</text>`;
                    }

                    // --- LIGNES ---
                    else if (e instanceof LinearObject || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                        const c = MathUtils.getLineCoords(e);
                        if (c.p1 && c.p2) {
                            let x1 = c.p1.x, y1 = c.p1.y, x2 = c.p2.x, y2 = c.p2.y;
                            if (e instanceof Line || e instanceof ParallelLine || e instanceof PerpendicularLine) {
                                const dx = x2 - x1, dy = y2 - y1;
                                x1 -= dx * 100; y1 -= dy * 100; x2 += dx * 100; y2 += dy * 100;
                            } else if (e instanceof Ray) {
                                const dx = x2 - x1, dy = y2 - y1;
                                x2 += dx * 100; y2 += dy * 100;
                            }
                            svgContent += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${color}" stroke-width="${width}" ${dash} stroke-linecap="round" />`;

                            if (e instanceof Segment) {
                                const mx = (c.p1.x + c.p2.x) / 2;
                                const my = (c.p1.y + c.p2.y) / 2;
                                const angleDeg = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x) * 180 / Math.PI;

                                if (e.coding && e.coding !== 'mark-none') {
                                    let pathData = "";
                                    const h = 6;
                                    if (e.coding === 'mark-1') pathData = `M 0 -${h} L 0 ${h}`;
                                    else if (e.coding === 'mark-2') pathData = `M -2 -${h} L -2 ${h} M 2 -${h} L 2 ${h}`;
                                    else if (e.coding === 'mark-3') pathData = `M -4 -${h} L -4 ${h} M 0 -${h} L 0 ${h} M 4 -${h} L 4 ${h}`;
                                    else if (e.coding === 'mark-x') pathData = `M -4 -4 L 4 4 M -4 4 L 4 -4`;
                                    else if (e.coding === 'mark-xx') pathData = `M -8 -3 L -2 3 M -8 3 L -2 -3 M 2 -3 L 8 3 M 2 3 L 8 -3`;

                                    if (pathData) svgContent += `<path d="${pathData}" stroke="${color}" stroke-width="2" fill="none" transform="translate(${mx},${my}) rotate(${angleDeg})" />`;

                                    if (e.coding === 'mark-o') svgContent += `<circle cx="0" cy="0" r="4" stroke="${color}" stroke-width="2" fill="none" transform="translate(${mx},${my})" />`;
                                    else if (e.coding === 'mark-oo') svgContent += `<g transform="translate(${mx},${my}) rotate(${angleDeg})"><circle cx="-5" cy="0" r="3" stroke="${color}" stroke-width="2" fill="none"/><circle cx="5" cy="0" r="3" stroke="${color}" stroke-width="2" fill="none"/></g>`;
                                }

                                if (e.showLength) {
                                    const dist = MathUtils.dist(c.p1.x, c.p1.y, c.p2.x, c.p2.y);
                                    const val = (dist / UNIT).toFixed(1);
                                    let angleRad = Math.atan2(c.p2.y - c.p1.y, c.p2.x - c.p1.x);
                                    let off = e.measureOffset;
                                    if (Math.abs(angleRad) > Math.PI / 2) { angleRad += Math.PI; off = -off; }
                                    const txtAngle = angleRad * 180 / Math.PI;
                                    svgContent += `<rect x="-15" y="${off - 10}" width="30" height="16" fill="white" fill-opacity="0.8" transform="translate(${mx},${my}) rotate(${txtAngle})" />`;
                                    svgContent += `<text x="0" y="${off}" font-family="Segoe UI" font-size="14" fill="${color}" text-anchor="middle" dominant-baseline="middle" transform="translate(${mx},${my}) rotate(${txtAngle})">${val}</text>`;
                                }
                            }
                        }
                    }

                    // --- CERCLES & ARCS ---
                    else if (e instanceof Circle || e instanceof CompassCircle) {
                        const p1 = e.p1 || e.center;
                        const radius = (e.getRadius) ? e.getRadius() : MathUtils.dist(e.p1.x, e.p1.y, e.p2.x, e.p2.y);
                        if (p1) svgContent += `<circle cx="${p1.x}" cy="${p1.y}" r="${radius}" stroke="${color}" stroke-width="${width}" ${dash} fill="none" />`;
                    }
                    else if (e instanceof Arc || e instanceof CompassArc) {
                        if (e.center) {
                            const startX = e.center.x + e.radius * Math.cos(e.startAngle);
                            const startY = e.center.y + e.radius * Math.sin(e.startAngle);
                            const endX = e.center.x + e.radius * Math.cos(e.endAngle);
                            const endY = e.center.y + e.radius * Math.sin(e.endAngle);
                            let diff = e.endAngle - e.startAngle;
                            if (e.counterClockwise) { if (diff > 0) diff -= 2 * Math.PI; }
                            else { if (diff < 0) diff += 2 * Math.PI; }
                            const largeArc = Math.abs(diff) > Math.PI ? 1 : 0;
                            const sweep = e.counterClockwise ? 0 : 1;
                            svgContent += `<path d="M ${startX} ${startY} A ${e.radius} ${e.radius} 0 ${largeArc} ${sweep} ${endX} ${endY}" stroke="${color}" stroke-width="${width}" ${dash} fill="none" />`;
                        }
                    }

                    // --- ANGLES ---
                    else if (e instanceof Angle && e.p1 && e.p2 && e.p3) {
                        const val = e.getAngleValue();
                        const isRight = Math.abs(val - 90) < 0.5;
                        const radius = 25;
                        const a1 = Math.atan2(e.p1.y - e.p2.y, e.p1.x - e.p2.x);
                        const a2 = Math.atan2(e.p3.y - e.p2.y, e.p3.x - e.p2.x);

                        let fillAttr = 'fill="none"';
                        if (e.isFilled) fillAttr = `fill="${e.color ? e.color : 'green'}" fill-opacity="0.3"`;

                        if (isRight) {
                            const size = 16;
                            const d1 = MathUtils.dist(e.p2.x, e.p2.y, e.p1.x, e.p1.y);
                            const d2 = MathUtils.dist(e.p2.x, e.p2.y, e.p3.x, e.p3.y);
                            const ux = (e.p1.x - e.p2.x) / d1 * size, uy = (e.p1.y - e.p2.y) / d1 * size;
                            const vx = (e.p3.x - e.p2.x) / d2 * size, vy = (e.p3.y - e.p2.y) / d2 * size;
                            svgContent += `<path d="M ${e.p2.x + ux} ${e.p2.y + uy} L ${e.p2.x + ux + vx} ${e.p2.y + uy + vy} L ${e.p2.x + vx} ${e.p2.y + vy} L ${e.p2.x} ${e.p2.y} Z" stroke="${color}" stroke-width="${width}" ${fillAttr} />`;
                        } else {
                            const startX = e.p2.x + radius * Math.cos(a1);
                            const startY = e.p2.y + radius * Math.sin(a1);
                            const endX = e.p2.x + radius * Math.cos(a2);
                            const endY = e.p2.y + radius * Math.sin(a2);
                            let diff = a2 - a1;
                            if (e.isCounterClockwise) { if (diff < 0) diff += 2 * Math.PI; }
                            else { if (diff > 0) diff -= 2 * Math.PI; }
                            const largeArc = Math.abs(diff) > Math.PI ? 1 : 0;
                            const sweep = e.isCounterClockwise ? 1 : 0;
                            svgContent += `<path d="M ${e.p2.x} ${e.p2.y} L ${startX} ${startY} A ${radius} ${radius} 0 ${largeArc} ${sweep} ${endX} ${endY} Z" stroke="${color}" stroke-width="${width}" ${fillAttr} />`;
                        }
                        if (e.showValue && !isRight) {
                            let diff = a2 - a1;
                            if (e.isCounterClockwise) { if (diff < 0) diff += 2 * Math.PI; }
                            else { if (diff > 0) diff -= 2 * Math.PI; }
                            const midA = a1 + diff / 2;
                            const txtX = e.p2.x + (radius + 20) * Math.cos(midA);
                            const txtY = e.p2.y + (radius + 20) * Math.sin(midA);
                            const txtVal = Math.round(val) + "¬∞";
                            svgContent += `<rect x="${txtX - 15}" y="${txtY - 8}" width="30" height="16" fill="white" fill-opacity="0.7" rx="2" />`;
                            svgContent += `<text x="${txtX}" y="${txtY}" font-family="Segoe UI" font-size="12" font-weight="bold" fill="${color}" text-anchor="middle" dominant-baseline="middle">${txtVal}</text>`;
                        }
                    }
                });

                svgContent += `</svg>`;
                const blob = new Blob([svgContent], { type: "image/svg+xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                // Remplace : a.download = "figure_geosoft.svg";
                // Par :
                a.download = this.getSafeFilename('svg');
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                this.showToast("‚úíÔ∏è Fichier SVG export√© !");
            }
        }
        const app = new GeometrieApp("geoCanvas");
        window.app = app;

    </script>
</body>

</html>
